# 搜索

## 1.题目使用的树结构

```java
package com.yubin;

/**
 * 树结构
 */
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

# easy

## part1

### 1.[相同的树](https://leetcode-cn.com/problems/same-tree/)（dfs）

难度简单631收藏分享切换为英文接收动态反馈

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```java
package com.yubin.easy.part1;

public class IsSameTree {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        return dfs(p, q);
    }

    /**
     * dfs两棵树，判断两树是否相同
     */
    private boolean dfs(TreeNode p, TreeNode q) {
        if (p == null && q == null)
            return true;
        else if (p == null || q == null)
            return false;
        else if (p.val != q.val)
            return false;

        if (!dfs(p.left, q.left))
            return false;
        if (!dfs(p.right, q.right))
            return false;

        return true;
    }
}
```

### 2.[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)（dfs）

给定一个二叉树，检查它是否是镜像对称的。

```java
package com.yubin.easy.part1;

import com.yubin.TreeNode;

public class IsSymmetric {
    /**
     * 假设有两棵一模一样的数，分别前序遍历和后序遍历
     */
    public boolean isSymmetric1(TreeNode root) {
        return dfs(root, root);
    }

    private boolean dfs(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return true;
        if (root1 == null || root2 == null) return false;
        if (root1.val != root2.val) return false;
        if (!dfs(root1.left, root2.right)) return false;
        return dfs(root1.right, root2.left);
    }

    /**
     * 记录遍历得到的数
     */
    private StringBuilder sbPre = new StringBuilder();
    private StringBuilder sbPost = new StringBuilder();

    public boolean isSymmetric(TreeNode root) {
        dfs(root, 0);
        dfs(root, 1);
        String pre = sbPre.toString();
        String post = sbPost.toString();
        return pre.equals(post);
    }

    /**
     * 对称树前序和后序遍历结果一样
     */
    private void dfs(TreeNode root, int flag) {
        if (root == null) {
            if (flag == 0) sbPre.append('n');
            else sbPost.append('n');
            return;
        }
        if (flag == 0) {
            sbPre.append(root.val);
            dfs(root.left, flag);
            dfs(root.right, flag);
        } else {
            sbPost.append(root.val);
            dfs(root.right, flag);
            dfs(root.left, flag);
        }
    }

    public void test() {
        TreeNode right2 = new TreeNode(3);
        TreeNode left1 = new TreeNode(2, null, right2);

        TreeNode right22 = new TreeNode(3);
        TreeNode right1 = new TreeNode(2, null, right22);

        TreeNode root = new TreeNode(1, left1, right1);
        System.out.println(isSymmetric1(root));
    }

    public static void main(String[] args) {
        new IsSymmetric().test();
    }
}
```

### 3.[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)（dfs）

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

```java
package com.yubin.easy.part1;

import com.yubin.TreeNode;

public class MaxDepth {
    /**
     * 基于层析遍历思想
     */
    public int maxDepth2(TreeNode root) {
        if (root == null) return 0;
        List<TreeNode> level = new LinkedList<>();
        int depth = 0;
        level.add(root);
        while (true) {
            int count = 0, size = level.size();
            for (int i = 0; i < size; i++) {
                TreeNode tree = level.remove(0);
                TreeNode left = tree.left;
                TreeNode right = tree.right;
                if (left == null)
                    count++;
                else level.add(left);
                if (right == null)
                    count++;
                else level.add(right);
            }
            depth++;
            if (count == size * 2) return depth;
        }
    }

    /**
     * 求最大深度
     */
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
    
    private int depth = 0;
    private int maxDepth = 0;

    /**
     * 求最大深度
     */
    public int maxDepth1(TreeNode root) {
        dfs(root);
        return maxDepth;
    }

    private void dfs(TreeNode root) {
        depth++;
        if (root == null) {
            depth--;
            return;
        }
        maxDepth = Math.max(depth, maxDepth);
        dfs(root.left);
        dfs(root.right);
        depth--;
    }
}
```

### 4.[将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)（dfs）

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

```java
package com.yubin.easy.part1;

import com.yubin.TreeNode;

public class SortedArrayToBST {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums, 0, nums.length - 1);
    }

    /**
     * 以中间的数为根，数组左侧构建左子树，数组右侧构建右子树
     * dfs递归求解
     */
    private TreeNode dfs(int[] nums, int left, int right) {
        if (left > right) return null;
        int mid = (right - left) / 2 + left;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = dfs(nums, left, mid - 1);
        root.right = dfs(nums, mid + 1, right);
        return root;
    }

    public void test() {
        sortedArrayToBST(new int[]{1, 3});
    }

    public static void main(String[] args) {
        new SortedArrayToBST().test();
    }
}
```

### 5. [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)（dfs）

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```java
package com.yubin.easy.part1;

import com.yubin.TreeNode;

public class IsBalanced {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        if (Math.abs(depth(root.left) - depth(root.right)) > 1)
            return false;
        return isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(depth(root.left), depth(root.right));
    }
}
```

## part2

### 1.[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)（dfs+层序遍历）

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

 

```java
package com.yubin.easy.part2;

import com.sun.source.tree.Tree;
import com.yubin.TreeNode;

import java.util.LinkedList;
import java.util.List;

public class MinDepth {
    /**
     * 层序遍历思想
     */
    public int minDepth1(TreeNode root) {
        if (root == null) return 0;
        List<TreeNode> level = new LinkedList<>();
        level.add(root);
        int depth = 1;
        while (true) {
            int size = level.size();
            for (int i = 0; i < size; i++) {
                TreeNode tree = level.get(0);
                level.remove(0);
                if (tree != null)
                    if (tree.left == null && tree.right == null) return depth;
                    else {
                        level.add(tree.left);
                        level.add(tree.right);
                    }
            }
            depth++;
        }
    }

    /**
     * dfs求解方法
     */
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        return minDepthOfNode(root);
    }

    private int minDepthOfNode(TreeNode root) {
        if (root == null) return Integer.MAX_VALUE;
        if (root.left == null && root.right == null) return 1;
        return 1 + Math.min(minDepthOfNode(root.left), minDepthOfNode(root.right));
    }

    public void test() {
        System.out.println("em...");
    }

    public static void main(String[] args) {
        new MinDepth().test();
    }
}
```

# medium

## part1

### 1.[岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)(dfs)

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

 

示例 1:

> [[0,0,1,0,0,0,0,1,0,0,0,0,0],
>  [0,0,0,0,0,0,0,1,1,1,0,0,0],
>  [0,1,1,0,1,0,0,0,0,0,0,0,0],
>  [0,1,0,0,1,1,0,0,1,0,1,0,0],
>  [0,1,0,0,1,1,0,0,1,1,1,0,0],
>  [0,0,0,0,0,0,0,0,0,0,1,0,0],
>  [0,0,0,0,0,0,0,1,1,1,0,0,0],
>  [0,0,0,0,0,0,0,1,1,0,0,0,0]]
> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

```java
package com.yubin.medium.part1;

public class MaxAreaOfIsland {
    private int col;
    private int row;

    /**
     * dfs深度优先搜索
     */
    public int maxAreaOfIsland(int[][] grid) {
        col = grid.length;
        row = grid[0].length;
        boolean[][] mark = new boolean[col][row];
        int res = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                res = Math.max(dfs(grid, mark, i, j), res);
            }
        }
        return res;
    }

    /**
     * 深度优先搜索，求岛屿可以连接的最大值
     */
    private int dfs(int[][] grid, boolean[][] mark, int i, int j) {
        if (grid[i][j] == 0 || mark[i][j]) return 0;
        int res = 1;
        mark[i][j] = true;
        if (i - 1 >= 0) res += dfs(grid, mark, i - 1, j);
        if (j - 1 >= 0) res += dfs(grid, mark, i, j - 1);
        if (i + 1 < col) res += dfs(grid, mark, i + 1, j);
        if (j + 1 < row) res += dfs(grid, mark, i, j + 1);
        return res;
    }
}
```

### 2.[省份数量](https://leetcode-cn.com/problems/number-of-provinces/)(dfs)

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[ i [ j ] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

 

示例 1：

> 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
> 输出：2

```java
package com.yubin.medium.part1;

public class FindCircleNum {
    private int num;//省份数
    boolean[] mark;

    public int findCircleNum(int[][] isConnected) {
        num = isConnected.length;
        mark = new boolean[num];
        int res = 0;
        for (int i = 0; i < num; i++) {
            if (dfs(isConnected, i) != 0) res++;
        }
        return res;
    }

    /**
     * 为i省份搜索可以连通的城市
     */
    private int dfs(int[][] isConnected, int i) {
        if (mark[i]) return 0;
        mark[i] = true;
        int res = 1;
        for (int j = 0; j < num; j++) {
            if (isConnected[i][j] == 1) res += dfs(isConnected, j);
        }
        return res;
    }
}
```

### 3.[太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)（dfs）

给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

 

提示：

输出坐标的顺序不重要
m 和 n 都小于150


示例：

> 给定下面的 5x5 矩阵:
>
> 太平洋 ~   ~   ~   ~   ~ 
>     ~  1   2   2   3  (5) *
>     ~  3   2   3  (4) (4) *
>     ~  2   4  (5)  3   1  *
>     ~ (6) (7)  1   4   5  *
>     ~ (5)  1   1   2   4  *
>
> **   *   *   * 大西洋
>
> 返回:
>
> [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).

```java
package com.yubin.medium.part1;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class PacificAtlantic {
    /**
     * 确定边界
     */
    private int row;
    private int col;

    private boolean pOk[][];
    private boolean aOk[][];

    /**
     * dfs逆向遍历从边界出发，找到可以到达的点
     */
    public List<List<Integer>> pacificAtlantic1(int[][] heights) {
        row = heights.length;
        col = heights[0].length;
        pOk = new boolean[row][col];
        aOk = new boolean[row][col];
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < row; i++) {
            dfs(heights, i, 0, pOk);
            dfs(heights, i, col - 1, aOk);
        }
        for (int i = 0; i < col; i++) {
            dfs(heights, 0, i, pOk);
            dfs(heights, row - 1, i, aOk);
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (pOk[i][j] && aOk[i][j])
                    res.add(Arrays.asList(i, j));
            }
        }
        return res;
    }

    /**
     * 确定边界点可以达到的点
     */
    private void dfs(int[][] heights, int i, int j, boolean[][] ok) {
        ok[i][j] = true;
        int height = heights[i][j];
        if (inAra(i - 1, j) && heights[i - 1][j] >= height && !ok[i - 1][j])
            dfs(heights, i - 1, j, ok);
        if (inAra(i, j - 1) && heights[i][j - 1] >= height && !ok[i][j - 1])
            dfs(heights, i, j - 1, ok);
        if (inAra(i + 1, j) && heights[i + 1][j] >= height && !ok[i + 1][j])
            dfs(heights, i + 1, j, ok);
        if (inAra(i, j + 1) && heights[i][j + 1] >= height && !ok[i][j + 1])
            dfs(heights, i, j + 1, ok);
    }

    private boolean inAra(int i, int j) {
        return i >= 0 && j >= 0 && i < row && j < col;
    }


    /**
     * 遍历每个点，确定其可以到达的海
     */
    private boolean[][] mark;
    private boolean[][] ok;

    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        row = heights.length;
        col = heights[0].length;
        ok = new boolean[row][col];
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                mark = new boolean[row][col];
                if (dfs1(heights, i, j)) {
                    mark = new boolean[row][col];
                    if (dfs2(heights, i, j)) {
                        ok[i][j] = true;
                        res.add(Arrays.asList(i, j));
                    }
                }
            }
        }
        return res;
    }

    /**
     * 确定可以达到太平洋
     */
    private boolean dfs1(int[][] heights, int i, int j) {
        mark[i][j] = true;
        if (i <= 0 || j <= 0)
            return true;
        if (heights[i - 1][j] <= heights[i][j] && !mark[i - 1][j]) {
            if (ok[i - 1][j]) return true;
            if (dfs1(heights, i - 1, j)) return true;
        }
        if (heights[i][j - 1] <= heights[i][j] && !mark[i][j - 1]) {
            if (ok[i][j - 1]) return true;
            if (dfs1(heights, i, j - 1)) return true;
        }
        if (i + 1 < row && heights[i + 1][j] <= heights[i][j] && !mark[i + 1][j]) {
            if (ok[i + 1][j]) return true;
            if (dfs1(heights, i + 1, j)) return true;
        }
        if (j + 1 < col && heights[i][j + 1] <= heights[i][j] && !mark[i][j + 1]) {
            if (ok[i][j + 1]) return true;
            if (dfs1(heights, i, j + 1)) return true;
        }
        return false;
    }

    /**
     * 确定可以达到大西洋
     */
    private boolean dfs2(int[][] heights, int i, int j) {
        mark[i][j] = true;
        if (i >= row - 1 || j >= col - 1)
            return true;
        if (i - 1 >= 0 && heights[i - 1][j] <= heights[i][j] && !mark[i - 1][j]) {
            if (ok[i - 1][j]) return true;
            if (dfs2(heights, i - 1, j)) return true;
        }
        if (j - 1 >= 0 && heights[i][j - 1] <= heights[i][j] && !mark[i][j - 1]) {
            if (ok[i][j - 1]) return true;
            if (dfs2(heights, i, j - 1)) return true;
        }
        if (heights[i + 1][j] <= heights[i][j] && !mark[i + 1][j]) {
            if (ok[i + 1][j]) return true;
            if (dfs2(heights, i + 1, j)) return true;
        }
        if (heights[i][j + 1] <= heights[i][j] && !mark[i][j + 1]) {
            if (ok[i][j + 1]) return true;
            if (dfs2(heights, i, j + 1)) return true;
        }
        return false;
    }

    public void test() {
        List<List<Integer>> res = pacificAtlantic(new int[][]{
                {1, 2, 2, 3, 5},
                {3, 2, 3, 4, 4},
                {2, 4, 5, 3, 1},
                {6, 7, 1, 4, 5},
                {5, 1, 1, 2, 4}
        });
        List<List<Integer>> res1 = pacificAtlantic1(new int[][]{
                {4, 4, 1, 7, 4, 18, 5, 5, 1, 6, 6, 10, 17, 19, 13, 3, 19},
                {19, 8, 3, 14, 18, 11, 2, 2, 5, 2, 19, 15, 18, 12, 16, 7, 19},
                {2, 4, 15, 2, 6, 4, 18, 13, 12, 11, 0, 11, 6, 19, 17, 11, 9}
        });
    }

    public static void main(String[] args) {
        new PacificAtlantic().test();
    }
}
```

### 4.[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)（dfs）

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```java
package com.yubin.medium.part1;

import java.util.LinkedList;
import java.util.List;

public class LetterCombinations {
    private final String[] digitsChar = new String[]{
            " ","!@#", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz", "*+", "_", "#"
    };
    private StringBuilder sb = null;
    private List<String> res = null;
    private int len = 0;

    public List<String> letterCombinations(String digits) {
        res = new LinkedList<>();
        if (digits.length() == 0) return res;
        sb = new StringBuilder();
        len = digits.length();
        dfs(digits, 0);
        return res;
    }

    private void dfs(String digits, int index) {
        if (index == len) {
            res.add(sb.toString());
            return;
        }
        int digit = Integer.parseInt(String.valueOf(digits.charAt(index)));
        for (int i = 0; i < digitsChar[digit].length(); i++) {
            char c = digitsChar[digit].charAt(i);
            sb.append(c);
            dfs(digits, index + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }


    public void test() {
        letterCombinations("23");
    }

    public static void main(String[] args) {
        new LetterCombinations().test();
    }
}
```

### 5.[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)（dfs）

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

```java
    3
   / \
  9  20
    /  \
   15   7
```
```java
package com.yubin.medium.part1;

import com.yubin.TreeNode;

import java.util.HashMap;
import java.util.Map;

public class BuildTree {
    private int index = 0;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Map<Integer, Integer> indexMap = new HashMap<>();
        index = 0;
        for (int i = 0; i < inorder.length; i++) {
            indexMap.put(inorder[i], i);
        }
        return dfs(preorder, indexMap, 0, indexMap.size() - 1);
    }

    private TreeNode dfs(int[] preorder, Map<Integer, Integer> map, int left, int right) {
        if (left > right) return null;
        int node = preorder[index];
        index++;
        TreeNode tree = new TreeNode(node);
        int inorderIndex = map.get(node);
        tree.left = dfs(preorder, map, left, inorderIndex - 1);
        tree.right = dfs(preorder, map, inorderIndex + 1, right);
        return tree;
    }

    public void test() {
        TreeNode root = buildTree(new int[]{3, 9, 20, 15, 7}, new int[]{9, 3, 15, 20, 7});
        System.out.println(root.left.val);
    }

    public static void main(String[] args) {
        new BuildTree().test();
    }
}
```



## part2

### 1.[有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)（dfs）

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

```java
package com.yubin.medium.part2;

import com.yubin.ListNode;
import com.yubin.TreeNode;

import java.util.ArrayList;
import java.util.List;

public class SortedListToBST {
    /**
     * 自顶向下构建二叉树
     */
    private TreeNode dfsUTB(List<Integer> list, int left, int right) {
        if (left > right) return null;
        int mid = (right - left) / 2 + left;
        TreeNode tree = new TreeNode(list.get(mid));
        tree.left = dfsUTB(list, left, mid - 1);
        tree.right = dfsUTB(list, mid + 1, right);
        return tree;
    }

    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        List<Integer> list = new ArrayList<>();
        ListNode n = head;
        while (n != null) {
            list.add(n.val);
            n = n.next;
        }
        return dfsUTB(list, 0, list.size() - 1);
    }


    /**
     * 自底向上构建二叉树
     */
    private ListNode h = null;

    private TreeNode dfsBTU(int left, int right) {
        if (left > right) return null;
        int mid = (right - left) / 2 + left;
        TreeNode leftNode = dfsBTU(left, mid - 1);
        TreeNode tree = new TreeNode(h.val);
        h = h.next;
        TreeNode rightNode = dfsBTU(mid + 1, right);
        tree.left = leftNode;
        tree.right = rightNode;
        return tree;
    }

    public TreeNode sortedListToBST1(ListNode head) {
        if (head == null) return null;
        h = head;
        int size = 0;
        while (h != null) {
            size++;
            h = h.next;
        }
        h = head;
        return dfsBTU(0, size - 1);
    }
}
```

# hard

