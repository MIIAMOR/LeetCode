# 搜索

## 题目使用的二叉树结构

```java
package com.yubin;

/**
 * 树结构
 */
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 题目使用的链式结构

```java
package com.yubin;

public class ListNode {
    public int val;
    public ListNode next;

    public ListNode() {
    }

    public ListNode(int val) {
        this.val = val;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

## 题目使用的N叉树结构

```java
package com.yubin;

import java.util.List;

public class Node {
    public int val;
    public List<Node> children;

    public Node() {
    }

    public Node(int val) {
        this.val = val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
}
```

# easy

## part1

### 1.[相同的树](https://leetcode-cn.com/problems/same-tree/)（dfs）

难度简单631收藏分享切换为英文接收动态反馈

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```java
package com.yubin.easy.part1;

public class IsSameTree {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        return dfs(p, q);
    }

    /**
     * dfs两棵树，判断两树是否相同
     */
    private boolean dfs(TreeNode p, TreeNode q) {
        if (p == null && q == null)
            return true;
        else if (p == null || q == null)
            return false;
        else if (p.val != q.val)
            return false;

        if (!dfs(p.left, q.left))
            return false;
        if (!dfs(p.right, q.right))
            return false;

        return true;
    }
}
```

### 2.[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)（dfs）

给定一个二叉树，检查它是否是镜像对称的。

```java
package com.yubin.easy.part1;

import com.yubin.basic.TreeNode;

public class IsSymmetric {
    /**
     * 假设有两棵一模一样的数，分别前序遍历和后序遍历
     */
    public boolean isSymmetric1(TreeNode root) {
        return dfs(root, root);
    }

    private boolean dfs(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return true;
        if (root1 == null || root2 == null) return false;
        if (root1.val != root2.val) return false;
        if (!dfs(root1.left, root2.right)) return false;
        return dfs(root1.right, root2.left);
    }

    /**
     * 记录遍历得到的数
     */
    private StringBuilder sbPre = new StringBuilder();
    private StringBuilder sbPost = new StringBuilder();

    public boolean isSymmetric(TreeNode root) {
        dfs(root, 0);
        dfs(root, 1);
        String pre = sbPre.toString();
        String post = sbPost.toString();
        return pre.equals(post);
    }

    /**
     * 对称树前序和后序遍历结果一样
     */
    private void dfs(TreeNode root, int flag) {
        if (root == null) {
            if (flag == 0) sbPre.append('n');
            else sbPost.append('n');
            return;
        }
        if (flag == 0) {
            sbPre.append(root.val);
            dfs(root.left, flag);
            dfs(root.right, flag);
        } else {
            sbPost.append(root.val);
            dfs(root.right, flag);
            dfs(root.left, flag);
        }
    }

    public void test() {
        TreeNode right2 = new TreeNode(3);
        TreeNode left1 = new TreeNode(2, null, right2);

        TreeNode right22 = new TreeNode(3);
        TreeNode right1 = new TreeNode(2, null, right22);

        TreeNode root = new TreeNode(1, left1, right1);
        System.out.println(isSymmetric1(root));
    }

    public static void main(String[] args) {
        new IsSymmetric().test();
    }
}
```

### 3.[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)（dfs+bfs）

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

```java
package com.yubin.easy.part1;

import com.yubin.basic.TreeNode;

public class MaxDepth {
    /**
     * 基于层析遍历思想
     */
    public int maxDepth2(TreeNode root) {
        if (root == null) return 0;
        List<TreeNode> level = new LinkedList<>();
        int depth = 0;
        level.add(root);
        while (true) {
            int count = 0, size = level.size();
            for (int i = 0; i < size; i++) {
                TreeNode tree = level.remove(0);
                TreeNode left = tree.left;
                TreeNode right = tree.right;
                if (left == null)
                    count++;
                else level.add(left);
                if (right == null)
                    count++;
                else level.add(right);
            }
            depth++;
            if (count == size * 2) return depth;
        }
    }

    /**
     * 求最大深度
     */
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
    
    private int depth = 0;
    private int maxDepth = 0;

    /**
     * 求最大深度
     */
    public int maxDepth1(TreeNode root) {
        dfs(root);
        return maxDepth;
    }

    private void dfs(TreeNode root) {
        depth++;
        if (root == null) {
            depth--;
            return;
        }
        maxDepth = Math.max(depth, maxDepth);
        dfs(root.left);
        dfs(root.right);
        depth--;
    }
}
```

### 4.[将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)（dfs）

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

```java
package com.yubin.easy.part1;

import com.yubin.basic.TreeNode;

public class SortedArrayToBST {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums, 0, nums.length - 1);
    }

    /**
     * 以中间的数为根，数组左侧构建左子树，数组右侧构建右子树
     * dfs递归求解
     */
    private TreeNode dfs(int[] nums, int left, int right) {
        if (left > right) return null;
        int mid = (right - left) / 2 + left;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = dfs(nums, left, mid - 1);
        root.right = dfs(nums, mid + 1, right);
        return root;
    }

    public void test() {
        sortedArrayToBST(new int[]{1, 3});
    }

    public static void main(String[] args) {
        new SortedArrayToBST().test();
    }
}
```

### 5. [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)（dfs）

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```java
package com.yubin.easy.part1;

import com.yubin.basic.TreeNode;

public class IsBalanced {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        if (Math.abs(depth(root.left) - depth(root.right)) > 1)
            return false;
        return isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(depth(root.left), depth(root.right));
    }
}
```

## part2

### 1.[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)（dfs+bfs）

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

 

```java
package com.yubin.easy.part2;

import com.sun.source.tree.Tree;
import com.yubin.basic.TreeNode;

import java.util.LinkedList;
import java.util.List;

public class MinDepth {
    /**
     * 层序遍历思想
     */
    public int minDepth1(TreeNode root) {
        if (root == null) return 0;
        List<TreeNode> level = new LinkedList<>();
        level.add(root);
        int depth = 1;
        while (true) {
            int size = level.size();
            for (int i = 0; i < size; i++) {
                TreeNode tree = level.get(0);
                level.remove(0);
                if (tree != null)
                    if (tree.left == null && tree.right == null) return depth;
                    else {
                        level.add(tree.left);
                        level.add(tree.right);
                    }
            }
            depth++;
        }
    }

    /**
     * dfs求解方法
     */
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        return minDepthOfNode(root);
    }

    private int minDepthOfNode(TreeNode root) {
        if (root == null) return Integer.MAX_VALUE;
        if (root.left == null && root.right == null) return 1;
        return 1 + Math.min(minDepthOfNode(root.left), minDepthOfNode(root.right));
    }

    public void test() {
        System.out.println("em...");
    }

    public static void main(String[] args) {
        new MinDepth().test();
    }
}
```

### 2.[N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)（dfs+bfs）

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

```java
package com.yubin.easy.part2;

import com.yubin.basic.Node;

import java.util.Deque;
import java.util.LinkedList;

public class MaxDepth {
    private int maxDep;

    public int maxDepth(Node root) {
        if (root == null) return 0;
        maxDep = 0;
        dfs(root, 0);
        return maxDep;
    }

    /**
     * 深度优先搜索 dfs
     */
    private void dfs(Node n, int depth) {
        maxDep = Math.max(maxDep, depth);
        if (n == null || n.children == null) return;
        for (Node child : n.children) {
            dfs(child, depth + 1);
        }
    }

    /**
     * 广度优先搜索 bfs
     */
    public int maxDepth1(Node root) {
        if (root == null) return 0;
        Deque<Node> queue = new LinkedList<>();
        int depth = 0;
        queue.addLast(root);
        while (true) {
            int count = 0;//记录为不null的下一层次的节点数量
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node n = queue.removeFirst();
                if (n == null) continue;
                if (n.children != null) {
                    for (Node child : n.children) {
                        if (child != null) count++;
                        queue.addLast(child);
                    }
                }
            }
            depth++;
            if (count == 0) return depth;
        }
    }
}
```

### 3. [员工的重要性](https://leetcode-cn.com/problems/employee-importance/)（dfs+bfs）

给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。

比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。

现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。

 

示例：

> 输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
> 输出：11
> 解释：
> 员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。

```java
package com.yubin.easy.part2;

import java.util.*;

public class GetImportance {
    private Map<Integer, Employee> map = null;
    private int importance1 = 0;

    /**
     * dfs求解
     */
    public int getImportance1(List<Employee> employees, int id) {
        map = new HashMap<>();
        for (Employee employee : employees) {
            map.put(employee.id, employee);
        }
        importance1 = 0;
        getImportance1(id);
        return importance1;
    }

    private void getImportance1(int id) {
        Employee e = map.get(id);
        importance1 += e.importance;
        for (Integer subordinate : e.subordinates) {
            getImportance1(subordinate);
        }
    }

    public int getImportance(List<Employee> employees, int id) {
        map = new HashMap<>();
        for (Employee employee : employees) {
            map.put(employee.id, employee);
        }
        return getImportance(id);
    }

    /**
     * 基于队列的bfs
     */
    private int getImportance(int id) {
        int importance = 0;
        Employee e = map.get(id);
        importance += e.importance;
        Deque<Employee> list = new LinkedList<>();
        list.add(e);
        while (true) {
            int size = list.size();
            int count = 0;
            for (int i = 0; i < size; i++) {
                List<Integer> employeeId = list.removeFirst().subordinates;
                for (Integer integer : employeeId) {
                    count++;
                    Employee employee = map.get(integer);
                    list.add(employee);
                    importance += employee.importance;
                }
            }
            if (count == 0) return importance;
        }
    }

    class Employee {
        public int id;//id号
        public int importance;//自身的重要性
        public List<Integer> subordinates;//直系下属
    }
}
```

### 4. [二叉树的堂兄弟节点](https://leetcode-cn.com/problems/cousins-in-binary-tree/)（bfs）

在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。

如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。

我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。

只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。



```java
package com.yubin.easy.part2;

import com.yubin.basic.TreeNode;

import java.util.Deque;
import java.util.LinkedList;

public class IsCousins {
    public boolean isCousins(TreeNode root, int x, int y) {
        Deque<TreeNode> queue = new LinkedList<>();
        queue.addLast(root);
        while (true) {
            int size = queue.size();
            boolean xIn = false, yIn = false;
            for (int i = 0; i < size; i++) {
                boolean flag = false;
                TreeNode tree = queue.removeFirst();
                if (tree.left != null) {
                    queue.addLast(tree.left);
                    if (tree.left.val == x) {
                        xIn = true;
                        flag = true;
                    }
                    if (tree.left.val == y) {
                        yIn = true;
                        flag = true;
                    }
                }
                if (tree.right != null && !flag) {
                    queue.addLast(tree.right);
                    if (tree.right.val == x) xIn = true;
                    if (tree.right.val == y) yIn = true;
                }
                if (xIn && yIn) return true;
            }
            if (xIn || yIn) return false;
        }
    }
}
```

### 5. [二进制手表](https://leetcode-cn.com/problems/binary-watch/)（backtracking）

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

- 例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。

分钟必须由两位数组成，可能会以零开头：

- 例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。


```java
package com.yubin.easy.part2;

import java.util.LinkedList;
import java.util.List;

public class ReadBinaryWatch {
    private int[] nums = new int[]{1, 2, 4, 8, 16, 32, 1, 2, 4, 8};
    private boolean[] light = new boolean[nums.length];
    private int size = nums.length;
    private List<String> res = null;

    public List<String> readBinaryWatch(int turnedOn) {
        res = new LinkedList<>();
        backtracking(turnedOn, 0);
        return res;
    }

    /**
     * @param left 剩下的可用的灯
     */
    private void backtracking(int left, int index) {
        if (left == 0) {
            int hour = 0, minute = 0;
            for (int i = 0; i < light.length; i++) {
                if (i < 6)
                    minute += (light[i] ? nums[i] : 0);
                else
                    hour += (light[i] ? nums[i] : 0);
            }
            if (hour < 12 && minute < 60) {
                if (minute < 10) res.add(hour + ":0" + minute);
                else res.add(hour + ":" + minute);
            }
            return;
        }
        for (int i = index; i < size; i++) {
            if (i + left > size) return;
            light[i] = true;
            backtracking(left - 1, i + 1);
            light[i] = false;
        }
    }

    public void test() {
        for (String s : readBinaryWatch(2)) {
            System.out.println(s);
        }
    }

    public static void main(String[] args) {
        new ReadBinaryWatch().test();
    }
}
```

## part3

### 1. [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

```java
package com.yubin.easy.part3;

import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.List;

public class BinaryTreePaths {
    private List<String> res = null;
    private StringBuilder sb = null;

    public List<String> binaryTreePaths(TreeNode root) {
        res = new ArrayList<>();
        sb = new StringBuilder();
        dfs(root);
        return res;
    }

    /**
     * 记住：node.val的值转换的字符串可能是多位
     * 对StringBuilder sb进行状态恢复的时候需要删除指定的位数
     *
     * @param node 待查找的树节点
     */
    private void dfs(TreeNode node) {
        String num = String.valueOf(node.val);
        int len = num.length();
        if (node.left == null && node.right == null) {
            sb.append(num);
            res.add(sb.toString());
            sb.delete(sb.length() - len, sb.length());
            return;
        }
        sb.append(num).append("->");
        if (node.left != null) dfs(node.left);
        if (node.right != null) dfs(node.right);
        sb.delete(sb.length() - 2 - len, sb.length());
    }
}
```

# medium

## part1

### 1.[岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)(dfs)

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

 

示例 1:

> [[0,0,1,0,0,0,0,1,0,0,0,0,0],
>  [0,0,0,0,0,0,0,1,1,1,0,0,0],
>  [0,1,1,0,1,0,0,0,0,0,0,0,0],
>  [0,1,0,0,1,1,0,0,1,0,1,0,0],
>  [0,1,0,0,1,1,0,0,1,1,1,0,0],
>  [0,0,0,0,0,0,0,0,0,0,1,0,0],
>  [0,0,0,0,0,0,0,1,1,1,0,0,0],
>  [0,0,0,0,0,0,0,1,1,0,0,0,0]]
> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

```java
package com.yubin.medium.part1;

public class MaxAreaOfIsland {
    private int col;
    private int row;

    /**
     * dfs深度优先搜索
     */
    public int maxAreaOfIsland(int[][] grid) {
        col = grid.length;
        row = grid[0].length;
        boolean[][] mark = new boolean[col][row];
        int res = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                res = Math.max(dfs(grid, mark, i, j), res);
            }
        }
        return res;
    }

    /**
     * 深度优先搜索，求岛屿可以连接的最大值
     */
    private int dfs(int[][] grid, boolean[][] mark, int i, int j) {
        if (grid[i][j] == 0 || mark[i][j]) return 0;
        int res = 1;
        mark[i][j] = true;
        if (i - 1 >= 0) res += dfs(grid, mark, i - 1, j);
        if (j - 1 >= 0) res += dfs(grid, mark, i, j - 1);
        if (i + 1 < col) res += dfs(grid, mark, i + 1, j);
        if (j + 1 < row) res += dfs(grid, mark, i, j + 1);
        return res;
    }
}
```

### 2.[省份数量](https://leetcode-cn.com/problems/number-of-provinces/)(dfs)

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[ i [ j ] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

 

示例 1：

> 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
> 输出：2

```java
package com.yubin.medium.part1;

public class FindCircleNum {
    private int num;//省份数
    boolean[] mark;

    public int findCircleNum(int[][] isConnected) {
        num = isConnected.length;
        mark = new boolean[num];
        int res = 0;
        for (int i = 0; i < num; i++) {
            if (dfs(isConnected, i) != 0) res++;
        }
        return res;
    }

    /**
     * 为i省份搜索可以连通的城市
     */
    private int dfs(int[][] isConnected, int i) {
        if (mark[i]) return 0;
        mark[i] = true;
        int res = 1;
        for (int j = 0; j < num; j++) {
            if (isConnected[i][j] == 1) res += dfs(isConnected, j);
        }
        return res;
    }
}
```

### 3.[太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)（dfs）

给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

 

提示：

输出坐标的顺序不重要
m 和 n 都小于150


示例：

> 给定下面的 5x5 矩阵:
>
> 太平洋 ~   ~   ~   ~   ~ 
>     ~  1   2   2   3  (5) *
>     ~  3   2   3  (4) (4) *
>     ~  2   4  (5)  3   1  *
>     ~ (6) (7)  1   4   5  *
>     ~ (5)  1   1   2   4  *
>
> **   *   *   * 大西洋
>
> 返回:
>
> [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).

```java
package com.yubin.medium.part1;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class PacificAtlantic {
    /**
     * 确定边界
     */
    private int row;
    private int col;

    private boolean pOk[][];
    private boolean aOk[][];

    /**
     * dfs逆向遍历从边界出发，找到可以到达的点
     */
    public List<List<Integer>> pacificAtlantic1(int[][] heights) {
        row = heights.length;
        col = heights[0].length;
        pOk = new boolean[row][col];
        aOk = new boolean[row][col];
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < row; i++) {
            dfs(heights, i, 0, pOk);
            dfs(heights, i, col - 1, aOk);
        }
        for (int i = 0; i < col; i++) {
            dfs(heights, 0, i, pOk);
            dfs(heights, row - 1, i, aOk);
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (pOk[i][j] && aOk[i][j])
                    res.add(Arrays.asList(i, j));
            }
        }
        return res;
    }

    /**
     * 确定边界点可以达到的点
     */
    private void dfs(int[][] heights, int i, int j, boolean[][] ok) {
        ok[i][j] = true;
        int height = heights[i][j];
        if (inAra(i - 1, j) && heights[i - 1][j] >= height && !ok[i - 1][j])
            dfs(heights, i - 1, j, ok);
        if (inAra(i, j - 1) && heights[i][j - 1] >= height && !ok[i][j - 1])
            dfs(heights, i, j - 1, ok);
        if (inAra(i + 1, j) && heights[i + 1][j] >= height && !ok[i + 1][j])
            dfs(heights, i + 1, j, ok);
        if (inAra(i, j + 1) && heights[i][j + 1] >= height && !ok[i][j + 1])
            dfs(heights, i, j + 1, ok);
    }

    private boolean inAra(int i, int j) {
        return i >= 0 && j >= 0 && i < row && j < col;
    }


    /**
     * 遍历每个点，确定其可以到达的海
     */
    private boolean[][] mark;
    private boolean[][] ok;

    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        row = heights.length;
        col = heights[0].length;
        ok = new boolean[row][col];
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                mark = new boolean[row][col];
                if (dfs1(heights, i, j)) {
                    mark = new boolean[row][col];
                    if (dfs2(heights, i, j)) {
                        ok[i][j] = true;
                        res.add(Arrays.asList(i, j));
                    }
                }
            }
        }
        return res;
    }

    /**
     * 确定可以达到太平洋
     */
    private boolean dfs1(int[][] heights, int i, int j) {
        mark[i][j] = true;
        if (i <= 0 || j <= 0)
            return true;
        if (heights[i - 1][j] <= heights[i][j] && !mark[i - 1][j]) {
            if (ok[i - 1][j]) return true;
            if (dfs1(heights, i - 1, j)) return true;
        }
        if (heights[i][j - 1] <= heights[i][j] && !mark[i][j - 1]) {
            if (ok[i][j - 1]) return true;
            if (dfs1(heights, i, j - 1)) return true;
        }
        if (i + 1 < row && heights[i + 1][j] <= heights[i][j] && !mark[i + 1][j]) {
            if (ok[i + 1][j]) return true;
            if (dfs1(heights, i + 1, j)) return true;
        }
        if (j + 1 < col && heights[i][j + 1] <= heights[i][j] && !mark[i][j + 1]) {
            if (ok[i][j + 1]) return true;
            if (dfs1(heights, i, j + 1)) return true;
        }
        return false;
    }

    /**
     * 确定可以达到大西洋
     */
    private boolean dfs2(int[][] heights, int i, int j) {
        mark[i][j] = true;
        if (i >= row - 1 || j >= col - 1)
            return true;
        if (i - 1 >= 0 && heights[i - 1][j] <= heights[i][j] && !mark[i - 1][j]) {
            if (ok[i - 1][j]) return true;
            if (dfs2(heights, i - 1, j)) return true;
        }
        if (j - 1 >= 0 && heights[i][j - 1] <= heights[i][j] && !mark[i][j - 1]) {
            if (ok[i][j - 1]) return true;
            if (dfs2(heights, i, j - 1)) return true;
        }
        if (heights[i + 1][j] <= heights[i][j] && !mark[i + 1][j]) {
            if (ok[i + 1][j]) return true;
            if (dfs2(heights, i + 1, j)) return true;
        }
        if (heights[i][j + 1] <= heights[i][j] && !mark[i][j + 1]) {
            if (ok[i][j + 1]) return true;
            if (dfs2(heights, i, j + 1)) return true;
        }
        return false;
    }

    public void test() {
        List<List<Integer>> res = pacificAtlantic(new int[][]{
                {1, 2, 2, 3, 5},
                {3, 2, 3, 4, 4},
                {2, 4, 5, 3, 1},
                {6, 7, 1, 4, 5},
                {5, 1, 1, 2, 4}
        });
        List<List<Integer>> res1 = pacificAtlantic1(new int[][]{
                {4, 4, 1, 7, 4, 18, 5, 5, 1, 6, 6, 10, 17, 19, 13, 3, 19},
                {19, 8, 3, 14, 18, 11, 2, 2, 5, 2, 19, 15, 18, 12, 16, 7, 19},
                {2, 4, 15, 2, 6, 4, 18, 13, 12, 11, 0, 11, 6, 19, 17, 11, 9}
        });
    }

    public static void main(String[] args) {
        new PacificAtlantic().test();
    }
}
```

### 4.[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)（dfs）

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```java
package com.yubin.medium.part1;

import java.util.LinkedList;
import java.util.List;

public class LetterCombinations {
    private final String[] digitsChar = new String[]{
            " ","!@#", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz", "*+", "_", "#"
    };
    private StringBuilder sb = null;
    private List<String> res = null;
    private int len = 0;

    public List<String> letterCombinations(String digits) {
        res = new LinkedList<>();
        if (digits.length() == 0) return res;
        sb = new StringBuilder();
        len = digits.length();
        dfs(digits, 0);
        return res;
    }

    private void dfs(String digits, int index) {
        if (index == len) {
            res.add(sb.toString());
            return;
        }
        int digit = Integer.parseInt(String.valueOf(digits.charAt(index)));
        for (int i = 0; i < digitsChar[digit].length(); i++) {
            char c = digitsChar[digit].charAt(i);
            sb.append(c);
            dfs(digits, index + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }


    public void test() {
        letterCombinations("23");
    }

    public static void main(String[] args) {
        new LetterCombinations().test();
    }
}
```

### 5.[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)（dfs）

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

```java
    3
   / \
  9  20
    /  \
   15   7
```
```java
package com.yubin.medium.part1;

import com.yubin.basic.TreeNode;

import java.util.HashMap;
import java.util.Map;

public class BuildTree {
    private int index = 0;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Map<Integer, Integer> indexMap = new HashMap<>();
        index = 0;
        for (int i = 0; i < inorder.length; i++) {
            indexMap.put(inorder[i], i);
        }
        return dfs(preorder, indexMap, 0, indexMap.size() - 1);
    }

    private TreeNode dfs(int[] preorder, Map<Integer, Integer> map, int left, int right) {
        if (left > right) return null;
        int node = preorder[index];
        index++;
        TreeNode tree = new TreeNode(node);
        int inorderIndex = map.get(node);
        tree.left = dfs(preorder, map, left, inorderIndex - 1);
        tree.right = dfs(preorder, map, inorderIndex + 1, right);
        return tree;
    }

    public void test() {
        TreeNode root = buildTree(new int[]{3, 9, 20, 15, 7}, new int[]{9, 3, 15, 20, 7});
        System.out.println(root.left.val);
    }

    public static void main(String[] args) {
        new BuildTree().test();
    }
}
```



## part2



### 1.[全排列](https://leetcode-cn.com/problems/permutations/)（backtracking）

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```java
package com.yubin.medium.part2;

import java.util.*;

public class Permute {
    private List<List<Integer>> res = null;
    private int len = 0;
    private List<Integer> list = null;

    public List<List<Integer>> permute(int[] nums) {
        res = new LinkedList<>();
        list = new LinkedList<>();
        len = nums.length;
        backtracking(nums);
        return res;
    }

    private void backtracking(int[] nums) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (num == Integer.MIN_VALUE) {
                count++;
                continue;
            }
            list.add(num);
            nums[i] = Integer.MIN_VALUE;
            backtracking(nums);
            list.remove(list.size() - 1);
            nums[i] = num;
        }
        if (count == len) {
            res.add(new LinkedList<>(list));
        }
    }

    public void test() {
        permute(new int[]{1, 2, 3});
    }

    public static void main(String[] args) {
        new Permute().test();
    }
}
```

### 2. [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)（backtracking）

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]

```java
package com.yubin.medium.part2;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class PermuteUnique {
    private List<Integer> list = null;
    private List<List<Integer>> res = null;
    private int size = 0;

    public List<List<Integer>> permuteUnique(int[] nums) {
        list = new LinkedList<>();
        res = new LinkedList<>();
        int len = nums.length;
        size = 0;
        Arrays.sort(nums);
        backtracking(nums, len);
        return res;
    }

    private void backtracking(int[] nums, int n) {
        if (size == n) {
            res.add(new LinkedList<>(list));
            return;
        }
        int flag = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (nums[i] == flag || nums[i] == Integer.MIN_VALUE) continue;
            int num = nums[i];
            flag = num;
            nums[i] = Integer.MIN_VALUE;
            list.add(num);
            size++;
            backtracking(nums, n);
            list.remove(list.size() - 1);
            size--;
            nums[i] = num;
        }
    }

    public void test() {
        for (List<Integer> integers : permuteUnique(new int[]{1, 1, 2})) {
            for (Integer integer : integers) {
                System.out.print(integer + " ");
            }
            System.out.println();
        }
        System.out.println();
        for (List<Integer> integers : permuteUnique(new int[]{1, 3, 2})) {
            for (Integer integer : integers) {
                System.out.print(integer + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        new PermuteUnique().test();
    }
}
```

### 3.[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)（backtracking）

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例 1：

> 输入：n = 3
> 输出：["((()))","(()())","(())()","()(())","()()()"]

```java
package com.yubin.medium.part2;

import java.util.LinkedList;
import java.util.List;

public class GenerateParenthesis {
    private LinkedList<Character> stack = null;
    private LinkedList<String> res = null;
    private StringBuilder sb = null;
    /**
     * 左括号的剩余数量
     * 右括号的剩余数量
     */
    private int leftNum = 0;
    private int rightNum = 0;

    public List<String> generateParenthesis(int n) {
        sb = new StringBuilder();
        stack = new LinkedList<>();
        res = new LinkedList<>();
        leftNum = rightNum = n;
        backtracking();
        return res;
    }

    /**
     * 其中stack用于记录状态，判断此时加入左括号后者右括号是否合法
     * sb记录当前的括号拼接状态
     */
    private void backtracking() {
        if (leftNum == 0 && rightNum == 0) {
            res.add(sb.toString());
            return;
        }
        if (stack.size() == 0 || leftNum > 0) {
            stack.addLast('(');
            sb.append('(');
            leftNum--;
            backtracking();
            sb.deleteCharAt(sb.length() - 1);
            stack.removeLast();
            leftNum++;
        }
        if (stack.size() > 0 && rightNum > 0) {
            stack.removeLast();
            sb.append(')');
            rightNum--;
            backtracking();
            sb.deleteCharAt(sb.length() - 1);
            stack.addLast('(');
            rightNum++;
        }
    }
}
```

### 4.[组合](https://leetcode-cn.com/problems/combinations/)（backtracking）

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:

> 输入: n = 4, k = 2
> 输出:
> [
>   [2,4],
>   [3,4],
>   [2,3],
>   [1,2],
>   [1,3],
>   [1,4],
> ]

```java
package com.yubin.medium.part2;

import java.util.LinkedList;
import java.util.List;

public class Combine {
    /**
     * 回溯法
     */
    private List<List<Integer>> res = null;
    private List<Integer> combineNum = null;

    public List<List<Integer>> combine(int n, int k) {
        res = new LinkedList<>();
        combineNum = new LinkedList<>();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        backtracking(nums, k, 0);
        return res;
    }

    private void backtracking(int[] nums, int k, int beginIndex) {
        if (combineNum.size() == k) {
            res.add(new LinkedList<>(combineNum));
            return;
        }
        for (int i = beginIndex; i < nums.length; i++) {
            combineNum.add(nums[i]);
            backtracking(nums, k, i + 1);
            combineNum.remove(combineNum.size() - 1);
        }
    }

    public List<List<Integer>> combine1(int n, int k) {
        res = new LinkedList<>();
        combineNum = new LinkedList<>();
        backtracking1(n, k, 0);
        return res;
    }

    /**
     * 回溯算法 剪枝去除不必要的计算
     *
     * @param n          组合中的数去1...n
     * @param k          k表示当前还需要多少个数来组合
     * @param beginIndex 下一个数从哪个位置开始寻找
     */
    private void backtracking1(int n, int k, int beginIndex) {
        if (0 == k) {
            res.add(new LinkedList<>(combineNum));
            return;
        }
        for (int i = beginIndex; i < n - k + 1; i++) {
            combineNum.add(i + 1);
            backtracking1(n, k - 1, i + 1);
            combineNum.remove(combineNum.size() - 1);
        }
    }

    public void test() {
        combine(4, 2);
    }

    public static void main(String[] args) {
        new Combine().test();
    }
}
```

### 5.[单词搜索](https://leetcode-cn.com/problems/word-search/)（backtracking）

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```java
package com.yubin.medium.part2;

public class Exist {
    private char[][] board = null;
    private char[] words = null;
    private int m = 0;
    private int n = 0;
    private int len = 0;

    public boolean exist(char[][] board, String word) {
        m = board.length;
        n = board[0].length;
        len = word.length();
        if (len > m * n) return false;
        words = word.toCharArray();
        this.board = board;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == words[0]) {
                    if (len == 1 || exist(i, j, 0))
                        return true;
                }
            }
        }
        return false;
    }

    /**
     * @param i     起始位置的坐标
     * @param j     起始位置的坐标
     * @param index 当前应该寻找的字符在单词中的下标
     * @return
     */
    private boolean exist(int i, int j, int index) {
        if (index >= len) return true;
        if (board[i][j] != words[index]) return false;
        char c = board[i][j];
        board[i][j] = '#';
        if (i + 1 < m && exist(i + 1, j, index + 1))
            return true;
        if (i - 1 >= 0 && exist(i - 1, j, index + 1))
            return true;
        if (j + 1 < n && exist(i, j + 1, index + 1))
            return true;
        if (j - 1 >= 0 && exist(i, j - 1, index + 1))
            return true;
        board[i][j] = c;
        return false;
    }

    public void test() {
        System.out.println(exist(new char[][]{
                {'a', 'a'},
        }, "aa"));
    }

    public static void main(String[] args) {
        new Exist().test();
    }
}
```

## part3

### 1.[组合总和](https://leetcode-cn.com/problems/combination-sum/)（backtracking）

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1：

> 输入：candidates = [2,3,6,7], target = 7,
> 所求解集为：
> [
>   [7],
>   [2,2,3]
> ]

```java
package com.yubin.medium.part3;

import java.util.*;

public class CombinationSum {
    private List<Integer> list = null;
    private List<List<Integer>> res = null;
    private int sum;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        list = new ArrayList<>();
        res = new LinkedList<>();
        Arrays.sort(candidates);
        sum = 0;
        backtracking(candidates, target, 0);
        return res;
    }

    private void backtracking(int[] candidates, int target, int index) {
        if (sum == target) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = index; i < candidates.length; i++) {
            sum += candidates[i];
            if (sum > target) {
                //i索引后面的数都会大于i索引的值，索引无需继续判断
                sum -= candidates[i];
                return;
            }
            list.add(candidates[i]);
            backtracking(candidates, target, i);
            sum -= candidates[i];
            list.remove(list.size() - 1);
        }
    }
}
```

### 2. [组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)（backtracking）

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

> 1. 所有数字（包括目标数）都是正整数。
> 2. 解集不能包含重复的组合。 

```java
package com.yubin.medium.part3;

import java.util.*;

public class CombinationSum2 {
    private List<Integer> list = null;
    private List<List<Integer>> res = null;
    private int sum;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        list = new ArrayList<>();
        res = new LinkedList<>();
        Arrays.sort(candidates);
        sum = 0;
        backtracking(candidates, target, 0);
        return res;
    }

    private void backtracking(int[] candidates, int target, int index) {
        if (sum == target) {
            res.add(new ArrayList<>(list));
            return;
        }
        int flag = 0;
        for (int i = index; i < candidates.length; i++) {
            if (flag == candidates[i]) continue;
            flag = candidates[i];
            sum += candidates[i];
            if (sum > target) {
                //i索引后面的数都会大于i索引的值，索引无需继续判断
                sum -= candidates[i];
                return;
            }
            list.add(candidates[i]);
            backtracking(candidates, target, i + 1);
            sum -= candidates[i];
            list.remove(list.size() - 1);
        }
    }

    public void test() {
        for (List<Integer> integers : combinationSum2(new int[]{10, 1, 2, 7, 6, 1, 5}, 8)) {
            for (Integer integer : integers) {
                System.out.print(integer + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        new CombinationSum2().test();
    }
}
```

### 3.[有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)（dfs）

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

```java
package com.yubin.medium.part2;

import com.yubin.basic.ListNode;
import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.List;

public class SortedListToBST {
    /**
     * 自顶向下构建二叉树
     */
    private TreeNode dfsUTB(List<Integer> list, int left, int right) {
        if (left > right) return null;
        int mid = (right - left) / 2 + left;
        TreeNode tree = new TreeNode(list.get(mid));
        tree.left = dfsUTB(list, left, mid - 1);
        tree.right = dfsUTB(list, mid + 1, right);
        return tree;
    }

    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        List<Integer> list = new ArrayList<>();
        ListNode n = head;
        while (n != null) {
            list.add(n.val);
            n = n.next;
        }
        return dfsUTB(list, 0, list.size() - 1);
    }


    /**
     * 自底向上构建二叉树
     */
    private ListNode h = null;

    private TreeNode dfsBTU(int left, int right) {
        if (left > right) return null;
        int mid = (right - left) / 2 + left;
        TreeNode leftNode = dfsBTU(left, mid - 1);
        TreeNode tree = new TreeNode(h.val);
        h = h.next;
        TreeNode rightNode = dfsBTU(mid + 1, right);
        tree.left = leftNode;
        tree.right = rightNode;
        return tree;
    }

    public TreeNode sortedListToBST1(ListNode head) {
        if (head == null) return null;
        h = head;
        int size = 0;
        while (h != null) {
            size++;
            h = h.next;
        }
        h = head;
        return dfsBTU(0, size - 1);
    }
}
```

### 4. [子集](https://leetcode-cn.com/problems/subsets/)（backtracking）

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：

> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

```java
package com.yubin.medium.part3;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Subsets {
    private List<List<Integer>> res = null;
    private List<Integer> list = null;

    public List<List<Integer>> subsets(int[] nums) {
        Arrays.sort(nums);
        res = new ArrayList<>();
        list = new ArrayList<>();
        backtracking(nums, 0);
        return res;
    }

    private void backtracking(int[] nums, int index) {
        if (index > nums.length) return;
        res.add(new ArrayList<>(list));
        for (int i = index; i < nums.length; i++) {
            list.add(nums[i]);
            backtracking(nums, i + 1);
            list.remove(list.size() - 1);
        }
    }


    public void test() {
        for (List<Integer> subset : subsets(new int[]{1, 2, 3, 4})) {
            for (Integer integer : subset) {
                System.out.print(integer + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        new Subsets().test();
    }
}
```

### 5. [子集 II](https://leetcode-cn.com/problems/subsets-ii/)（backtracking）

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

 

示例 1：

> 输入：nums = [1,2,2]
> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]

```java
package com.yubin.medium.part3;

import java.util.*;

public class SubsetsWithDup {
    private List<List<Integer>> res = null;
    private List<Integer> list = null;

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        res = new ArrayList<>();
        list = new ArrayList<>();
        backtracking(nums, 0);
        return res;
    }

    private void backtracking(int[] nums, int index) {
        if (index > nums.length) return;
        res.add(new ArrayList<>(list));
        int flag = Integer.MIN_VALUE;
        for (int i = index; i < nums.length; i++) {
            if (flag == nums[i]) continue;
            flag = nums[i];
            list.add(nums[i]);
            backtracking(nums, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```

## part4

### 1. [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)（dfs）

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

> 输入：grid = [
>   ["1","1","1","1","0"],
>   ["1","1","0","1","0"],
>   ["1","1","0","0","0"],
>   ["0","0","0","0","0"]
> ]
> 输出：1

```java
package com.yubin.medium.part4;

public class NumIslands {
    public int numIslands(char[][] grid) {
        int num = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    num++;
                }
            }
        }
        return num;
    }

    private void dfs(char[][] grid, int i, int j) {
        grid[i][j] = '0';
        if (i - 1 >= 0 && grid[i - 1][j] == '1') dfs(grid, i - 1, j);
        if (j - 1 >= 0 && grid[i][j - 1] == '1') dfs(grid, i, j - 1);
        if (i + 1 < grid.length && grid[i + 1][j] == '1') dfs(grid, i + 1, j);
        if (j + 1 < grid[i].length && grid[i][j + 1] == '1') dfs(grid, i, j + 1);
    }
}
```

### 2.[最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)（bfs）

在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）

现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。

返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）

 

示例 1：

输入：A = [[0,1],[1,0]]
输出：1

```java
package com.yubin.medium.part4;

import java.util.LinkedList;

/**
 * 算法思路：
 * 1. 使用dfs找到两个岛屿
 * 2. 对其中一个岛屿进行bfs扩充，直到碰到第二个岛屿
 */
public class ShortestBridge {
    private int m = 0;
    private int n = 0;

    // 第一个岛屿的边界
    private LinkedList<int[]> boundary = null;

    public int shortestBridge(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        boundary = new LinkedList<>();
        int flag = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    dfs(grid, boundary, i, j);
                    flag++;
                }
                if (flag != 0) break;
            }
            if (flag != 0) break;
        }
        return bfs(grid);
    }

    /**
     * 对边界1进行bfs扩展，遇到
     */
    private int bfs(int[][] grid) {
        int res = 1;
        while (true) {
            int size = boundary.size();
            for (int i = 0; i < size; i++) {
                int[] index = boundary.removeFirst();
                int north = index[0] - 1;
                int south = index[0] + 1;
                int west = index[1] - 1;
                int east = index[1] + 1;
                if (north >= 0) {
                    if (grid[north][index[1]] == 1) return res;
                    if (grid[north][index[1]] == 0) {
                        grid[north][index[1]] = 2;
                        boundary.add(new int[]{north, index[1]});
                    }
                }
                if (south < m) {
                    if (grid[south][index[1]] == 1) return res;
                    if (grid[south][index[1]] == 0) {
                        grid[south][index[1]] = 2;
                        boundary.add(new int[]{south, index[1]});
                    }
                }
                if (west >= 0) {
                    if (grid[index[0]][west] == 1) return res;
                    if (grid[index[0]][west] == 0) {
                        grid[index[0]][west] = 2;
                        boundary.add(new int[]{index[0], west});
                    }
                }
                if (east < n) {
                    if (grid[index[0]][east] == 1) return res;
                    if (grid[index[0]][east] == 0) {
                        grid[index[0]][east] = 2;
                        boundary.add(new int[]{index[0], east});
                    }
                }
            }
            res++;
        }
    }

    private void dfs(int[][] grid, LinkedList<int[]> boundary, int i, int j) {
        if (grid[i][j] == 0) {
            boundary.add(new int[]{i, j});
            grid[i][j] = 2;
            return;
        }
        if (grid[i][j] == 2) return;
        grid[i][j] = 2;
        if (i - 1 >= 0) {
            dfs(grid, boundary, i - 1, j);
        }
        if (j - 1 >= 0) {
            dfs(grid, boundary, i, j - 1);
        }
        if (i + 1 < m) {
            dfs(grid, boundary, i + 1, j);
        }
        if (j + 1 < n) {
            dfs(grid, boundary, i, j + 1);
        }
    }

    public void test() {
        System.out.println(shortestBridge(new int[][]{
                {1, 1, 1, 1, 1},
                {1, 0, 0, 0, 1},
                {1, 0, 1, 0, 1},
                {1, 0, 0, 0, 1},
                {1, 1, 1, 1, 1}
        }));
    }

    public static void main(String[] args) {
        new ShortestBridge().test();
    }
}
```

### 3. [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)（bfs）

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
二叉树：[3,9,20,null,null,15,7],

```java
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

```java
package com.yubin.medium.part4;

import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * 二叉树的层序遍历
 */
public class LevelOrder {
    private List<List<Integer>> res = null;
    private LinkedList<TreeNode> list = null;

    public List<List<Integer>> levelOrder(TreeNode root) {
        res = new LinkedList<>();
        list = new LinkedList<>();
        if (root == null) return res;
        list.addLast(root);
        while (true) {
            int size = list.size();
            if (size == 0) return res;
            List<Integer> nums = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = list.removeFirst();
                nums.add(node.val);
                if (node.left != null) list.add(node.left);
                if (node.right != null) list.add(node.right);
            }
            res.add(nums);
        }
    }
}
```

### 4.[二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)（bfs）

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```java
package com.yubin.medium.part4;

import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class LevelOrderBottom {
    /**
     * 从叶子节点向根节点遍历
     */
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        LinkedList<List<Integer>> res = new LinkedList<>();
        LinkedList<TreeNode> list = new LinkedList<>();
        if (root == null) return res;
        list.addLast(root);
        while (true) {
            int size = list.size();
            if (size == 0) return res;
            List<Integer> nums = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = list.removeFirst();
                nums.add(node.val);
                if (node.left != null) list.add(node.left);
                if (node.right != null) list.add(node.right);
            }
            res.addFirst(nums);
        }
    }
}
```

### 5. [二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)（bfs）

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

```java
    3
   / \
  9  20
    /  \
   15   7
```

返回锯齿形层序遍历如下：

> [
>   [3],
>   [20,9],
>   [15,7]
> ]

```java
package com.yubin.medium.part4;

import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ZigzagLevelOrder {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        LinkedList<TreeNode> list = new LinkedList<>();
        if (root == null) return res;
        list.addLast(root);
        boolean flag = true;
        while (true) {
            int size = list.size();
            if (size == 0) return res;
            LinkedList<TreeNode> childNodes = new LinkedList<>();
            List<Integer> nums = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = null;
                if (flag) node = list.removeFirst();
                else node = list.removeLast();
                nums.add(node.val);
                if (flag) {
                    if (node.left != null) childNodes.addLast(node.left);
                    if (node.right != null) childNodes.addLast(node.right);
                } else {
                    if (node.right != null) childNodes.addFirst(node.right);
                    if (node.left != null) childNodes.addFirst(node.left);
                }
            }
            res.add(nums);
            list = childNodes;
            flag = !flag;
        }
    }
}
```

## part5

### 1.[被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)（dfs）

```java
package com.yubin.medium.part5;

import java.util.ArrayList;
import java.util.List;

public class Solve {
    /**
     * 逆向思维，遍历边界的O，进行dfs，不能被dfs搜索到的就是内部O，可以变成X
     */
    public void solve(char[][] board) {
        m = board.length;
        n = board[0].length;
        if (m == 1 || n == 1) return;
        for (int i = 0; i < m; i++) {
            if (board[i][n - 1] == 'O') dfs(board, i, n - 1);
            if (board[i][0] == 'O') dfs(board, i, 0);
        }
        for (int i = 0; i < n; i++) {
            if (board[0][i] == 'O') dfs(board, 0, i);
            if (board[m - 1][i] == 'O') dfs(board, m - 1, i);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                if (board[i][j] == 'o') board[i][j] = 'O';
            }
        }
    }

    private void dfs(char[][] board, int i, int j) {
        if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] != 'O') return;
        board[i][j] = 'o';
        int north = i - 1, south = i + 1, west = j - 1, east = j + 1;
        dfs(board, north, j);
        dfs(board, south, j);
        dfs(board, i, west);
        dfs(board, i, east);
    }

    /**
     * 常规解法，遍历每一个字符，对每一个字符dfs
     */
    private List<int[]> index = null;
    private int m = 0;
    private int n = 0;

    public void solve1(char[][] board) {
        m = board.length;
        n = board[0].length;
        index = new ArrayList<>();
        List<List<int[]>> indexList = new ArrayList<>();
        List<Boolean> flags = new ArrayList<>();
        if (m == 1 || n == 1) return;
        for (int i = 1; i < m - 1; i++) {
            for (int j = 1; j < n - 1; j++) {
                if (board[i][j] == 'O') {
                    flags.add(dfs1(board, i, j));
                    indexList.add(new ArrayList<>(index));
                    index.clear();
                }
            }
        }
        int len = flags.size();
        for (int i = 0; i < len; i++) {
            if (!flags.get(i)) {
                for (int[] indexes : indexList.get(i)) {
                    board[indexes[0]][indexes[1]] = 'O';
                }
            }
        }
    }

    private boolean dfs1(char[][] board, int i, int j) {
        if (i == 0 || j == 0 || i == m - 1 || j == n - 1) return false;
        index.add(new int[]{i, j});
        int north = i - 1, south = i + 1, west = j - 1, east = j + 1;
        boolean flag = true;
        board[i][j] = 'X';
        if (board[north][j] == 'O') flag = dfs1(board, north, j);
        if (board[south][j] == 'O') flag &= dfs1(board, south, j);
        if (board[i][west] == 'O') flag &= dfs1(board, i, west);
        if (board[i][east] == 'O') flag &= dfs1(board, i, east);
        return flag;
    }

    public void test() {
        solve(new char[][]{
                {'O', 'X', 'X', 'O', 'X'},
                {'X', 'O', 'O', 'X', 'O'},
                {'X', 'O', 'X', 'O', 'X'},
                {'O', 'X', 'O', 'O', 'O'},
                {'X', 'X', 'O', 'X', 'O'}});
    }

    public static void main(String[] args) {
        new Solve().test();
    }
}
```

# hard

## part1

### 1.[ N 皇后](https://leetcode-cn.com/problems/n-queens/)（backtracking）（非自己解答）

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

[8皇后问题](https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/11053477?fr=aladdin)

```java
package com.yubin.hard.part1;

import java.util.*;

public class SolveNQueens {
    private List<char[]> list = null;
    private List<List<String>> res = null;
    //列 左斜 右斜
    private boolean[] col = null;
    private boolean[] leftTilt = null;
    private boolean[] rightTilt = null;

    public List<List<String>> solveNQueens(int n) {
        res = new LinkedList<>();
        list = new LinkedList<>();
        col = new boolean[n];
        leftTilt = new boolean[2 * n - 1];
        rightTilt = new boolean[2 * n - 1];
        for (int i = 0; i < n; i++) {
            char[] c = new char[n];
            Arrays.fill(c, '.');
            list.add(c);
        }
        backtracking(0, n);
        return res;
    }

    /**
     * 由于皇后只能存在于一行
     *
     * @param row 在row行填充一个Q
     * @param n   共多少个皇后
     */
    private void backtracking(int row, int n) {
        if (row == n) {
            List<String> l = new LinkedList<>();
            for (char[] chars : list) {
                l.add(String.valueOf(chars));
            }
            res.add(l);
            return;
        }
        //对row行，判断这一列中可以填充皇后的点
        for (int i = 0; i < n; i++) {
            if (col[i] || leftTilt[n - 1 + row - i] || rightTilt[i + row])
                continue;
            list.get(row)[i] = 'Q';
            //设置列属性
            col[i] = leftTilt[n - 1 + row - i] = rightTilt[i + row] = true;
            backtracking(row + 1, n);//设置皇后过后在下一行中找可以放皇后的点
            //恢复状态，在当前行寻找其他可以放皇后的点
            col[i] = leftTilt[n - 1 + row - i] = rightTilt[i + row] = false;
            list.get(row)[i] = '.';
        }
    }

    public void test() {
        List<List<String>> ans = solveNQueens(10);
        for (List<String> re : ans) {
            for (String s : re) {
                System.out.println(s);
            }
            System.out.println();
        }
        System.out.println(ans.size());
    }

    public static void main(String[] args) {
        new SolveNQueens().test();
    }
}
```

### 2. [N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)（backtracking）

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。

```java
package com.yubin.hard.part1;

public class TotalNQueens {
    public int totalNQueens(int n) {
        return new SolveNQueens().solveNQueens(n).size();
    }
}
```

### 3. [单词接龙](https://leetcode-cn.com/problems/word-ladder/)（bfs）（非自己解答）

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：

- 序列中第一个单词是 beginWord 。
- 序列中最后一个单词是 endWord 。
- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须是字典 wordList 中的单词。
- 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。

```java
package com.yubin.hard.part1;

import java.util.*;

public class LadderLength {
    /**
     * 从上到下依次是 ：
     * 单词到计数器的映射
     * 每个单词可以变换一个字符而得到的虚拟单词节点
     * 这个单词是否被访问
     * 单词在wordList中的计数号
     */
    private Map<String, Integer> wordCount = null;
    private List<List<Integer>> edge = null;
    private boolean[] visited = null;
    private int count = 0;

    /**
     * 长度为n的单词将对应n个虚拟节点
     * 可以相互转换的单词毕竟连着着同一个虚拟节点
     *
     * @param word 为每个单词节点创建虚拟节点
     */
    private void addEdge(String word) {
        addWord(word);
        int wordId = wordCount.get(word);
        char[] chars = word.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            char tmp = chars[i];
            chars[i] = '*';
            String newWord = String.valueOf(chars);
            addWord(newWord);
            int newWordId = wordCount.get(newWord);
            edge.get(newWordId).add(wordId);
            edge.get(wordId).add(newWordId);
            chars[i] = tmp;
        }
    }

    /**
     * 为每个单词添加映射的号码
     *
     * @param word 待添加的单词
     */
    private void addWord(String word) {
        if (!wordCount.containsKey(word)) {
            wordCount.put(word, count++);
            edge.add(new ArrayList<>());
        }
    }

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // 初始化
        wordCount = new HashMap<>();
        edge = new ArrayList<>();
        count = 0;
        // 建立图结构
        addEdge(beginWord);
        for (String s : wordList) {
            addEdge(s);
        }
        visited = new boolean[edge.size()];
        // endWord不在映射表中的时候,返回0
        if (!wordCount.containsKey(endWord)) return 0;
        // 进行bfs搜索 寻找到达endWord的最短路径
        int endId = wordCount.get(endWord);
        int beginId = wordCount.get(beginWord);
        LinkedList<Integer> currLevel = new LinkedList<>();
        currLevel.add(beginId);
        int depth = 0;// bfs时探索的深度
        while (!currLevel.isEmpty()) {
            int size = currLevel.size();
            for (int i = 0; i < size; i++) {
                int id = currLevel.removeFirst();
                visited[id] = true;
                if (id == endId) return depth / 2 + 1;
                for (Integer nextId : edge.get(id)) {
                    if (!visited[nextId])
                        currLevel.addLast(nextId);
                }
            }
            depth++;
        }
        return 0;
    }

    public void test() {
        System.out.println(ladderLength("hit", "cog", Arrays.asList("hot", "dot", "dog", "lot", "log", "cog")));
        System.out.println(ladderLength("hot", "dog", Arrays.asList("hot", "dog")));
    }

    public static void main(String[] args) {
        new LadderLength().test();
    }
}
```

### 4. [单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)（bfs+dfs）（自己解答，参考答案以后看）

按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：

- 每对相邻的单词之间仅有单个字母不同。

- 转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。
  sk == endWord

- 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。

 

示例 1：

> 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
> 输出：[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
> 解释：存在 2 种最短的转换序列：
> "hit" -> "hot" -> "dot" -> "dog" -> "cog"
> "hit" -> "hot" -> "lot" -> "log" -> "cog"

**建立节点，属性包含：**

> - 单词word
>
> - wordList中未被访问过的单词中可以由word修改一个字符变换得到的单词构成的子节点
>
> - 所有出现过的父辈节点，只记录单词本身

**算法思路（对应代码解法2）：**

> 构建endWord的节点root，parents初始化
>
> 建立一个currNodes记录每一层中的节点
>
> 1. 记录当前层次节点的数量size
> 2. 然后每次取currNodes得第一个元素节点n并删除这个元素
> 3. 判断n可以到达的word，其中需要配合parents属性判断其是否被访问
> 4. 找到word后，健健成一个节点，复制n节点parents属性到新建节点，并在新建节点的parents属性中添加n节点的word值
> 5. 把新构建的节点加入到currNodes中，重复size次
>
> 在上述过程中，对于每一个n节点，都需要判断n节点的word和beginWord是否相邻
>
> 1. 相邻：则代表这一层是endWord到beginWord的最小转换次数，遍历完currNodes后就可以返回结果了
>
> 2. 到下一层中可以获取的节点数为0时，则说明无法转换到beginWord中，返回空列表
>
> 作者：xing-yuan-fan-xing
> 链接：https://leetcode-cn.com/problems/word-ladder-ii/solution/dan-ci-jie-long-ii-tong-guo-gou-jian-shu-b6fb/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
package com.yubin.hard.part1;

import java.util.*;

public class FindLadders {
    /**
     * 测试两个单词是否只有一个字符之差
     */
    private boolean testWord(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int flag = 0;
        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i) != s2.charAt(i)) flag++;
            if (flag == 2) return false;
        }
        return flag == 1;
    }

    /**
     * -------------------------------------------------------------------------------------------------------
     * 思路2：
     * 使用bfs思想，从endWord向beginWord扩展，第一次遇到beginWord，就意味着是最短路径
     */
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new LinkedList<>();//最终结果
        if (!wordList.contains(endWord)) return ans;

        // 从endWord构造的树结构的根节点
        Node root = new Node(endWord);
        root.parents = new LinkedList<>();
        LinkedList<Node> currNodes = new LinkedList<>();

        currNodes.add(root);

        while (true) {
            int flag = 0;//记录是否遇到了beginWord
            int size = currNodes.size();
            if (size == 0) return ans;
            for (int i = 0; i < size; i++) {
                Node n = currNodes.removeFirst();
                if (testWord(n.word, beginWord)) {
                    Node node = new Node(beginWord);
                    node.parents = new LinkedList<>(n.parents);
                    node.parents.addFirst(n.word);
                    node.parents.addFirst(beginWord);
                    ans.add(node.parents);
                    flag++;
                    continue;
                }
                for (String nextWord : wordList) {
                    if (testWord(n.word, nextWord) && !n.parents.contains(nextWord)) {
                        Node node = new Node(nextWord);
                        node.parents = new LinkedList<>(n.parents);
                        node.parents.addFirst(n.word);
                        currNodes.addLast(node);
                    }
                }
            }
            if (flag != 0) return ans;
        }
    }


    /**
     * 记录一个单词和可以与他转化得到的单词
     */
    private static class Node {
        // 单词 子节点 所有出现过的父辈节点
        String word;
        LinkedList<String> parents;

        public Node(String word) {
            this.word = word;
        }
    }

    /**
     * -------------------------------------------------------------------------------------------------------
     * 思路1
     * 从beginWord开始，使用bfs进行遍历，遇到endWord则对比List长度
     * 若果长度等于res中的元素长度，就添加
     * 小于，则清空res再添加
     * 大于，则直接返回
     */
    /**
     * 记录最终的结果 临时记录结果数据项的List 记录是否访问的字段
     */
    private List<List<String>> res = null;
    private LinkedList<String> list = null;
    private String endWord = null;
    private boolean[] visited = null;

    public List<List<String>> findLadders1(String beginWord, String endWord, List<String> wordList) {
        res = new LinkedList<>();
        if (beginWord.length() != endWord.length()) return res;
        list = new LinkedList<>();
        visited = new boolean[wordList.size()];
        this.endWord = endWord;
        list.add(beginWord);
        dfs(wordList, beginWord, 1);
        return res;
    }

    /**
     * 进行深度优先遍历，寻找最优解
     *
     * @param wordList 单词列表
     * @param preWord  单词接龙的上一个单词
     * @param size     当前已经进入的list的单词数
     */
    private void dfs(List<String> wordList, String preWord, int size) {
        if (size == wordList.size() + 1) return;
        for (int i = 0; i < wordList.size(); i++) {
            String word = wordList.get(i);
            if (!visited[i] && testWord(preWord, word)) {
                visited[i] = true;
                list.addLast(word);
                if (word.equals(endWord)) {
                    addRes();
                    list.removeLast();
                    visited[i] = false;
                    return;
                }
                dfs(wordList, word, size + 1);
                list.removeLast();
                visited[i] = false;
            }
        }
    }

    private void addRes() {
        if (res.size() != 0) {
            if (list.size() > res.get(0).size()) return;
            else if (list.size() == res.get(0).size()) {
                res.add(new LinkedList<>(list));
                return;
            }
        }
        res.clear();
        res.add(new LinkedList<>(list));
    }

    public void test() {
        for (List<String> ladder : findLadders("hit", "cog", Arrays.asList("hot", "dot", "dog", "lot", "log", "cog"))) {
            for (String s : ladder) {
                System.out.print(s + " ");
            }
            System.out.println();
        }
        for (List<String> ladder : findLadders("a", "c", Arrays.asList("a", "b", "c"))) {
            for (String s : ladder) {
                System.out.print(s + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        new FindLadders().test();
    }
}
```

