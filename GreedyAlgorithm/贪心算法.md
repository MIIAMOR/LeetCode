# 贪心算法

## Part1

### 1.[跳跃游戏](https://leetcode-cn.com/problems/jump-game)

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

> 输入：nums = [2,3,1,1,4]
> 输出：true
> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

示例 2：

> 输入：nums = [3,2,1,0,4]
> 输出：false
> 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。


提示：

> 1 <= nums.length <= 3 * 104
> 0 <= nums[i] <= 105

```java
package com.yubin.part1;

public class CanJump {
    /**
     * 判断是否可以达到最后的一个点，只需要判断i（索引）+i对应的值是否可以大于最后一个位置的索引即可
     *
     * @param nums
     * @return
     */
    public boolean canJump(int[] nums) {
        if (nums.length == 1) return true;
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                res = Math.max(i + nums[i], res);
            } else {
                if (res <= i) return false;
            }
            if (res >= nums.length - 1) return true;
        }
        return false;
    }

    public static void main(String[] args) {
        CanJump cj = new CanJump();
        int[] nums1 = new int[]{3, 2, 1, 1, 4};
        int[] nums2 = new int[]{3, 2, 1, 0, 4};
        int[] nums3 = new int[]{0};
        int[] nums4 = new int[]{2, 0, 0};
        System.out.println(cj.canJump(nums1));
        System.out.println(cj.canJump(nums2));
        System.out.println(cj.canJump(nums3));
        System.out.println(cj.canJump(nums4));
    }
}
```

### 2.[跳跃游戏](https://leetcode-cn.com/problems/jump-game-ii)2

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

示例 1:

> 输入: [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

示例 2:

> 输入: [2,3,0,1,4]
> 输出: 2


提示:

> 1 <= nums.length <= 1000
> 0 <= nums[i] <= 105

```java
package com.yubin.part1;

public class Jump {
    /**
     * 判断最短步数到达最后一个点<br>
     * 首先确定当前点A能到达得最远的点B，然后<br>
     * 再在这两点之间，寻找第二步，要求第二步达到的点最远<br>
     * 且起始位置需要是AB之间<br>
     * 依次类推，直到确定到最后一个点的步数
     *
     * @param nums
     * @return
     */
    public int jump(int[] nums) {
        if (nums.length == 1) return 0;
        int res = 1, curr = 0;
        int left = 0, right = nums[0] + 0;
        while (true) {
            if (right >= nums.length - 1) return res;
            for (int i = left; i <= right; i++) {
                curr = Math.max(i + nums[i], curr);
            }
            res++;
            left = right;
            right = curr;
        }
    }

    public static void main(String[] args) {
        Jump j = new Jump();
        int[] nums1 = new int[]{3, 2, 1, 1, 4};
        int[] nums2 = new int[]{2, 3, 0, 1, 4};
        int[] nums3 = new int[]{0};
        int[] nums4 = new int[]{2, 0, 0};
        System.out.println(j.jump(nums1));
        System.out.println(j.jump(nums2));
        System.out.println(j.jump(nums3));
        System.out.println(j.jump(nums4));
    }
}
```

### 3.[分发饼干](https://leetcode-cn.com/problems/assign-cookies)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。


示例 1:

> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。

示例 2:

> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.


提示：

> 1 <= g.length <= 3 * 104
> 0 <= s.length <= 3 * 104
> 1 <= g[i], s[j] <= 231 - 1

```java
package com.yubin.part1;

import java.util.Arrays;

public class FindContentChildren {
    /**
     * 贪心算法求解，优先满足胃口小的孩子，并且让胃口小的孩子先吃到饼干，并且饼干尽可能小
     *
     * @param g
     * @param s
     * @return
     */
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int res = 0;
        for (int i = 0, j = 0; i < g.length && j < s.length; j++) {
            if (g[i] <= s[j]) {
                i++;
                res++;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        FindContentChildren fcc = new FindContentChildren();
        int[] g1 = new int[]{1, 2, 3};
        int[] s1 = new int[]{1, 1};
        System.out.println(fcc.findContentChildren(g1, s1));
        int[] g2 = new int[]{1, 2};
        int[] s2 = new int[]{1, 2, 3};
        System.out.println(fcc.findContentChildren(g2, s2));
    }
}
```

### 4.[加油站](https://leetcode-cn.com/problems/gas-station)

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

> 如果题目有解，该答案即为唯一答案。
> 输入数组均为非空数组，且长度相同。
> 输入数组中的元素均为非负数。

示例 1:

> 输入: 
> gas  = [1,2,3,4,5]
> cost = [3,4,5,1,2]
>
> 输出: 3
>
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。

示例 2:

> 输入: 
> gas  = [2,3,4]
> cost = [3,4,3]
>
> 输出: -1
>
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。

### 5.[去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters)（非自己解答）

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

注意：该题与 1081[不同字符的最小子序列](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/) 相同

 

示例 1：

> 输入：s = "bcabc"
> 输出："abc"

示例 2：

> 输入：s = "cbacdcbc"
> 输出："acdb"


提示：

> 1 <= s.length <= 104
> s 由小写英文字母组成

[解法学习](https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/)

```java
package com.yubin.part1;

import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

public class RemoveDuplicateLetters {
    /**
     * 使用哈希映射外加单调栈<br>
     * 虽然解法上使用了栈，但是不一定非得使用栈数据结构，只要可以发挥出栈的特性就好<br>
     *
     * @param s
     * @return
     */
    public String removeDuplicateLetters(String s) {
        //建立一个数组记录每一个字母出现的频率（O(n)）
        int[] count = new int[26];
        boolean[] in = new boolean[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            int index = s.charAt(i) - 'a';
            count[s.charAt(i) - 'a']--;
            if (in[index]) {
                continue;
            }
            while (sb.length() > 0 && sb.charAt(sb.length() - 1) > s.charAt(i) && count[sb.charAt(sb.length() - 1) - 'a'] > 0) {
                in[sb.charAt(sb.length() - 1) - 'a'] = false;
                sb.deleteCharAt(sb.length() - 1);
            }
            sb.append(s.charAt(i));
            in[index] = true;
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        RemoveDuplicateLetters rdl = new RemoveDuplicateLetters();
        System.out.println(rdl.removeDuplicateLetters("bcabc"));
        System.out.println(rdl.removeDuplicateLetters("cbacdcbc"));
        System.out.println(rdl.removeDuplicateLetters("edebbed"));
        System.out.println(rdl.removeDuplicateLetters("cbacdcbc"));
    }
}
```