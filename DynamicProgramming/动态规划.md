# 动态规划

## Part1

### 1 [Fibonacci数列](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

```java
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。
```

> - 示例 1：
>
>
> 输入：2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
>
> - 示例 2：
>
> 输入：3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
>
> - 示例 3：
>
> 输入：4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3

> 提示：0 <= n <= 30

```java
package com.learn.part1;

/**
 * 动态规划题目：斐波那契数列
 */
public class Fibonacci {
    /**
     * 递归算法，重复调用自身。可能栈内存溢出
     *
     * @param n
     * @return
     */
    public int fib1(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fib1(n - 1) + fib1(n - 2);
        }
    }

    /**
     * 动态规划算法，可以优化，不必开辟数组
     *
     * @param n
     * @return
     */
    public int fib2(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int[] dp = new int[n + 1];
            dp[0] = 0;
            dp[1] = 1;
            for (int i = 2; i < dp.length; i++) {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];
        }
    }

    /**
     * 动态规划改良，减少内存消耗
     * @param n
     * @return
     */
    public int fib3(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int sum = 0, pre = 0, curr = 1;
            for (int i = 1; i < n; i++) {
                sum = curr + pre;
                pre = curr;
                curr = sum;
            }
            return sum;
        }
    }

    public static void main(String[] args) {
        Fibonacci f = new Fibonacci();
        System.out.println(f.fib2(5));
        System.out.println(f.fib1(5));
        System.out.println(f.fib3(5));
    }
}
```

### 2.[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

> - 示例 1：
>
>输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> 
>- 示例 2：
> 
>输入：s = "cbbd"
> 输出："bb"
> 
>- 示例 3：
> 
>输入：s = "a"
> 输出："a"
> 
>- 示例 4：
> 
>输入：s = "ac"
> 输出："a"

>
> 提示：
>
> 1 <= s.length <= 1000
> s 仅由数字和英文字母（大写和/或小写）组成

**`这里的方法2：中心向外扩展法，在LeetCode上无法编译通过，但是idea上可以运行。`**

```java
package com.learn.part1;

public class LongestPalindrome {
    /**
     * <p>动态规划算法</p>
     * <p>1.建立一个dp数组记录dp[j]记录的是以j下标为结尾的最长回文串的开始位置</p>
     * <p>2.如何递推求出每个dp[j]的值</p>
     * <p> 情况1：dp[j+1] = dp[dp[j]-1],这种情况直接使得dp[j+1] = dp[j]-1</p>
     * <p> 情况2：如果没能向两侧扩展，那么需要重新求出最长回文子串<br/>
     * (解决方法：设置两个下标left = dp[j],right = j+1<br>
     * 如果str[lef]==str[right]让left++的同时让right--<br>
     * 如果遇到str[lef]！=str[right]，让right回归初始值，left不变<br>
     * 当left==right的时候，就可以记录dp数组了
     * </p>
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome1(String s) {
        if (s == null) {
            return null;
        }
        int[] dp = new int[s.length()];//建立记录数组
        char[] chars = s.toCharArray();//拆分字符串为一个字符数组
        dp[0] = 0;//初始化dp[0]为0
        //动态求得每一个数组的值
        for (int i = 1; i < chars.length; i++) {
            //边界判断 索引没有变为负数
            if (dp[i - 1] - 1 >= 0 && chars[i] == chars[dp[i - 1] - 1]) {
                //情况1 当前字符串等于上一个字符串的上
                dp[i] = dp[i - 1] - 1;
            } else {
                int left = dp[i - 1], right = i, index = dp[i - 1];
                while (right - left >= 1) {
                    if (chars[left] == chars[right]) {
                        left++;
                        right--;
                    } else {
                        right = i;
                        left++;
                        index = left;
                        if (index == i) break;
                    }
                }
                dp[i] = index;
            }
        }
        //遍历获取最大的回文串
        int begin = 0, end = 0, len = 0;
        for (int i = 0; i < dp.length; i++) {
            if (i - dp[i] > len) {
                begin = dp[i];
                end = i;
                len = i - dp[i];
            }
        }
        return s.substring(begin, end + 1);
    }

    /**
     * 中间向两侧扩展法，思路简单易懂
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome2(String s) {
        if (s == null) {
            return null;
        }
        StringBuilder res = new StringBuilder();
        StringBuilder str1 = new StringBuilder();
        StringBuilder str2 = new StringBuilder();
        for (int i = 0; i < s.length() - 1; i++) {
            str1.delete(0, str1.length()).append(extend(s, i, i));//奇数扩展
            str2.delete(0, str2.length()).append(extend(s, i, i + 1));//偶数扩展
            if (res.length() < str1.length() || res.length() < str2.length()) {
                res.delete(0, res.length()).append(str1.length() > str2.length() ? str1 : str2);
            }
        }
        return res.toString();
    }

    /**
     * 从中间向两侧扩展，注意<br>
     * 回文串是奇数还是偶数<br>
     *
     * @param s     待求的字符串
     * @param left  以该索引向两边扩展
     * @param right 以该索引向两边扩展
     * @return 中间向两侧扩展的最大回文子串
     */
    private String extend(String s, int left, int right) {
        while (left >= 0 && right < s.length()) {
            if (s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
            } else {
                break;
            }
        }
        return s.substring(left + 1, right);
    }

    public static void main(String[] args) {
        LongestPalindrome lp = new LongestPalindrome();
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1("cbbdd"));
        System.out.println(lp.longestPalindrome1("cb"));
        System.out.println(lp.longestPalindrome1("ababababa"));
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1(null));
        System.out.println(lp.longestPalindrome2("asddsa"));
        System.out.println(lp.longestPalindrome2("cbbdd"));
        System.out.println(lp.longestPalindrome2("cb"));
        System.out.println(lp.longestPalindrome2("ababababa"));
        System.out.println(lp.longestPalindrome2("babad"));
        System.out.println(lp.longestPalindrome2("bb"));
        System.out.println(lp.longestPalindrome2("sss"));
        System.out.println(lp.longestPalindrome2(""));
        System.out.println(lp.longestPalindrome2(null));
    }
}
```

### 3.[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)（进阶：分治求解）

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

> - 示例 1：
>
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>
> - 示例 2：
>
> 输入：nums = [1]
> 输出：1
>
> - 示例 3：
>
> 输入：nums = [0]
> 输出：0
>
> - 示例 4：
>
> 输入：nums = [-1]
> 输出：-1
>
> - 示例 5：
>
> 输入：nums = [-100000]
> 输出：-100000
>
> - 
>   提示：1 <= nums.length <= 3 * 104      -105 <= nums[i] <= 105
>
>
> - 
>   进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
>

```java
package com.learn.part1;

public class MaxSubArray {
    /**
     * 动态规划算法<br>
     * 利用一个一维数组dp[j]来记录包含nums[j]的最大子序和<br/>
     * 其中递归规律是：<br>
     * 1.对于dp[j],如果dp[j-1]>0,那么dp[j]=dp[j-1]+nums[j]<br>
     * 2.对于dp[j],如果dp[j-1]<0，那么dp[j]=nums[j]
     *
     * @param nums 一个数组
     * @return 最大子序和（即最大连续子数组和）
     */
    public int maxSubArray1(int[] nums) {
        int[] dp = new int[nums.length];
        int res = nums[0];
        dp[0] = nums[0];
        //按照递推规律求得dp数组的值
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    public static void main(String[] args) {
        MaxSubArray msa = new MaxSubArray();
        int[] nums = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(msa.maxSubArray1(nums));
    }
}
```

### 4.[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
>
> 1 阶 + 1 阶
>
> 2 阶

示例 2：

> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
>
> 1 阶 + 1 阶 + 1 阶
>
> 1 阶 + 2 阶
>
> 2 阶 + 1 阶

```java
package com.learn.part1;

public class ClimbStairs {
    /**
     * 由于爬楼梯的方式要么两格一步，要么一格一步<br>
     * 所以爬到最后一阶楼梯的时候要么跨出两步，要么跨出一步<br>
     * 所以F(n)=F(n-1)+F(n-2)
     *
     * @param n 楼梯数
     * @return 爬楼梯的方式数
     */
    public int climbStairs(int n) {
        int pre = 1, curr = 2, res = 1;
        for (int i = 1; i < n; i++) {
            res = curr;
            curr = pre + curr;
            pre = res;
        }
        return res;
    }

    public static void main(String[] args) {
        ClimbStairs cs = new ClimbStairs();
        System.out.println(cs.climbStairs(4));
    }
}
```

### 5.[买股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。



示例 1：

> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> 示例 2：

> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

> 1 <= prices.length <= 105
> 0 <= prices[i] <= 104