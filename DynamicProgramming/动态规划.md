# 动态规划

# basic

## 1. [背包九讲](https://www.bilibili.com/video/BV1qt411Z7nE?p=2&t=665)

### 1.1.  0-1背包问题

​	**0-1背包问题**：给定 n 件物品，物品的重量为 w[i]，物品的价值为 c[i]。现挑选物品放入背包中，假定背包能承受的最大重量为 V，问应该如何选择装入背包中的物品，使得装入背包中物品的总价值最大？

```java
package com.yubin.basic.knapsack_problem;

/**
 * @author MIIAMOR
 * @date 2021/7/2 20:03
 */
public class Backpack_01 {
    /**
     * @param goods goods[i][0]表示第i个物品的价值，goods[i][1]表示第i个物品的体积
     * @param V     背包的容量
     * @return 最大价值
     */
    public int backpack_01(int[][] goods, int V) {
//        return solution_1(goods, V);
        return solution_2(goods, V);
    }

    /**
     * 0-1背包问题
     * <p>
     * 二维解法：定义二维数组dp，dp[i][j]表示的是只在前i个物品中取出，且背包容量为j的情况下最大的价值
     * <p>
     * 状态转移方程：
     * if (j >= goods[i - 1][1])
     * dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - goods[i - 1][1]] + goods[i - 1][0]);
     * else
     * dp[i][j] = dp[i - 1][j];
     */
    private int solution_1(int[][] goods, int V) {
        int N = goods.length;
        int[][] dp = new int[N + 1][V + 1];// 不取物品的情况下（i == 0），所得的价值自然也是0
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= V; j++) {
                if (j >= goods[i - 1][1])
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - goods[i - 1][1]] + goods[i - 1][0]);
                else
                    dp[i][j] = dp[i - 1][j];
            }
        }
        return dp[N][V];
    }

    /**
     * 从上面的状态转移方程中可以看出：
     * 每个状态都只会与 i - 1 的状态有关
     */
    private int solution_2(int[][] goods, int V) {
        int N = goods.length;
        int[] dp = new int[V + 1];
        for (int i = 1; i <= N; i++) {
            // 这里需要的使用上一层的状态，因此需要从后向前遍历，保证状态迭代的顺序
            for (int j = V; j >= goods[i - 1][1]; j--) {
                dp[j] = Math.max(dp[j - goods[i - 1][1]] + goods[i - 1][0], dp[j]);
            }
        }
        return dp[V];
    }

    public static void main(String[] args) {
        Backpack_01 backpack_01 = new Backpack_01();
        System.out.println(backpack_01.backpack_01(new int[][]
                        {{2, 1}, {4, 2}, {4, 3}, {5, 4}}
                , 5));
        System.out.println(backpack_01.backpack_01(new int[][]
                        {{2, 1}, {4, 2}, {4, 4}, {5, 4}}
                , 5));
    }
}
```

### 1.2. 完全背包问题

```java
package com.yubin.basic.knapsack_problem;

/**
 * @author MIIAMOR
 * @date 2021/7/2 20:43
 */
public class Backpack_Full {
    /**
     * @param goods goods[i][0]表示第i个物品的价值，goods[i][1]表示第i个物品的体积
     * @param V     背包的容量
     * @return 最大价值
     */
    public int backpack_Full(int[][] goods, int V) {
        return solution_1(goods, V);
    }

    /**
     * 完全背包问题
     * <p>
     * 二维解法：定义二维数组dp，dp[i][j]表示的是只在前i个物品中取出，且背包容量为j的情况下最大的价值
     * <p>
     * 状态转移方程：
     * dp[j] = Math.max(dp[j], dp[j - goods[i - 1][1] + goods[i - 1][0]]);
     */
    private int solution_1(int[][] goods, int V) {
        int N = goods.length;
        int[] dp = new int[V + 1];
        for (int i = 1; i <= N; i++) {
            for (int j = goods[i - 1][1]; j <= V; j++) {
                dp[j] = Math.max(dp[j], dp[j - goods[i - 1][1]] + goods[i - 1][0]);
            }
        }
        return dp[V];
    }

    public static void main(String[] args) {
        Backpack_Full backpack_full = new Backpack_Full();
        System.out.println(backpack_full.backpack_Full(new int[][]
                        {{2, 1}, {4, 2}, {4, 3}, {5, 4}}
                , 5));
    }
}
```

# easy

## Part1

### 1 [Fibonacci数列](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

```java
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。
```

> - 示例 1：
>
>输入：2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
> 
>- 示例 2：
> 
>输入：3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
> 
>- 示例 3：
> 
>输入：4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3

> 提示：0 <= n <= 30

```java
package com.yubin.part1;

/**
 * 动态规划题目：斐波那契数列
 */
public class Fibonacci {
    /**
     * 递归算法，重复调用自身。可能栈内存溢出
     *
     * @param n
     * @return
     */
    public int fib1(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fib1(n - 1) + fib1(n - 2);
        }
    }

    /**
     * 动态规划算法，可以优化，不必开辟数组
     *
     * @param n
     * @return
     */
    public int fib2(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int[] dp = new int[n + 1];
            dp[0] = 0;
            dp[1] = 1;
            for (int i = 2; i < dp.length; i++) {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];
        }
    }

    /**
     * 动态规划改良，减少内存消耗
     * @param n
     * @return
     */
    public int fib3(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int sum = 0, pre = 0, curr = 1;
            for (int i = 1; i < n; i++) {
                sum = curr + pre;
                pre = curr;
                curr = sum;
            }
            return sum;
        }
    }

    public static void main(String[] args) {
        Fibonacci f = new Fibonacci();
        System.out.println(f.fib2(5));
        System.out.println(f.fib1(5));
        System.out.println(f.fib3(5));
    }
}
```

### 2.[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)（进阶：分治求解）

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

> - 示例 1：
>
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>
> - 示例 2：
>
> 输入：nums = [1]
> 输出：1
>
> - 示例 3：
>
> 输入：nums = [0]
> 输出：0
>
> - 示例 4：
>
> 输入：nums = [-1]
> 输出：-1
>
> - 示例 5：
>
> 输入：nums = [-100000]
> 输出：-100000
>
> - 
>   提示：1 <= nums.length <= 3 * 104      -105 <= nums[i] <= 105
>
>
> - 
>   进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
>

```java
package com.yubin.part1;

public class MaxSubArray {
    /**
     * 动态规划算法<br>
     * 利用一个一维数组dp[j]来记录包含nums[j]的最大子序和<br/>
     * 其中递归规律是：<br>
     * 1.对于dp[j],如果dp[j-1]>0,那么dp[j]=dp[j-1]+nums[j]<br>
     * 2.对于dp[j],如果dp[j-1]<0，那么dp[j]=nums[j]
     *
     * @param nums 一个数组
     * @return 最大子序和（即最大连续子数组和）
     */
    public int maxSubArray1(int[] nums) {
        int[] dp = new int[nums.length];
        int res = nums[0];
        dp[0] = nums[0];
        //按照递推规律求得dp数组的值
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    public int maxSubArray2(int[] nums) {
        int curr = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            curr = Math.max(curr + nums[i], nums[i]);
            res = Math.max(res, curr);
        }
        return res;
    }

    public static void main(String[] args) {
        MaxSubArray msa = new MaxSubArray();
        int[] nums = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(msa.maxSubArray1(nums));
        System.out.println(msa.maxSubArray2(nums));
    }
}

```

### 3.[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
>
> 1 阶 + 1 阶
>
> 2 阶

示例 2：

> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
>
> 1 阶 + 1 阶 + 1 阶
>
> 1 阶 + 2 阶
>
> 2 阶 + 1 阶

```java
package com.yubin.part1;

public class ClimbStairs {
    /**
     * 由于爬楼梯的方式要么两格一步，要么一格一步<br>
     * 所以爬到最后一阶楼梯的时候要么跨出两步，要么跨出一步<br>
     * 所以F(n)=F(n-1)+F(n-2)
     *
     * @param n 楼梯数
     * @return 爬楼梯的方式数
     */
    public int climbStairs(int n) {
        int pre = 1, curr = 2, res = 1;
        for (int i = 1; i < n; i++) {
            res = curr;
            curr = pre + curr;
            pre = res;
        }
        return res;
    }

    public static void main(String[] args) {
        ClimbStairs cs = new ClimbStairs();
        System.out.println(cs.climbStairs(4));
    }
}
```

### 4.[买股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。



示例 1：

> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：

> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

> 1 <= prices.length <= 105
> 0 <= prices[i] <= 104

```java
package com.yubin.part1;

public class MaxProfit {
    /**
     * 分析：<br>
     * <p>
     * 解法1：暴力遍历数组，记录最大的利益 timeoutError
     * </p>
     *
     * @param prices 股票的价格
     * @return 最大收益
     */
    public int maxProfit1(int[] prices) {
        int res = 0;
        for (int i = prices.length - 1; i >= 0; i--) {
            for (int j = i; j >= 0; j--) {
                if (prices[j] < prices[i] && res < prices[i] - prices[j]) res = prices[i] - prices[j];
            }
        }
        return res;
    }

    /**
     * 分析：<br>
     * <p>
     * 解法2：图像分析法+动态规划算法<br>
     * 把每个值绘制在折线图中，就可以非常直观看到每个数值的大小关系了<br>
     * 整个过程就是找出极差，右边的数必须大于左边的数<br>
     * 用数组dp表示动态规划的状态数组，则dp[i]表示到第i天时的最大利润。<br>
     * 用变量cur_min_buy维护截止到前一天股票的最低买入价格<br>
     * 则不难看出状态转移方程为dp[i]=max(dp[i-1], prices[i]-cur_min_buy).<br>
     *     在动态记录这个result即可
     * </p>
     *
     * @param prices 股票的价格
     * @return 最大收益
     */
    public int maxProfit2(int[] prices) {
        if (prices.length < 2) return 0;
        // res用来记录当前已经知道的最大利益，currMin用来记录已知的最小股票市价
        int res = 0, currMin = prices[0];
        for (int price : prices) {
            currMin = Math.min(currMin, price);
            res = Math.max(res, price - currMin);
        }
        return res;
    }

    public static void main(String[] args) {
        MaxProfit mp = new MaxProfit();
        int[] prices = new int[]{7, 1, 5, 3, 6, 4};
        System.out.println(mp.maxProfit1(prices));
        System.out.println(mp.maxProfit2(prices));
    }
}
```

### 5. [区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。

实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）

```java
package com.yubin.easy.part1;

/**
 * @author MIIAMOR
 * @date 2021/6/22
 */
class NumArray {
    /**
     * Your NumArray object will be instantiated and called as such:
     * NumArray obj = new NumArray(nums);
     * int param_1 = obj.sumRange(left,right);
     */
    private int[] dp = null;

    public NumArray(int[] nums) {
        int len = nums.length;
        dp = new int[len + 1];
        dp[0] = 0;
        for (int i = 1; i <= len; i++) {
            dp[i] = dp[i - 1] + nums[i - 1];
        }
    }

    public int sumRange(int left, int right) {
        int res = 0;
        res = dp[right + 1] - dp[left];
        return res;
    }
}
```

## Part2

### 1. [比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

> 输入: 2
> 输出: [0,1,1]

[官方解题](https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/)

```java
package com.yubin.easy.part2;

/**
 * @author MIIAMOR
 * @date 2021/6/22
 */
public class CountBits {
    public int[] countBits(int n) {
        int[] res = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            res[i] = countOnes(i);
        }
        return res;
    }

    private int countOnes(int x) {
        int count = 0;
        while (x > 0) {
            x &= (x - 1);
            count++;
        }
        return count;
    }

    public int[] countBits1(int n) {
        int[] bits = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            bits[i] = bits[i & (i - 1)] + 1;
        }
        return bits;
    }
}
```

# medium

## Part1

### 1.[解码方式](https://leetcode-cn.com/problems/decode-ways)

一条包含字母 A-Z 的消息通过以下映射进行了编码 ：

> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26

要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

- "AAJF" ，将消息分组为 (1 1 10 6)
- "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

 

示例 1：

> 输入：s = "12"
> 输出：2
> 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：

> 输入：s = "226"
> 输出：3
> 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：

> 输入：s = "0"
> 输出：0
> 解释：没有字符映射到以 0 开头的数字。
> 含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
> 由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。

示例 4：

> 输入：s = "06"
> 输出：0
> 解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。


提示：

> 1 <= s.length <= 100
> s 只包含数字，并且可能包含前导零。

```java
package com.yubin.part2;

public class NumDecodings {
    /**
     * 动态规划算法<br>
     * 设置一个dp[]数组用于记录到s[i]处时解码的串数量<br>
     * 从左到右查看时数字的时候，由于字母与数字的映射是1-26，那么需要考虑两种位数的情况<br>
     * 1. 只有一位数进行字符扩展的时候，那么i处能得到的串数量就是i-1处的串数量<br>
     * 这里需要注意的是0的情况，0不会构成字符，所以1位扩展在s[i]=='0'时无效<br>
     * 2. 有两位数字进行扩展的时候，那么i出可以得到的串数量，就是i-2出已经知道的串数量<br>
     * 这里需要注意的是，由于1-26才会对应出字符，所以需要进行数的大小判断<p></p>
     * 这里由于值需要用到dp[i]前面的两个数，所以，可以不定义数组
     *
     * @param s
     * @return
     */
    public int numDecodings1(String s) {
        int res = 0, pre1 = 1, pre2 = 1;
        int num;
        for (int i = 0; i < s.length(); i++) {
            res = 0;
            num = Integer.parseInt(String.valueOf(s.charAt(i)));
            if (num >= 1 && num <= 9) {
                res += pre1;
            }
            if (i - 1 >= 0 && s.charAt(i - 1) != '0') {
                num = Integer.parseInt(s.substring(i - 1, i + 1));
                if (num >= 1 && num <= 26) {
                    res += pre2;
                }
            }
            pre2 = pre1;
            pre1 = res;
        }
        return res;
    }

    /**
     * 时间内复杂度终于优化到了100%<br>
     * 执行用时： 1 ms , 在所有 Java 提交中击败了100.00% 的用户<br>
     * 内存消耗： 36.3 MB , 在所有 Java 提交中击败了 98.86% 的用户
     *
     * @param s
     * @return
     */
    public int numDecodings2(String s) {
        int res = 0, pre1 = 1, pre2 = 1;
        for (int i = 0; i < s.length(); i++) {
            res = 0;
            if (s.charAt(i) >= '1' && s.charAt(i) <= '9') {
                res += pre1;
            }
            if (i - 1 >= 0 && (s.charAt(i - 1) == '1' || (s.charAt(i - 1) == '2' && s.charAt(i) < '7'))) {
                res += pre2;
            }
            pre2 = pre1;
            pre1 = res;
        }
        return res;
    }

    public static void main(String[] args) {
        NumDecodings nd = new NumDecodings();
        System.out.println(nd.numDecodings1("111"));
        System.out.println(nd.numDecodings1("12"));
        System.out.println(nd.numDecodings1("226"));
        System.out.println(nd.numDecodings1("0"));
        System.out.println(nd.numDecodings1("06"));
        System.out.println(nd.numDecodings2("111"));
        System.out.println(nd.numDecodings2("12"));
        System.out.println(nd.numDecodings2("226"));
        System.out.println(nd.numDecodings2("0"));
        System.out.println(nd.numDecodings2("06"));
    }
}
```

### 2.[不同路径](https://leetcode-cn.com/problems/unique-paths)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：

> 输入：m = 3, n = 7
> 输出：28

示例 2：

> 输入：m = 3, n = 2
> 输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
>
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下

示例 3：

> 输入：m = 7, n = 3
> 输出：28

示例 4：

> 输入：m = 3, n = 3
> 输出：6


提示：

> 1 <= m, n <= 100
> 题目数据保证答案小于等于 2 * 109

```java
package com.yubin.part2;

public class UniquePaths {
    /**
     * 动态规划算法求取最多的路径数量<br>
     * 递推关系，对于最终的目的点，由于只能选择右或者下，最后只有两个地方直接抵达这个点<br>
     * 即改点的上一个点或者左边的那个点，由此得到递推关系dp[i][j]=dp[i-1][j]+dp[i][j-1]
     *
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths1(int m, int n) {
        int[][] dp = new int[m][n];
        //递推求解数组中的每个值
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) dp[i][j] = 1;
                else
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * 动态规划算法空间优化<br>
     * 遍历得时候按照行进行遍历，那么只需要记录上一行和当前点的左边即可
     *
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths2(int m, int n) {
        int[] preRow = new int[n];
        int[] currRow = new int[n];
        currRow[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (i == 0) currRow[j] = 1;
                else currRow[j] = preRow[j] + currRow[j - 1];
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        UniquePaths up = new UniquePaths();
        System.out.println(up.uniquePaths1(3, 7));
    }
}
```

### 3.[不同路径2](https://leetcode-cn.com/problems/unique-paths-ii)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？



网格中的障碍物和空位置分别用 1 和 0 来表示。

 

示例 1：

> 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
> 输出：2
> 解释：
> 3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
>
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右

示例 2：

> 输入：obstacleGrid = [[0,1],[0,0]]
> 输出：1


提示：

> m == obstacleGrid.length
> n == obstacleGrid[i].length
> 1 <= m, n <= 100
> obstacleGrid[i][j] 为 0 或 1

```java
package com.yubin.part2;

public class UniquePathsWithObstacles {

    /**
     * 动态规划算法求取最多的路径数量<br>
     * 递推关系，对于最终的目的点，由于只能选择右或者下，最后只有两个地方直接抵达这个点<br>
     * 即改点的上一个点或者左边的那个点，由此得到递推关系dp[i][j]=dp[i-1][j]+dp[i][j-1]<br>
     * 但是，由于中间有不可过的点，那么这个位置的dp值置0
     *
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles1(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i < m + 1; i++) {
            for (int j = 0; j < n + 1; j++) {
                if (i == 0 || j == 0) dp[i][j] = 0;
                else if (i == 1 && j == 1) dp[i][j] = obstacleGrid[0][0] == 0 ? 1 : 0;
                else {
                    if (obstacleGrid[i - 1][j - 1] == 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    else dp[i][j] = 0;
                }
            }
        }
        return dp[m][n];
    }

    /**
     * 对动态规划算法进行空间优化
     *
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles2(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[] preRow = new int[n];
        int[] currRow = new int[n];
        boolean flag = false;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0) {
                    //第一行
                    if (obstacleGrid[i][j] == 1) {
                        flag = true;
                        currRow[j] = 0;
                    } else if (obstacleGrid[i][j] == 0 && flag == false) {
                        currRow[j] = 1;
                    } else if (flag) {
                        currRow[j] = 0;
                    }
                } else if (j == 0) {
                    if (obstacleGrid[i][j] == 1) currRow[0] = 0;
                } else {
                    if (obstacleGrid[i][j] == 1) {
                        currRow[j] = 0;
                    } else {
                        currRow[j] = preRow[j] + currRow[j - 1];
                    }
                }
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        UniquePathsWithObstacles upo = new UniquePathsWithObstacles();
        int[][] grid = new int[][]{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
        System.out.println(upo.uniquePathsWithObstacles1(grid));
        System.out.println(upo.uniquePathsWithObstacles2(grid));
    }
}
```

### 4.[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum)

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例 1：

> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
> 输出：7
> 解释：因为路径 1→3→1→1→1 的总和最小。

示例 2：

> 输入：grid = [[1,2,3],[4,5,6]]
> 输出：12


提示：

> m == grid.length
> n == grid[i].length
> 1 <= m, n <= 200
> 0 <= grid[i][j] <= 100

```java
package com.yubin.part2;

public class MinPathSum {
    /**
     * 动态规划算法，当前点的最短路径等于左边和上边的点中的较小值加上自己
     *
     * @param grid
     * @return
     */
    public int minPathSum1(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j > 0) dp[i][j] = dp[i][j - 1] + grid[i][j];
                else if (j == 0 && i > 0) dp[i][j] = dp[i - 1][j] + grid[i][j];
                else if (i > 0 && j > 0)
                    dp[i][j] = Math.min(grid[i][j] + dp[i - 1][j], grid[i][j] + dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * 动态规划优化空间复杂度,只维护行数据
     *
     * @param grid
     * @return
     */
    public int minPathSum2(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] currRow = new int[n];
        int[] preRow = new int[n];
        currRow[0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j > 0) currRow[j] = grid[i][j] + currRow[j - 1];
                else if (j == 0 && i > 0) currRow[j] = grid[i][j] + preRow[j];
                else if (i > 0 && j > 0) currRow[j] = Math.min(grid[i][j] + currRow[j - 1], grid[i][j] + preRow[j]);
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        int[][] grid = new int[][]{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};
        int[][] grid2 = new int[][]{{1, 2, 3}, {4, 5, 6}};
        MinPathSum mps = new MinPathSum();
        System.out.println(mps.minPathSum1(grid));
        System.out.println(mps.minPathSum2(grid));
        System.out.println(mps.minPathSum1(grid2));
        System.out.println(mps.minPathSum2(grid2));
    }
}
```

### 5.[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

> - 示例 1：
>
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
>
> - 示例 2：
>
> 输入：s = "cbbd"
> 输出："bb"
>
> - 示例 3：
>
> 输入：s = "a"
> 输出："a"
>
> - 示例 4：
>
> 输入：s = "ac"
> 输出："a"

>提示：
>
>1 <= s.length <= 1000
>s 仅由数字和英文字母（大写和/或小写）组成

**`这里的方法2：中心向外扩展法，在LeetCode上无法编译通过，但是idea上可以运行。`**

```java
package com.yubin.medium.part1;

public class LongestPalindrome {
    /**
     * <p>动态规划算法</p>
     * <p>1.建立一个dp数组记录dp[j]记录的是以j下标为结尾的最长回文串的开始位置</p>
     * <p>2.如何递推求出每个dp[j]的值</p>
     * <p> 情况1：dp[j+1] = dp[dp[j]-1],这种情况直接使得dp[j+1] = dp[j]-1</p>
     * <p> 情况2：如果没能向两侧扩展，那么需要重新求出最长回文子串<br/>
     * (解决方法：设置两个下标left = dp[j],right = j+1<br>
     * 如果str[lef]==str[right]让left++的同时让right--<br>
     * 如果遇到str[lef]！=str[right]，让right回归初始值，left不变<br>
     * 当left==right的时候，就可以记录dp数组了
     * </p>
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome1(String s) {
        if (s == null) {
            return null;
        }
        int[] dp = new int[s.length()];//建立记录数组
        char[] chars = s.toCharArray();//拆分字符串为一个字符数组
        dp[0] = 0;//初始化dp[0]为0
        //动态求得每一个数组的值
        for (int i = 1; i < chars.length; i++) {
            //边界判断 索引没有变为负数
            if (dp[i - 1] - 1 >= 0 && chars[i] == chars[dp[i - 1] - 1]) {
                //情况1 当前字符串等于上一个字符串的上
                dp[i] = dp[i - 1] - 1;
            } else {
                int left = dp[i - 1], right = i, index = dp[i - 1];
                while (right - left >= 1) {
                    if (chars[left] == chars[right]) {
                        left++;
                        right--;
                    } else {
                        right = i;
                        left++;
                        index = left;
                        if (index == i) break;
                    }
                }
                dp[i] = index;
            }
        }
        //遍历获取最大的回文串
        int begin = 0, end = 0, len = 0;
        for (int i = 0; i < dp.length; i++) {
            if (i - dp[i] > len) {
                begin = dp[i];
                end = i;
                len = i - dp[i];
            }
        }
        return s.substring(begin, end + 1);
    }

    /**
     * 中间向两侧扩展法，思路简单易懂
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome2(String s) {
        if (s == null) {
            return null;
        }
        StringBuilder res = new StringBuilder();
        StringBuilder str1 = new StringBuilder();
        StringBuilder str2 = new StringBuilder();
        for (int i = 0; i < s.length() - 1; i++) {
            str1.delete(0, str1.length()).append(extend(s, i, i));//奇数扩展
            str2.delete(0, str2.length()).append(extend(s, i, i + 1));//偶数扩展
            if (res.length() < str1.length() || res.length() < str2.length()) {
                res.delete(0, res.length()).append(str1.length() > str2.length() ? str1 : str2);
            }
        }
        return res.toString();
    }

    /**
     * 从中间向两侧扩展，注意<br>
     * 回文串是奇数还是偶数<br>
     *
     * @param s     待求的字符串
     * @param left  以该索引向两边扩展
     * @param right 以该索引向两边扩展
     * @return 中间向两侧扩展的最大回文子串
     */
    private String extend(String s, int left, int right) {
        while (left >= 0 && right < s.length()) {
            if (s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
            } else {
                break;
            }
        }
        return s.substring(left + 1, right);
    }

    public static void main(String[] args) {
        LongestPalindrome lp = new LongestPalindrome();
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1("cbbdd"));
        System.out.println(lp.longestPalindrome1("cb"));
        System.out.println(lp.longestPalindrome1("ababababa"));
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1(null));
        System.out.println(lp.longestPalindrome2("asddsa"));
        System.out.println(lp.longestPalindrome2("cbbdd"));
        System.out.println(lp.longestPalindrome2("cb"));
        System.out.println(lp.longestPalindrome2("ababababa"));
        System.out.println(lp.longestPalindrome2("babad"));
        System.out.println(lp.longestPalindrome2("bb"));
        System.out.println(lp.longestPalindrome2("sss"));
        System.out.println(lp.longestPalindrome2(""));
        System.out.println(lp.longestPalindrome2(null));
    }
}
```

## Part2

### 1. [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>             偷窃到的最高金额 = 1 + 3 = 4 。

```java
package com.yubin.medium.part2;

public class Rob {
    /**
     * 限制：不可以同时访问相邻的两个数
     * 思路：每家都可以选择偷或者不偷，如果偷第i家，那么当前最大的值就是i-2家前所得的最大值加上i家
     *
     * @param nums 每家中存在的现金数量
     * @return
     */
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        int len = nums.length;
        // 分别表示偷这家 或者 放过这家 者两种情况已经偷盗的最大值
        int[] steal = new int[len];
        int[] leave = new int[len];
        steal[0] = nums[0];
        steal[1] = nums[1];
        leave[0] = 0;
        leave[1] = nums[0];
        for (int i = 2; i < nums.length; i++) {
            // 如果选择放过这家  则可以获取的最大值就是 steal[i-1]或者leave[i-1]
            leave[i] = Math.max(steal[i - 1], leave[i - 1]);
            // 如果选择偷盗这家  则可以获取的最大值就是 leave[i-1]和steal[i-2]中的最大值加上nums[i]
            steal[i] = Math.max(leave[i - 1], steal[i - 2]) + nums[i];
        }
        return Math.max(steal[len - 1], leave[len - 1]);
    }

    /**
     * 空间优化，每次只用了三个数来递推求解
     */
    public int rob1(int[] nums) {
        if (nums.length == 1) return nums[0];
        int len = nums.length;
        int steal2 = nums[0], steal1 = nums[1], leave1 = nums[0];
        int leave = nums[0], steal = Math.max(nums[0], nums[1]);
        for (int i = 2; i < len; i++) {
            leave = Math.max(leave1, steal1);
            steal = Math.max(leave1, steal2) + nums[i];
            leave1 = leave;
            steal2 = steal1;
            steal1 = steal;
        }
        return Math.max(leave, steal);
    }

    public void test() {
        System.out.println(rob1(new int[]{1, 2, 3, 1}));
    }

    public static void main(String[] args) {
        new Rob().test();
    }
}
```

### 2. [等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

> 例如，以下数列为等差数列:
>
> 1, 3, 5, 7, 9
> 7, 7, 7, 7
> 3, -1, -5, -9
>
> 以下数列不是等差数列。
>
> 1, 1, 2, 5, 7

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。

 

示例:

> A = [1, 2, 3, 4]
>
> 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
>

```java
package com.yubin.medium.part2;

/**
 * 给定一个数组，求数组中连续且等差的子数组数量
 */
public class NumberOfArithmeticSlices {
    public int numberOfArithmeticSlices(int[] nums) {
        if (nums.length < 3) return 0;
        int res = 0;
        int count = 1, cap = Integer.MIN_VALUE;
        // 循环求取连续的等差数组，每一次求得一个等差连续数组，就让结果加上他的子数组数量
        for (int i = 0; i < nums.length; i++) {
            count++;
            if (i == nums.length - 1) {
                if (nums[i] - nums[i - 1] == cap)
                    res += numberOfSubarray(count);
                else res += numberOfSubarray(count - 1);
                break;
            }
            int dif = nums[i + 1] - nums[i];
            if (cap != dif) {
                res += numberOfSubarray(count);
                cap = dif;
                count = 1;
            }
        }
        return res;
    }

    /**
     * 求长度大于等于3的连续子数组的数量
     */
    private int numberOfSubarray(int n) {
        if (n < 3) return 0;
        int l = n - 2;
        return (l + 1) * l / 2;
    }

    public void test() {
        System.out.println(numberOfArithmeticSlices(new int[]{1, 2, 3, 4, -1, 6, 7, 8, 9, 10, 12}));
    }

    public static void main(String[] args) {
        new NumberOfArithmeticSlices().test();
    }
}
```

### 3. [01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。



示例 1：

> 输入：
> [[0,0,0],
>  [0,1,0],
>  [0,0,0]]
>
> 输出：
> [[0,0,0],
>  [0,1,0],
>  [0,0,0]]

`大佬的反方向遍历思想没有想明白，以后再想`

```java
package com.yubin.medium.part2;

public class UpdateMatrix {
    /**
     * 常规解法：
     * 初始化结果数组
     * 第一次遍历：把1的点设置为10000，0的带你设置为0
     * 之后对结果数组不停的遍历，一直到res中所有的值都不在变化为止
     */
    public int[][] updateMatrix(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[][] res = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] != 0) res[i][j] = 10000;
            }
        }
        while (true) {
            int count = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (res[i][j] > 0) {
                        int north = i - 1, south = i + 1, west = j - 1, east = j + 1;
                        int dis = 10000;
                        if (north >= 0) dis = Math.min(res[north][j] + 1, dis);
                        if (south < m) dis = Math.min(res[south][j] + 1, dis);
                        if (west >= 0) dis = Math.min(res[i][west] + 1, dis);
                        if (east < n) dis = Math.min(res[i][east] + 1, dis);
                        if (dis != res[i][j]) {
                            res[i][j] = dis;
                            count++;
                        }
                    }
                }
            }
            if (count == 0) break;
        }
        return res;
    }

    public int[][] updateMatrix1(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[][] res = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] != 0) res[i][j] = 10000;
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (res[i][j] > 0) {
                    int north = i - 1, west = j - 1;
                    if (north >= 0) res[i][j] = Math.min(res[north][j] + 1, res[i][j]);
                    if (west >= 0) res[i][j] = Math.min(res[i][west] + 1, res[i][j]);
                }
            }
        }
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (res[i][j] > 0) {
                    int south = i + 1, east = j + 1;
                    if (south < m) res[i][j] = Math.min(res[south][j] + 1, res[i][j]);
                    if (east < n) res[i][j] = Math.min(res[i][east] + 1, res[i][j]);
                }
            }
        }
        return res;
    }

    public void test() {
        for (int[] matrix : updateMatrix(new int[][]{
                {0, 0, 0},
                {0, 1, 0},
                {1, 1, 1}})) {
            for (int i : matrix) {
                System.out.print(i + " ");
            }
            System.out.println();
        }
        for (int[] matrix : updateMatrix1(new int[][]{
                {0, 0, 0},
                {0, 1, 0},
                {1, 1, 1}})) {
            for (int i : matrix) {
                System.out.print(i + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        new UpdateMatrix().test();
    }
}
```

### 4. [最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

 

示例 1：

> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
> 输出：4

```java
package com.yubin.medium.part2;

public class MaximalSquare {
    /**
     * dp数组中存放的是ij最大正方形的边长
     */
    public int maximalSquare(char[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[][] dp = new int[m][n];
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = matrix[i][j] - '0';
                } else if (matrix[i][j] == '1') {
                    int square;
                    square = Math.min(dp[i][j - 1], dp[i - 1][j]);
                    square = Math.min(square, dp[i - 1][j - 1]);
                    dp[i][j] = square + matrix[i][j] - '0';
                }
                res = Math.max(dp[i][j], res);
            }
        }
        return res * res;
    }

    /**
     * 空间优化
     */
    public int maximalSquare1(char[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[] dp = new int[n];
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < m; i++) {
            int pre = 0, curr = 0;
            for (int j = 0; j < n; j++) {
                if (i == 0) {
                    curr = matrix[i][j] - '0';
                    dp[j] = curr;
                } else if (j == 0) {
                    curr = matrix[i][j] - '0';
                    pre = curr;
                } else {
                    if (matrix[i][j] == '1') {
                        curr = Math.min(dp[j - 1], dp[j]);
                        curr = Math.min(pre, curr) + matrix[i][j] - '0';
                    } else curr = 0;
                    dp[j - 1] = pre;
                    pre = curr;
                    if (j == n - 1) dp[j] = curr;
                }
                res = Math.max(curr, res);
            }
        }
        return res * res;
    }

    public void test() {
        maximalSquare(new char[][]{
                {'1', '0', '1', '1', '0', '1'},
                {'1', '1', '1', '1', '1', '1'},
                {'0', '1', '1', '0', '1', '1'},
                {'1', '1', '1', '0', '1', '0'},
                {'0', '1', '1', '1', '1', '1'},
                {'1', '1', '0', '1', '1', '1'}
        });
        maximalSquare1(new char[][]{
                {'1', '0'},
                {'0', '1'},
                {'0', '1'},
                {'0', '1'},
                {'1', '1'},
                {'0', '0'},
                {'0', '1'}
        });
        maximalSquare1(new char[][]{
                {'0'},
                {'1'}
        });
    }

    public static void main(String[] args) {
        new MaximalSquare().test();
    }
}
```

### 5. [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)（分割型动态规划）（非自己解答）

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

[ 四平方和定理](https://baike.baidu.com/item/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86)

> 同时四平方和定理包含了一个更强的结论：当且仅当 n不等于 4^k \times (8m+7)，n 可以被表示为至多三个正整数的平方和。因此，当n=4^k×(8m+7) 时，n 只能被表示为四个正整数的平方和。此时我们可以直接返回 4。
>

示例 ：

> 输入：n = 12
> 输出：3 
> 解释：12 = 4 + 4 + 4
>

```java
package com.yubin.medium.part2;


public class NumSquares {
    /**
     * dp[i]表示数字i最少可以用
     */
    public int numSquares1(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            dp[i] = 10000;
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }

    /**
     * 利用数学知识解题（四平方和定理）
     */
    public int numSquares(int n) {
        // 第一步：判断是否是完全平方数
        if (isSquares(n)) return 1;
        // 第二步：判断是否可以有两个完全平方数相加得到
        for (int i = 1; i <= (int) Math.sqrt(n); i++) {
            int num = n - i * i;
            if (isSquares(num)) return 2;
        }
        // 第三步：判断是否可以有四个完全平方数相加得来
        if (isSquaresOfFour(n)) return 4;
        return 3;
    }

    /**
     * n = 4^k*(8*m+7)
     */
    private boolean isSquaresOfFour(int n) {
        while (n % 4 == 0) n /= 4;
        return n % 8 == 7;
    }

    private boolean isSquares(int n) {
        int i = (int) Math.sqrt(n);
        return i * i == n;
    }


    public static void main(String[] args) {
        new NumSquares().numSquares1(12);
    }
}
```

## part3

### 1. [单词拆分](https://leetcode-cn.com/problems/word-break/)（非自己解答）

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

示例 1：

> 输入: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

```java
package com.yubin.medium.part3;

import java.util.Arrays;
import java.util.List;

public class WordBreak {
    /**
     * wordInList[i]代表i以前的单词是否都可以被划分
     */
    public boolean wordBreak1(String s, List<String> wordDict) {
        int len = s.length();
        boolean[] wordInList = new boolean[len + 1];
        wordInList[0] = true;
        for (int i = 1; i < len + 1; i++) {
            for (String word : wordDict) {
                int lenOfWord = word.length();
                if (i >= lenOfWord) {
                    String subWord = s.substring(i - lenOfWord, i);
                    if (subWord.equals(word))
                        wordInList[i] = wordInList[i] || wordInList[i - lenOfWord];
                }
            }
        }
        return wordInList[len];
    }


    /**
     * dfs搜索
     */
    public boolean wordBreak(String s, List<String> wordDict) {
        if (s.length() == 0) return true;
        for (String word : wordDict) {
            int lenOfWord = word.length();
            if (s.length() < lenOfWord) continue;
            if (word.equals(s.substring(0, lenOfWord)))
                if (wordBreak(s.substring(lenOfWord), wordDict))
                    return true;
        }
        return false;
    }

    public static void main(String[] args) {
        System.out.println(new WordBreak().wordBreak("cars",
                Arrays.asList("car", "ca", "rs")));
    }
}
```

### 2. [最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


示例 1：

> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。



```java
package com.yubin.medium.part3;

import java.util.Arrays;

public class LengthOfLIS {
    /**
     * O(n^2)
     */
    public int lengthOfLIS1(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    /**
     * 使用二分搜索降低时间复杂度
     */
    public int lengthOfLIS(int[] nums) {
        int size = nums.length;
        int[] dp = new int[size + 1];
        dp[0] = nums[0];
        int len = 1;
        for (int i = 1; i < size; i++) {
            if (nums[i] > dp[len - 1]) {
                dp[len] = nums[i];
                len++;
            } else {
                int right = len - 1;
                for (int index = 0; index <= right; index++) {
                    if (dp[index] >= nums[i]) {
                        dp[index] = nums[i];
                        break;
                    }
                    if (index == right) dp[index] = nums[i];
                }
            }
        }
        return len;
    }

    public static void main(String[] args) {
        new LengthOfLIS().lengthOfLIS(new int[]{0, 1, 0, 3, 2, 3});
        new LengthOfLIS().lengthOfLIS(new int[]{3, 5, 6, 2, 5, 4, 19, 5, 6, 7, 12});
        new LengthOfLIS().lengthOfLIS(new int[]{4, 10, 4, 3, 8, 9});
    }
}
```

### 3. [ 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 

示例 1：

> 输入：text1 = "abcde", text2 = "ace" 
> 输出：3  
> 解释：最长公共子序列是 "ace" ，它的长度为 3 。

```java
package com.yubin.medium.part3;

/**
 * @author MIIAMOR
 * @date 2021/6/19
 */
public class LongestCommonSubsequence {
    /**
     * dp[i][j]表示的是chars1[1...i]和chars2[1...j]中最长子序列的长度
     * 当遇到相同字母的时候dp[i][j] = dp[i - 1][j - 1] + 1;
     * 遇到不同的字符时：就是dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
     */
    public int longestCommonSubsequence(String text1, String text2) {
        char[] chars1, chars2;
        int len1 = text1.length(), len2 = text2.length();
        chars1 = text1.toCharArray();
        chars2 = text2.toCharArray();
        int[][] dp = new int[len2 + 1][len1 + 1];
        for (int i = 1; i <= len2; i++) {
            for (int j = 1; j <= len1; j++) {
                if (chars1[j - 1] == chars2[i - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[len2][len1];
    }

    /**
     * 空间优化
     */
    public int longestCommonSubsequence1(String text1, String text2) {
        char[] chars1, chars2;
        int len1 = text1.length(), len2 = text2.length();
        chars1 = text1.toCharArray();
        chars2 = text2.toCharArray();
        int[] dp = new int[len1 + 1];
        int curr, pre;
        for (int i = 1; i <= len2; i++) {
            curr = 0;
            pre = 0;
            for (int j = 1; j <= len1; j++) {
                if (chars1[j - 1] == chars2[i - 1]) {
                    curr = dp[j - 1] + 1;
                } else {
                    curr = Math.max(curr, dp[j]);
                }
                dp[j - 1] = pre;
                pre = curr;
                if (j == len1) dp[len1] = curr;
            }
        }
        return dp[len1];
    }
}
```

### 4. [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

> 输入：nums = [2,3,2]
> 输出：3
> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

```java
package com.yubin.medium.part3;

/**
 * @author MIIAMOR
 * @date 2021/6/19
 */
public class Rob {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 1) return nums[0];
        else if (len == 2) return Math.max(nums[0], nums[1]);
        else if (len == 3) {
            int max = Math.max(nums[0], nums[1]);
            return Math.max(max, nums[2]);
        }
        // 正向偷
        int[] stealPos = new int[len];
        int[] leavePos = new int[len];
        stealPos[1] = nums[1];
        // 反向偷
        int[] stealNeg = new int[len];
        int[] leaveNeg = new int[len];
        stealNeg[1] = nums[len - 2];
        for (int i = 2; i < len; i++) {
            leavePos[i] = Math.max(stealPos[i - 1], leavePos[i - 1]);
            stealPos[i] = Math.max(leavePos[i - 1], stealPos[i - 2]) + nums[i];

            leaveNeg[i] = Math.max(stealNeg[i - 1], leaveNeg[i - 1]);
            stealNeg[i] = Math.max(leaveNeg[i - 1], stealNeg[i - 2]) + nums[len - i - 1];
        }
        int pos = Math.max(stealPos[len - 1], leavePos[len - 1]);
        int neg = Math.max(stealNeg[len - 1], leaveNeg[len - 1]);
        return Math.max(pos, neg);
    }

    public static void main(String[] args) {
        new Rob().rob(new int[]{1, 2, 1, 1, 2});
    }
}
```

### 5. [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

[ dfs记忆化搜搜](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/shou-hua-tu-jie-fen-ge-deng-he-zi-ji-dfshui-su-si-/)

示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

```java
package com.yubin.medium.part3;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * @author MIIAMOR
 * @date 2021/6/19
 */
public class CanPartition {
    /**
     * 0-1背包问题 halfSum为背包值的最大容量 nums.length为物品数量 nums[i]为物品的值
     */
    public boolean canPartition(int[] nums) {
        int sum = getSum(nums);
        if (sum % 2 != 0) return false;
        int len = nums.length;
        int halfSum = sum / 2;
        int[][] dp = new int[len + 1][halfSum + 1];
        // dp[i][j]表示的是取前i个数，最大只能达到j的最大值
        for (int i = 1; i < len + 1; i++) {
            int num = nums[i - 1];
            for (int j = 1; j < halfSum + 1; j++) {
                if (j >= num) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - num] + num);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
                if (j == halfSum && dp[i][j] == halfSum) return true;
            }
        }
        return false;
    }

    /**
     * 空间优化
     */
    public boolean canPartition1(int[] nums) {
        int sum = getSum(nums);
        if (sum % 2 != 0) return false;
        int len = nums.length;
        int halfSum = sum / 2;
        int[] dp = new int[halfSum + 1];
        for (int i = 1; i < len + 1; i++) {
            int num = nums[i - 1];
            for (int j = halfSum; j >= num; j--) {
                dp[j] = Math.max(dp[j], dp[j - num] + num);
            }
            if (dp[halfSum] == halfSum) return true;
        }
        return false;
    }

    /**
     * dfs搜索 dfs数记忆化搜索（记忆对象是index和currSum）
     */
    private Map<String, Boolean> ms = null;

    public boolean canPartition2(int[] nums) {
        int sum = getSum(nums);
        if (sum % 2 != 0) return false;
        int halfSum = sum / 2;
        ms = new HashMap<>();
        return dfs(nums, halfSum, 0, 0);
    }

    private boolean dfs(int[] nums, int halfSum, int sum, int index) {
        if (index >= nums.length) return false;

        if (sum == halfSum) return true;

        if (sum > halfSum) return false;

        String key = sum + "&" + index;
        if (ms.containsKey(key)) return ms.get(key);

        boolean res = dfs(nums, halfSum, sum, index + 1) || dfs(nums, halfSum, sum + nums[index], index + 1);

        ms.put(key, res);

        return res;
    }

    private int getSum(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res += num;
        }
        return res;
    }

    public static void main(String[] args) {
        CanPartition c = new CanPartition();
        System.out.println(c.canPartition1(new int[]{1, 2, 5}));
        System.out.println(c.canPartition(new int[]{1, 5, 10, 6}));
        System.out.println(c.canPartition1(new int[]{1, 5, 10, 6}));
        System.out.println(c.canPartition2(new int[]{1, 5, 10, 6}));
        System.out.println(c.canPartition2(new int[]{1, 5, 11, 5}));
        System.out.println(c.canPartition2(new int[]{
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 99, 97
        }));
    }
}
```



## part4

### 1. [一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)（非自己解答）

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

 

示例 1：

> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
> 输出：4
> 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
> 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

```java
package com.yubin.medium.part4;

/**
 * @author MIIAMOR
 * @date 2021/6/19
 */
public class FindMaxForm {
    /**
     * 向0-1背包问题转化
     * 相当于有两个背包,分别是大小为m的0背包和大小为n的1背包
     * 在装入物品的时候，需要同时向两个背包装入指定大小的0和1
     */
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        // 对于dp[i][j]，用于记录容量为i的0背包和容量为1的1背吧可以装入的最大物品数
        int[][] dp = new int[m + 1][n + 1];
        // 用于记录使用了多少个字符串
        // 左上到右下 求取最优结构
        for (int i = 0; i < len; i++) {
            // 从物品栏中取出物品，计算0的数量和1的数量
            int[] count = convert(strs[i]);
            int v = count[0], w = count[1];
            for (int j = m; j >= v; j--) {
                for (int k = n; k >= w; k--) {
                    // 递推方程中使用到的数据是装入上一个物品时的背包状况
                    // 而这些数据在dp数组中的左上方
                    // 因此遍历的顺序应该是从右下到左上
                    dp[j][k] = Math.max(dp[j - v][k - w] + 1, dp[j][k]);
                }
            }
        }
        return dp[m][n];
    }

    /**
     * 双背包问题，基于三维dp数组求解
     */
    public int findMaxForm1(String[] strs, int m, int n) {
        int len = strs.length;
        // 这里的dp[i][j][k]表示的是把前i个数据存入大小分别为j的0背包和大小为k的1背包中所能存入的最大物品数
        int[][][] dp = new int[len + 1][m + 1][n + 1];
        for (int i = 1; i <= len; i++) {
            int[] count = convert(strs[i - 1]);
            int v = count[0], w = count[1];
            // 下面进行遍历的时候需要从0遍历
            // 字符中1和0的数量都可能为1
            // 从1开始遍历的话，就可能漏掉字符串中0或者1的数量为0的情况
            // 传统的0-1背包问题中，weight和value的值都是大于0的，所以从1遍历没啥问题
            // 也不可以从v和w开始遍历
            // 对于物品数为i的情况而言，需要把物品数为i-1在的状态复制到i状态
            // 上面得二维数组压缩情况就不需要考虑这点
            // 从右下遍历到左上，为被遍历的数据就是上一个状态的数据
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    if (j >= v && k >= w)
                        dp[i][j][k] = Math.max(dp[i - 1][j - v][k - w] + 1, dp[i - 1][j][k]);
                    else
                        dp[i][j][k] = dp[i - 1][j][k];
                }
            }
        }
        return dp[len][m][n];
    }

    private int[] convert(String str) {
        int count0 = 0, count1 = 0;
        for (char c : str.toCharArray()) {
            if (c == '0') count0++;
            else count1++;
        }
        return new int[]{count0, count1};
    }

    public static void main(String[] args) {
        new FindMaxForm().findMaxForm(new String[]{"10", "0001", "111001", "1", "0"}, 5, 3);
        new FindMaxForm().findMaxForm1(new String[]{"10", "1", "0"}, 1, 1);
        new FindMaxForm().findMaxForm(new String[]{"10", "1", "0"}, 1, 1);
    }
}
```

### 2. [整数拆分](https://leetcode-cn.com/problems/integer-break/)

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1。

```java
package com.yubin.medium.part4;

/**
 * @author MIIAMOR
 * @date 2021/6/19
 */
public class IntegerBreak {
    /**
     * dp[i] 表示加起来最多为i的数所能达到的最大乘积
     * 状态转移方程dp[i]=max(dp[j]*(i-j),dp[j-1]*(i-j+1)......)
     * 注意特殊情况
     */
    public int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int max = i;
            // 计算的时候算一般就行，例如dp[7]*3 > dp[3]*7恒成立
            for (int j = i - 1; j >= i / 2; j--) {
                max = Math.max(dp[j] * (i - j), max);
            }
            dp[i] = max;
        }
        return dp[n];
    }

    public static void main(String[] args) {
        IntegerBreak ib = new IntegerBreak();
        System.out.println(ib.integerBreak(10));
    }
}
```

### 3. [两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

 

示例：

> 输入: "sea", "eat"
> 输出: 2
> 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

```java
package com.yubin.medium.part4;

/**
 * @author MIIAMOR
 * @date 2021/6/20
 */
public class MinDistance {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        char[] chars1 = word1.toCharArray(), chars2 = word2.toCharArray();
        // 这里的dp[i][j]表示的是word1前i个字符变换到word2前j个字符最少的步骤数
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i == 0) dp[i][j] = j;
                else if (j == 0) dp[i][j] = i;
                else {
                    // 递推方程分情况考虑
                    if (chars1[i - 1] == chars2[j - 1]) {
                        // 1. i和j索引处的单词相等
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        // 2. i和j处索引的单词不相等
                        // 此时再细分情况:
                        // 直接添加字符即可(1步操作) -->包含：删除后再添加字符(2步操作)情况 删除到达dp[i-1][j]状态
                        // 异或 直接删除i处的字符
                        dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + 1;
                    }
                }
            }
        }
        return dp[m][n];
    }

    /**
     * 空间优化
     */
    public int minDistance1(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        char[] chars1 = word1.toCharArray(), chars2 = word2.toCharArray();
        int[] preDp = new int[n + 1];
        int[] currDp = new int[n + 1];
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                preDp[j] = currDp[j];
                if (i == 0) currDp[j] = j;
                else if (j == 0) currDp[0] = i;
                else {
                    if (chars1[i - 1] == chars2[j - 1]) currDp[j] = preDp[j - 1];
                    else
                        currDp[j] = Math.min(preDp[j], currDp[j - 1]) + 1;
                }
            }
        }
        return currDp[n];
    }

    public static void main(String[] args) {
        new MinDistance().minDistance1("sea", "eat");
        new MinDistance().minDistance("sea", "eat");
    }
}
```

### 4. [零钱兑换](https://leetcode-cn.com/problems/coin-change/)(非自己解答)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

 

示例 1：

> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1

```java
package com.yubin.medium.part4;

/**
 * @author MIIAMOR
 * @date 2021/6/21
 */
public class CoinChange {
    public int coinChange(int[] coins, int amount) {
        // dp[i]表示的是coins中的数加起来刚好是i所需要的最小coin数量
        // 如果无法使得coin的值加起来为i，那么把dp[i]设置为一个较大的数，这里默认为amount+2
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            // 这里初始默认前置状态为amount + 2
            int pre = amount + 2;
            for (int coin : coins) {
                // 要保证最后的结果加起来刚好是amount
                // 递推方程，如果选择了coin作为被加数，那么所需的coin数量就是dp[i-coin]+1
                // 如果无法使数加起来等于i-coin，那么dp[i - coin]的值为amount+2
                // 这里的前置状态也是设置的一个大数
                // 只有当i-coin可以被组合时，i处的dp值才会有效
                if (i - coin >= 0) pre = Math.min(pre, dp[i - coin]);
            }
            dp[i] = pre + 1;
        }
        return (dp[amount] >= amount + 2) ? -1 : dp[amount];
    }

    public static void main(String[] args) {
        CoinChange cc = new CoinChange();
        System.out.println(cc.coinChange(new int[]{1, 2, 5}, 11));
        System.out.println(cc.coinChange(new int[]{2}, 3));
    }
}
```

### 5. [只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/)(dfs自己写的，dp和数学解法参考大佬的)

最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
Paste (粘贴) : 你可以粘贴你上一次复制的字符。
给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。

示例 1:

> 输入: 3
> 输出: 3
> 解释:
> 最初, 我们只有一个字符 'A'。
> 第 1 步, 我们使用 Copy All 操作。
> 第 2 步, 我们使用 Paste 操作来获得 'AA'。
> 第 3 步, 我们使用 Paste 操作来获得 'AAA'。

[质数分解解法](https://leetcode-cn.com/problems/2-keys-keyboard/solution/zhi-you-liang-ge-jian-de-jian-pan-by-leetcode/)

```java
package com.yubin.medium.part4;

/**
 * @author MIIAMOR
 * @date 2021/6/21
 */
public class MinSteps {
    /**
     * 质数分解方式，详情见官方解答
     */
    public int minSteps(int n) {
        if (n == 1) return 0;
        int res = 0, d = 2;
        while (n > 1) {
            while ((n % d) == 0) {
                res += d;
                n /= d;
            }
            d++;
        }
        return res;
    }

    private int res;

    public int minSteps1(int n) {
        if (n == 1) return 0;
        res = Integer.MAX_VALUE;
        dfs(1, 1, 1, n);// 默认第一步是copy操作
        return res;
    }

    /**
     * @param copyNum 当前剪切板上的A的数量
     * @param sum     当前文本中A的数量
     * @param n       最终需要达到的A的数量
     */
    private void dfs(int copyNum, int sum, int count, int n) {
        if (sum > n) return;
        if (sum == n) res = Math.min(res, count);

        // 每次都有两种选择方式
        // 1. 直接粘贴当前剪切板 步数+1
        dfs(copyNum, sum + copyNum, count + 1, n);
        // 2. 复制当前文本再粘贴
        dfs(sum, sum * 2, count + 2, n);
    }

    public int minSteps2(int n) {
        if (n == 1) return 0;
        int h = (int) Math.sqrt(n);
        // 表示达到i个A所需的最小次数
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            dp[i] = i;// 默认的初始值为copy1次，paste一个i-1次
            // 这里的边界条件使用h而非n/2，可以减少空循环的次数
            for (int j = 2; j <= h; j++) {
                if (i % j == 0) {
                    // 在此条件下，说明i个A可以有j个A变换得到
                    // 这个变换的次数就是dp[i/j]
                    // dp[j]->dp[i]等价于dp[j/j]->dp[i/j]等价于dp[1]->dp[i/j]
                    // 对于每个dp[i]，最后进行的都是paste操作而不是copy，dp[1]相当于剪切板为空，也没有进行copy操作
                    // 因此状态转移方程是可行的
                    dp[i] = dp[j] + dp[i / j];
                    break;
                }
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {
        MinSteps ms = new MinSteps();
        System.out.println(ms.minSteps(4));
        System.out.println(ms.minSteps1(4));
        System.out.println(ms.minSteps2(4));
    }
}
```

## part5

### *1. [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

> 输入: [1,2,3,0,2]
> 输出: 3 
> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]



### 2. [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

```java
package com.yubin.medium.part5;

import java.util.*;

/**
 * @author MIIAMOR
 * @date 2021/7/14 9:14
 */
public class MinimumTotal {
    public int minimumTotal(List<List<Integer>> triangle) {
        return minimumTotal1(triangle);
//        return minimumTotal2(triangle);
    }

    private int minimumTotal1(List<List<Integer>> triangle) {
        int n = triangle.size();
        if (n == 1) return triangle.get(0).get(0);
        int[][] dp = new int[n][n];
        dp[0][0] = triangle.get(0).get(0);
        int res = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            List<Integer> list = triangle.get(i);
            for (int j = 0; j < list.size(); j++) {
                int num = list.get(j);
                if (j == 0) dp[i][j] = dp[i - 1][j] + num;
                else if (i == j) dp[i][j] = dp[i - 1][j - 1] + num;
                else dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + num;
            }
        }
        for (int i : dp[n - 1]) {
            res = Math.min(res, i);
        }
        return res;
    }

    private int res = Integer.MAX_VALUE;
    private int len;
    private int sum;

    private int minimumTotal2(List<List<Integer>> triangle) {
        len = triangle.size();
        sum = triangle.get(0).get(0);
        dfs(triangle, 0, 0);
        return res;
    }

    private void dfs(List<List<Integer>> triangle, int length, int index) {
        if (length == len - 1) {
            res = Math.min(res, sum);
            return;
        }
        List<Integer> list = triangle.get(length + 1);
        sum += list.get(index);
        dfs(triangle, length + 1, index);
        sum -= triangle.get(length + 1).get(index);
        sum += triangle.get(length + 1).get(index + 1);
        dfs(triangle, length + 1, index + 1);
        sum -= triangle.get(length + 1).get(index + 1);
    }
}
```

# hard

## Part1

### 1. [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses)（非自己解题）

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

示例 1：

> 输入：s = "(()"
> 输出：2
> 解释：最长有效括号子串是 "()"

示例 2：

> 输入：s = ")()())"
> 输出：4
> 解释：最长有效括号子串是 "()()"

示例 3：

> 输入：s = ""
> 输出：0


提示：

> 0 <= s.length <= 3 * 104
> s[i] 为 '(' 或 ')'

```java
package com.yubin.hard.part1;

import java.util.LinkedList;

public class LongestValidParentheses {
    /**
     * 栈匹配法,遇到左括号，入栈，遇到右括号，检测匹配并弹栈
     * 半天才想明白，我好笨呀
     * https://leetcode-cn.com/problems/longest-valid-parentheses/solution/32-zui-chang-you-xiao-gua-hao-fu-zhu-zha-1cqq/
     *
     * @param s
     * @return 连续的合法字符串长度
     */
    public int longestValidParentheses1(String s) {
        LinkedList<Integer> stack = new LinkedList<>();
        int res = 0;

        for (int i = 0; i < s.length(); i++) {
            if (stack.isEmpty() || s.charAt(i) == '(' || s.charAt(stack.getLast()) == ')') {
                stack.addLast(i);
            } else {
                stack.removeLast();
                res = Math.max(res, stack.isEmpty() ? i + 1 : i - stack.getLast());
            }
        }
        return res;
    }

    /**
     * 解法思路来源：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042/
     *
     * @param s
     * @return
     */
    public int longestValidParentheses2(String s) {
        int res = 0;
        int[] dp = new int[s.length()];
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '(') dp[i] = 0;
            else if (chars[i] == ')') {
                if ((i - 1) >= 0 && (chars[i - 1] == '(')) {
                    dp[i] = 2;
                    if (i - 2 >= 0) dp[i] = dp[i - 2] + 2;
                } else if (i - 1 >= 0 && chars[i - 1] == ')') {
                    //判断((...))形
                    if ((i - dp[i - 1] - 1 >= 0) && (chars[i - dp[i - 1] - 1] == '(')) {
                        dp[i] = dp[i - 1] + 2;
                        if (i - dp[i - 1] - 2 >= 0)
                            dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;
                    }
                }
                res = Math.max(dp[i], res);
            }
        }
        return res;
    }

    public static void main(String[] args) {
        LongestValidParentheses lvp = new LongestValidParentheses();
        System.out.println(lvp.longestValidParentheses1("(()())"));
        System.out.println(lvp.longestValidParentheses1("(()"));
        System.out.println(lvp.longestValidParentheses1("()((()"));
        System.out.println(lvp.longestValidParentheses1("()(())"));
        System.out.println(lvp.longestValidParentheses1(")()())"));
        System.out.println(lvp.longestValidParentheses1(")()())()()("));

        System.out.println(lvp.longestValidParentheses2("(()())"));
        System.out.println(lvp.longestValidParentheses2("(()"));
        System.out.println(lvp.longestValidParentheses2("()((()"));
        System.out.println(lvp.longestValidParentheses2("()(())"));
        System.out.println(lvp.longestValidParentheses2(")()())"));
        System.out.println(lvp.longestValidParentheses2(")()())()()("));
    }
}
```

### 2. [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符


示例 1：

> 输入：word1 = "horse", word2 = "ros"
> 输出：3
> 解释：
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (删除 'r')
> rose -> ros (删除 'e')

```java
package com.yubin.hard.part1;

/**
 * @author MIIAMOR
 * @date 2021/6/21
 */
public class MinDistance {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        char[] chars1 = word1.toCharArray(), chars2 = word2.toCharArray();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                // 对于字符串长度为0的情况，只能选择删除后者添加的情况
                if (i == 0) dp[0][j] = j;
                else if (j == 0) dp[i][j] = i;
                else {
                    // 对于遇到相等的情况 步数不会增加
                    if (chars1[i - 1] == chars2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
                    else {
                        // 多种情况来考虑
                        // 直接改变这个字符为目标字符
                        // 异或 删除原字符串末尾字符
                        // 异或 在原字符串上添加指定字符
                        // 这三种情况的初始状态不一样 注意状态转移过程的初始状态判断
                        dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + 1;
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + 1);
                    }
                }
            }
        }
        return dp[m][n];
    }

    public int minDistance1(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        char[] chars1 = word1.toCharArray(), chars2 = word2.toCharArray();
        int[] currDp = new int[n + 1], preDp = new int[n + 1];
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                preDp[j] = currDp[j];
                // 对于字符串长度为0的情况，只能选择删除后者添加的情况
                if (i == 0) currDp[j] = j;
                else if (j == 0) currDp[j] = i;
                else {
                    // 对于遇到相等的情况 步数不会增加
                    if (chars1[i - 1] == chars2[j - 1]) currDp[j] = preDp[j - 1];
                    else {
                        // 多种情况来考虑
                        // 直接改变这个字符为目标字符
                        // 异或 删除原字符串末尾字符
                        // 异或 在原字符串上添加指定字符
                        // 这三种情况的初始状态不一样 注意状态转移过程的初始状态判断
                        currDp[j] = Math.min(preDp[j], currDp[j - 1]) + 1;
                        currDp[j] = Math.min(currDp[j], preDp[j - 1] + 1);
                    }
                }
            }
        }
        return currDp[n];
    }
}
```

### 3. [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)（dp非自己解答，回溯是自己写的）

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。


示例 1：

> 输入：s = "aa" p = "a"
> 输出：false
> 解释："a" 无法匹配 "aa" 整个字符串。

```java
package com.yubin.hard.part1;

import java.util.Arrays;

/**
 * @author MIIAMOR
 * @date 2021/6/22
 */
public class IsMatch {
    private boolean match(char[] c1, char[] c2, int i, int j) {
        if (i == 0) return false;
        if (c2[j - 1] == '.') return true;
        return c1[i - 1] == c2[j - 1];
    }

    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        char[] charS = s.toCharArray(), charP = p.toCharArray();
        // dp[i][j]表示的是s的前i个字符可以有正则表达式的前j个字符匹配得到
        boolean[][] dp = new boolean[m + 1][n + 1];// 这里初始化默认为false
        // 设置为true 默认0串可以匹配0串
        dp[0][0] = true;
        /*
         * '*'字符无法单独出现，必定前面会出现一个字符
         * 分情况讨论：
         * 1. 在两个串中都遇到了普通字符
         *      dp[i][j] = dp[i - 1][j - 1]  s[i] == p[j]时
         *      dp[i][j] = false s[i] != p[j]时
         * 2. 当在p串中遇到了 . 表示可以匹配任意字符
         *      dp[i][j] = dp[i - 1][j - 1] 成立
         * 3. 当遇到了 * 时，这表明 * 前面的串一定普通字符或者 .
         *    这表示我们可以对p[j - 1]处的字符匹配数次
         *      这里比如放弃一次 * 匹配 则 dp[i][j] = dp[i][j - 2]
         *      如果选择匹配：
         *          1次： dp[i][j] = dp[i - 1][j - 2]
         *          2次： dp[i][j] = dp[i - 2][j - 2]
         *          3次： dp[i][j] = dp[i - 3][j - 2]...
         *      但是当我们使用 2次 匹配且二次匹配也有效的话 说明 1次 匹配也是有效的
         *      那么dp[i - 1][j]为真
         *      同理当我们使用 3次 匹配且二次匹配也有效的话 说明 2次 匹配也是有效的
         *      那么dp[i - 2][j]为真
         *
         *      那么dp[i][j] = dp[i - 1][j]
         *
         */
        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 遇到了 * ，z则需要考虑的是前面的字符匹配情况
                if (charP[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 2];//默认零匹配情况
                    if (match(charS, charP, i, j - 1))
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                } else {
                    if (match(charS, charP, i, j))
                        dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[m][n];
    }

    /**
     * 空间优化
     */
    public boolean isMatch1(String s, String p) {
        int m = s.length(), n = p.length();
        char[] charS = s.toCharArray(), charP = p.toCharArray();
        // dp[i][j]表示的是s的前i个字符可以有正则表达式的前j个字符匹配得到
        boolean[] preDp = new boolean[n + 1];// 这里初始化默认为false
        boolean[] currDp = new boolean[n + 1];// 这里初始化默认为false
        // 设置为true 默认0串可以匹配0串
        currDp[0] = true;
        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 遇到了 * ，z则需要考虑的是前面的字符匹配情况
                if (charP[j - 1] == '*') {
                    currDp[j] = currDp[j - 2];//默认零匹配情况
                    if (match(charS, charP, i, j - 1))
                        currDp[j] = currDp[j] || preDp[j];
                } else {
                    if (match(charS, charP, i, j))
                        currDp[j] = preDp[j - 1];
                }
            }
            preDp = currDp;
            currDp = new boolean[n + 1];
        }
        return preDp[n];
    }

    /**
     * 使用回溯算法
     */
    private char[] cS, cP = null;
    private boolean[] isStar = null;
    private int m, n;

    public boolean isMatch2(String s, String p) {
        m = s.length();
        n = p.length();
        cS = s.toCharArray();
        cP = new char[n];
        isStar = new boolean[n];
        int index = 0;
        // 为正则表达式中带*的字符打上标记
        for (int i = 0; i < n; i++) {
            char c = p.charAt(i);
            if (c == '*') isStar[index - 1] = true;
            else cP[index++] = c;
        }
        n = index;
        return dfs(0, 0);
    }

    private boolean dfs(int i, int j) {
        if (i == m) {
            if (j == n) return true;
            else if (j < n && isStar[j]) {
                return dfs(i, j + 1);
            }
            return false;
        }
        if (j >= n) return false;

        char c1 = cS[i], c2 = cP[j];

        // 带 * 的字符，匹配时可以选择匹配或者跳过
        if (isStar[j]) {
            boolean flag = false;
            if (c2 == '.' || c1 == c2)
                flag = dfs(i + 1, j);
            if (flag) return true;
            return dfs(i, j + 1);
        } else {
            if (c2 == '.' || c1 == c2)
                return dfs(i + 1, j + 1);
        }

        return false;
    }

    public static void main(String[] args) {
        System.out.println(new IsMatch().isMatch2("aa", "a"));
        System.out.println(new IsMatch().isMatch2("a", "ab*c*"));
        System.out.println(new IsMatch().isMatch2("aaa", "ab*a*c*a"));
        System.out.println(new IsMatch().isMatch2("aab", "c*a*bd"));
        System.out.println(new IsMatch().isMatch2("ab", "a*b"));
    }
}
```

### 4. [买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)*

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1：

> 输入：k = 2, prices = [2,4,1]
> 输出：2
> 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

示例 2：

> 输入：k = 2, prices = [3,2,6,5,0,3]
> 输出：7
> 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
>      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。







## Part2

