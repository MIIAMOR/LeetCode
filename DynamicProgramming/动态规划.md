# 动态规划

## Part1

### 1 [Fibonacci数列](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

```java
 F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。
```

> - 示例 1：
>
>
> 输入：2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
>
> - 示例 2：
>
> 输入：3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
>
> - 示例 3：
>
> 输入：4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3

> 提示：0 <= n <= 30

```java
package com.yubin.part1;

/**
 * 动态规划题目：斐波那契数列
 */
public class Fibonacci {
    /**
     * 递归算法，重复调用自身。可能栈内存溢出
     *
     * @param n
     * @return
     */
    public int fib1(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fib1(n - 1) + fib1(n - 2);
        }
    }

    /**
     * 动态规划算法，可以优化，不必开辟数组
     *
     * @param n
     * @return
     */
    public int fib2(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int[] dp = new int[n + 1];
            dp[0] = 0;
            dp[1] = 1;
            for (int i = 2; i < dp.length; i++) {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];
        }
    }

    /**
     * 动态规划改良，减少内存消耗
     * @param n
     * @return
     */
    public int fib3(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int sum = 0, pre = 0, curr = 1;
            for (int i = 1; i < n; i++) {
                sum = curr + pre;
                pre = curr;
                curr = sum;
            }
            return sum;
        }
    }

    public static void main(String[] args) {
        Fibonacci f = new Fibonacci();
        System.out.println(f.fib2(5));
        System.out.println(f.fib1(5));
        System.out.println(f.fib3(5));
    }
}
```

### 2.[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

> - 示例 1：
>
>输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> 
>- 示例 2：
> 
>输入：s = "cbbd"
> 输出："bb"
> 
>- 示例 3：
> 
>输入：s = "a"
> 输出："a"
> 
>- 示例 4：
> 
>输入：s = "ac"
> 输出："a"

>
> 提示：
>
> 1 <= s.length <= 1000
> s 仅由数字和英文字母（大写和/或小写）组成

**`这里的方法2：中心向外扩展法，在LeetCode上无法编译通过，但是idea上可以运行。`**

```java
package com.yubin.part1;

public class LongestPalindrome {
    /**
     * <p>动态规划算法</p>
     * <p>1.建立一个dp数组记录dp[j]记录的是以j下标为结尾的最长回文串的开始位置</p>
     * <p>2.如何递推求出每个dp[j]的值</p>
     * <p> 情况1：dp[j+1] = dp[dp[j]-1],这种情况直接使得dp[j+1] = dp[j]-1</p>
     * <p> 情况2：如果没能向两侧扩展，那么需要重新求出最长回文子串<br/>
     * (解决方法：设置两个下标left = dp[j],right = j+1<br>
     * 如果str[lef]==str[right]让left++的同时让right--<br>
     * 如果遇到str[lef]！=str[right]，让right回归初始值，left不变<br>
     * 当left==right的时候，就可以记录dp数组了
     * </p>
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome1(String s) {
        if (s == null) {
            return null;
        }
        int[] dp = new int[s.length()];//建立记录数组
        char[] chars = s.toCharArray();//拆分字符串为一个字符数组
        dp[0] = 0;//初始化dp[0]为0
        //动态求得每一个数组的值
        for (int i = 1; i < chars.length; i++) {
            //边界判断 索引没有变为负数
            if (dp[i - 1] - 1 >= 0 && chars[i] == chars[dp[i - 1] - 1]) {
                //情况1 当前字符串等于上一个字符串的上
                dp[i] = dp[i - 1] - 1;
            } else {
                int left = dp[i - 1], right = i, index = dp[i - 1];
                while (right - left >= 1) {
                    if (chars[left] == chars[right]) {
                        left++;
                        right--;
                    } else {
                        right = i;
                        left++;
                        index = left;
                        if (index == i) break;
                    }
                }
                dp[i] = index;
            }
        }
        //遍历获取最大的回文串
        int begin = 0, end = 0, len = 0;
        for (int i = 0; i < dp.length; i++) {
            if (i - dp[i] > len) {
                begin = dp[i];
                end = i;
                len = i - dp[i];
            }
        }
        return s.substring(begin, end + 1);
    }

    /**
     * 中间向两侧扩展法，思路简单易懂
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome2(String s) {
        if (s == null) {
            return null;
        }
        StringBuilder res = new StringBuilder();
        StringBuilder str1 = new StringBuilder();
        StringBuilder str2 = new StringBuilder();
        for (int i = 0; i < s.length() - 1; i++) {
            str1.delete(0, str1.length()).append(extend(s, i, i));//奇数扩展
            str2.delete(0, str2.length()).append(extend(s, i, i + 1));//偶数扩展
            if (res.length() < str1.length() || res.length() < str2.length()) {
                res.delete(0, res.length()).append(str1.length() > str2.length() ? str1 : str2);
            }
        }
        return res.toString();
    }

    /**
     * 从中间向两侧扩展，注意<br>
     * 回文串是奇数还是偶数<br>
     *
     * @param s     待求的字符串
     * @param left  以该索引向两边扩展
     * @param right 以该索引向两边扩展
     * @return 中间向两侧扩展的最大回文子串
     */
    private String extend(String s, int left, int right) {
        while (left >= 0 && right < s.length()) {
            if (s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
            } else {
                break;
            }
        }
        return s.substring(left + 1, right);
    }

    public static void main(String[] args) {
        LongestPalindrome lp = new LongestPalindrome();
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1("cbbdd"));
        System.out.println(lp.longestPalindrome1("cb"));
        System.out.println(lp.longestPalindrome1("ababababa"));
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1(null));
        System.out.println(lp.longestPalindrome2("asddsa"));
        System.out.println(lp.longestPalindrome2("cbbdd"));
        System.out.println(lp.longestPalindrome2("cb"));
        System.out.println(lp.longestPalindrome2("ababababa"));
        System.out.println(lp.longestPalindrome2("babad"));
        System.out.println(lp.longestPalindrome2("bb"));
        System.out.println(lp.longestPalindrome2("sss"));
        System.out.println(lp.longestPalindrome2(""));
        System.out.println(lp.longestPalindrome2(null));
    }
}
```

### 3.[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)（进阶：分治求解）

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

> - 示例 1：
>
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>
> - 示例 2：
>
> 输入：nums = [1]
> 输出：1
>
> - 示例 3：
>
> 输入：nums = [0]
> 输出：0
>
> - 示例 4：
>
> 输入：nums = [-1]
> 输出：-1
>
> - 示例 5：
>
> 输入：nums = [-100000]
> 输出：-100000
>
> - 
>   提示：1 <= nums.length <= 3 * 104      -105 <= nums[i] <= 105
>
>
> - 
>   进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
>

```java
package com.yubin.part1;

public class MaxSubArray {
    /**
     * 动态规划算法<br>
     * 利用一个一维数组dp[j]来记录包含nums[j]的最大子序和<br/>
     * 其中递归规律是：<br>
     * 1.对于dp[j],如果dp[j-1]>0,那么dp[j]=dp[j-1]+nums[j]<br>
     * 2.对于dp[j],如果dp[j-1]<0，那么dp[j]=nums[j]
     *
     * @param nums 一个数组
     * @return 最大子序和（即最大连续子数组和）
     */
    public int maxSubArray1(int[] nums) {
        int[] dp = new int[nums.length];
        int res = nums[0];
        dp[0] = nums[0];
        //按照递推规律求得dp数组的值
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    public int maxSubArray2(int[] nums) {
        int curr = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            curr = Math.max(curr + nums[i], nums[i]);
            res = Math.max(res, curr);
        }
        return res;
    }

    public static void main(String[] args) {
        MaxSubArray msa = new MaxSubArray();
        int[] nums = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(msa.maxSubArray1(nums));
        System.out.println(msa.maxSubArray2(nums));
    }
}

```

### 4.[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
>
> 1 阶 + 1 阶
>
> 2 阶

示例 2：

> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
>
> 1 阶 + 1 阶 + 1 阶
>
> 1 阶 + 2 阶
>
> 2 阶 + 1 阶

```java
package com.yubin.part1;

public class ClimbStairs {
    /**
     * 由于爬楼梯的方式要么两格一步，要么一格一步<br>
     * 所以爬到最后一阶楼梯的时候要么跨出两步，要么跨出一步<br>
     * 所以F(n)=F(n-1)+F(n-2)
     *
     * @param n 楼梯数
     * @return 爬楼梯的方式数
     */
    public int climbStairs(int n) {
        int pre = 1, curr = 2, res = 1;
        for (int i = 1; i < n; i++) {
            res = curr;
            curr = pre + curr;
            pre = res;
        }
        return res;
    }

    public static void main(String[] args) {
        ClimbStairs cs = new ClimbStairs();
        System.out.println(cs.climbStairs(4));
    }
}
```

### 5.[买股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。



示例 1：

> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：

> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

> 1 <= prices.length <= 105
> 0 <= prices[i] <= 104

```java
package com.yubin.part1;

public class MaxProfit {
    /**
     * 分析：<br>
     * <p>
     * 解法1：暴力遍历数组，记录最大的利益 timeoutError
     * </p>
     *
     * @param prices 股票的价格
     * @return 最大收益
     */
    public int maxProfit1(int[] prices) {
        int res = 0;
        for (int i = prices.length - 1; i >= 0; i--) {
            for (int j = i; j >= 0; j--) {
                if (prices[j] < prices[i] && res < prices[i] - prices[j]) res = prices[i] - prices[j];
            }
        }
        return res;
    }

    /**
     * 分析：<br>
     * <p>
     * 解法2：图像分析法+动态规划算法<br>
     * 把每个值绘制在折线图中，就可以非常直观看到每个数值的大小关系了<br>
     * 整个过程就是找出极差，右边的数必须大于左边的数<br>
     * 用数组dp表示动态规划的状态数组，则dp[i]表示到第i天时的最大利润。<br>
     * 用变量cur_min_buy维护截止到前一天股票的最低买入价格<br>
     * 则不难看出状态转移方程为dp[i]=max(dp[i-1], prices[i]-cur_min_buy).<br>
     *     在动态记录这个result即可
     * </p>
     *
     * @param prices 股票的价格
     * @return 最大收益
     */
    public int maxProfit2(int[] prices) {
        if (prices.length < 2) return 0;
        // res用来记录当前已经知道的最大利益，currMin用来记录已知的最小股票市价
        int res = 0, currMin = prices[0];
        for (int price : prices) {
            currMin = Math.min(currMin, price);
            res = Math.max(res, price - currMin);
        }
        return res;
    }

    public static void main(String[] args) {
        MaxProfit mp = new MaxProfit();
        int[] prices = new int[]{7, 1, 5, 3, 6, 4};
        System.out.println(mp.maxProfit1(prices));
        System.out.println(mp.maxProfit2(prices));
    }
}
```

## Part2

### 1.[不同路径](https://leetcode-cn.com/problems/unique-paths)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：

> 输入：m = 3, n = 7
> 输出：28

示例 2：

> 输入：m = 3, n = 2
> 输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
>
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下
>

示例 3：

> 输入：m = 7, n = 3
> 输出：28

示例 4：

> 输入：m = 3, n = 3
> 输出：6


提示：

> 1 <= m, n <= 100
> 题目数据保证答案小于等于 2 * 109
>

```java
package com.yubin.part2;

public class UniquePaths {
    /**
     * 动态规划算法求取最多的路径数量<br>
     * 递推关系，对于最终的目的点，由于只能选择右或者下，最后只有两个地方直接抵达这个点<br>
     * 即改点的上一个点或者左边的那个点，由此得到递推关系dp[i][j]=dp[i-1][j]+dp[i][j-1]
     *
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths1(int m, int n) {
        int[][] dp = new int[m][n];
        //递推求解数组中的每个值
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) dp[i][j] = 1;
                else
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * 动态规划算法空间优化<br>
     * 遍历得时候按照行进行遍历，那么只需要记录上一行和当前点的左边即可
     *
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths2(int m, int n) {
        int[] preRow = new int[n];
        int[] currRow = new int[n];
        currRow[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (i == 0) currRow[j] = 1;
                else currRow[j] = preRow[j] + currRow[j - 1];
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        UniquePaths up = new UniquePaths();
        System.out.println(up.uniquePaths1(3, 7));
    }
}
```

### 2.[不同路径2](https://leetcode-cn.com/problems/unique-paths-ii)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？



网格中的障碍物和空位置分别用 1 和 0 来表示。

 

示例 1：

> 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
> 输出：2
> 解释：
> 3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
>
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右
>

示例 2：

> 输入：obstacleGrid = [[0,1],[0,0]]
> 输出：1


提示：

> m == obstacleGrid.length
> n == obstacleGrid[i].length
> 1 <= m, n <= 100
> obstacleGrid[i][j] 为 0 或 1

```java
package com.yubin.part2;

public class UniquePathsWithObstacles {

    /**
     * 动态规划算法求取最多的路径数量<br>
     * 递推关系，对于最终的目的点，由于只能选择右或者下，最后只有两个地方直接抵达这个点<br>
     * 即改点的上一个点或者左边的那个点，由此得到递推关系dp[i][j]=dp[i-1][j]+dp[i][j-1]<br>
     * 但是，由于中间有不可过的点，那么这个位置的dp值置0
     *
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles1(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i < m + 1; i++) {
            for (int j = 0; j < n + 1; j++) {
                if (i == 0 || j == 0) dp[i][j] = 0;
                else if (i == 1 && j == 1) dp[i][j] = obstacleGrid[0][0] == 0 ? 1 : 0;
                else {
                    if (obstacleGrid[i - 1][j - 1] == 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    else dp[i][j] = 0;
                }
            }
        }
        return dp[m][n];
    }

    /**
     * 对动态规划算法进行空间优化
     *
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles2(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[] preRow = new int[n];
        int[] currRow = new int[n];
        boolean flag = false;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0) {
                    //第一行
                    if (obstacleGrid[i][j] == 1) {
                        flag = true;
                        currRow[j] = 0;
                    } else if (obstacleGrid[i][j] == 0 && flag == false) {
                        currRow[j] = 1;
                    } else if (flag) {
                        currRow[j] = 0;
                    }
                } else if (j == 0) {
                    if (obstacleGrid[i][j] == 1) currRow[0] = 0;
                } else {
                    if (obstacleGrid[i][j] == 1) {
                        currRow[j] = 0;
                    } else {
                        currRow[j] = preRow[j] + currRow[j - 1];
                    }
                }
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        UniquePathsWithObstacles upo = new UniquePathsWithObstacles();
        int[][] grid = new int[][]{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
        System.out.println(upo.uniquePathsWithObstacles1(grid));
        System.out.println(upo.uniquePathsWithObstacles2(grid));
    }
}
```

### 3.[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum)

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例 1：

> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
> 输出：7
> 解释：因为路径 1→3→1→1→1 的总和最小。

示例 2：

> 输入：grid = [[1,2,3],[4,5,6]]
> 输出：12


提示：

> m == grid.length
> n == grid[i].length
> 1 <= m, n <= 200
> 0 <= grid[i][j] <= 100

```java
package com.yubin.part2;

public class MinPathSum {
    /**
     * 动态规划算法，当前点的最短路径等于左边和上边的点中的较小值加上自己
     *
     * @param grid
     * @return
     */
    public int minPathSum1(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j > 0) dp[i][j] = dp[i][j - 1] + grid[i][j];
                else if (j == 0 && i > 0) dp[i][j] = dp[i - 1][j] + grid[i][j];
                else if (i > 0 && j > 0)
                    dp[i][j] = Math.min(grid[i][j] + dp[i - 1][j], grid[i][j] + dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * 动态规划优化空间复杂度,只维护行数据
     *
     * @param grid
     * @return
     */
    public int minPathSum2(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] currRow = new int[n];
        int[] preRow = new int[n];
        currRow[0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j > 0) currRow[j] = grid[i][j] + currRow[j - 1];
                else if (j == 0 && i > 0) currRow[j] = grid[i][j] + preRow[j];
                else if (i > 0 && j > 0) currRow[j] = Math.min(grid[i][j] + currRow[j - 1], grid[i][j] + preRow[j]);
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        int[][] grid = new int[][]{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};
        int[][] grid2 = new int[][]{{1, 2, 3}, {4, 5, 6}};
        MinPathSum mps = new MinPathSum();
        System.out.println(mps.minPathSum1(grid));
        System.out.println(mps.minPathSum2(grid));
        System.out.println(mps.minPathSum1(grid2));
        System.out.println(mps.minPathSum2(grid2));
    }
}
```

### 4.[最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses)（非自己解题）

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

示例 1：

> 输入：s = "(()"
> 输出：2
> 解释：最长有效括号子串是 "()"

示例 2：

> 输入：s = ")()())"
> 输出：4
> 解释：最长有效括号子串是 "()()"

示例 3：

> 输入：s = ""
> 输出：0


提示：

> 0 <= s.length <= 3 * 104
> s[i] 为 '(' 或 ')'

```java
package com.yubin.part2;

import java.util.LinkedList;

public class LongestValidParentheses {
    /**
     * 栈匹配法,遇到左括号，入栈，遇到右括号，检测匹配并弹栈
     * 半天才想明白，我好笨呀
     * https://leetcode-cn.com/problems/longest-valid-parentheses/solution/32-zui-chang-you-xiao-gua-hao-fu-zhu-zha-1cqq/
     *
     * @param s
     * @return 连续的合法字符串长度
     */
    public int longestValidParentheses1(String s) {
        LinkedList<Integer> stack = new LinkedList<>();
        int res = 0;

        for (int i = 0; i < s.length(); i++) {
            if (stack.isEmpty() || s.charAt(i) == '(' || s.charAt(stack.getLast()) == ')') {
                stack.addLast(i);
            } else {
                stack.removeLast();
                res = Math.max(res, stack.isEmpty() ? i + 1 : i - stack.getLast());
            }
        }
        return res;
    }

    /**
     * 解法思路来源：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042/
     *
     * @param s
     * @return
     */
    public int longestValidParentheses2(String s) {
        int res = 0;
        int[] dp = new int[s.length()];
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '(') dp[i] = 0;
            else if (chars[i] == ')') {
                if ((i - 1) >= 0 && (chars[i - 1] == '(')) {
                    dp[i] = 2;
                    if (i - 2 >= 0) dp[i] = dp[i - 2] + 2;
                } else if (i - 1 >= 0 && chars[i - 1] == ')') {
                    //判断((...))形
                    if ((i - dp[i - 1] - 1 >= 0) && (chars[i - dp[i - 1] - 1] == '(')) {
                        dp[i] = dp[i - 1] + 2;
                        if (i - dp[i - 1] - 2 >= 0)
                            dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;
                    }
                }
                res = Math.max(dp[i], res);
            }
        }
        return res;
    }

    public static void main(String[] args) {
        LongestValidParentheses lvp = new LongestValidParentheses();
        System.out.println(lvp.longestValidParentheses1("(()())"));
        System.out.println(lvp.longestValidParentheses1("(()"));
        System.out.println(lvp.longestValidParentheses1("()((()"));
        System.out.println(lvp.longestValidParentheses1("()(())"));
        System.out.println(lvp.longestValidParentheses1(")()())"));
        System.out.println(lvp.longestValidParentheses1(")()())()()("));
        System.out.println(lvp.longestValidParentheses2("(()())"));
        System.out.println(lvp.longestValidParentheses2("(()"));
        System.out.println(lvp.longestValidParentheses2("()((()"));
        System.out.println(lvp.longestValidParentheses2("()(())"));
        System.out.println(lvp.longestValidParentheses2(")()())"));
        System.out.println(lvp.longestValidParentheses2(")()())()()("));
    }
}
```

### 5.[解码方式](https://leetcode-cn.com/problems/decode-ways)

一条包含字母 A-Z 的消息通过以下映射进行了编码 ：

> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26

要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

- "AAJF" ，将消息分组为 (1 1 10 6)
- "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

 

示例 1：

> 输入：s = "12"
> 输出：2
> 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：

> 输入：s = "226"
> 输出：3
> 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：

> 输入：s = "0"
> 输出：0
> 解释：没有字符映射到以 0 开头的数字。
> 含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
> 由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。

示例 4：

> 输入：s = "06"
> 输出：0
> 解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。


提示：

> 1 <= s.length <= 100
> s 只包含数字，并且可能包含前导零。

```java
package com.yubin.part2;

public class NumDecodings {
    /**
     * 动态规划算法<br>
     * 设置一个dp[]数组用于记录到s[i]处时解码的串数量<br>
     * 从左到右查看时数字的时候，由于字母与数字的映射是1-26，那么需要考虑两种位数的情况<br>
     * 1. 只有一位数进行字符扩展的时候，那么i处能得到的串数量就是i-1处的串数量<br>
     * 这里需要注意的是0的情况，0不会构成字符，所以1位扩展在s[i]=='0'时无效<br>
     * 2. 有两位数字进行扩展的时候，那么i出可以得到的串数量，就是i-2出已经知道的串数量<br>
     * 这里需要注意的是，由于1-26才会对应出字符，所以需要进行数的大小判断<p></p>
     * 这里由于值需要用到dp[i]前面的两个数，所以，可以不定义数组
     *
     * @param s
     * @return
     */
    public int numDecodings1(String s) {
        int res = 0, pre1 = 1, pre2 = 1;
        int num;
        for (int i = 0; i < s.length(); i++) {
            res = 0;
            num = Integer.parseInt(String.valueOf(s.charAt(i)));
            if (num >= 1 && num <= 9) {
                res += pre1;
            }
            if (i - 1 >= 0 && s.charAt(i - 1) != '0') {
                num = Integer.parseInt(s.substring(i - 1, i + 1));
                if (num >= 1 && num <= 26) {
                    res += pre2;
                }
            }
            pre2 = pre1;
            pre1 = res;
        }
        return res;
    }

    /**
     * 时间内复杂度终于优化到了100%<br>
     * 执行用时： 1 ms , 在所有 Java 提交中击败了100.00% 的用户<br>
     * 内存消耗： 36.3 MB , 在所有 Java 提交中击败了 98.86% 的用户
     *
     * @param s
     * @return
     */
    public int numDecodings2(String s) {
        int res = 0, pre1 = 1, pre2 = 1;
        for (int i = 0; i < s.length(); i++) {
            res = 0;
            if (s.charAt(i) >= '1' && s.charAt(i) <= '9') {
                res += pre1;
            }
            if (i - 1 >= 0 && (s.charAt(i - 1) == '1' || (s.charAt(i - 1) == '2' && s.charAt(i) < '7'))) {
                res += pre2;
            }
            pre2 = pre1;
            pre1 = res;
        }
        return res;
    }

    public static void main(String[] args) {
        NumDecodings nd = new NumDecodings();
        System.out.println(nd.numDecodings1("111"));
        System.out.println(nd.numDecodings1("12"));
        System.out.println(nd.numDecodings1("226"));
        System.out.println(nd.numDecodings1("0"));
        System.out.println(nd.numDecodings1("06"));
        System.out.println(nd.numDecodings2("111"));
        System.out.println(nd.numDecodings2("12"));
        System.out.println(nd.numDecodings2("226"));
        System.out.println(nd.numDecodings2("0"));
        System.out.println(nd.numDecodings2("06"));
    }
}
```

## Part3



