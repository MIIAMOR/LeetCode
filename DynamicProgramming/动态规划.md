# 动态规划

## Part1

### 1 [Fibonacci数列](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

```java
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。
```

> - 示例 1：
>
>
> 输入：2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
>
> - 示例 2：
>
> 输入：3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
>
> - 示例 3：
>
> 输入：4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3

> 提示：0 <= n <= 30

```java
package com.learn.part1;

/**
 * 动态规划题目：斐波那契数列
 */
public class Fibonacci {
    /**
     * 递归算法，重复调用自身。可能栈内存溢出
     *
     * @param n
     * @return
     */
    public int fib1(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fib1(n - 1) + fib1(n - 2);
        }
    }

    /**
     * 动态规划算法，可以优化，不必开辟数组
     *
     * @param n
     * @return
     */
    public int fib2(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int[] dp = new int[n + 1];
            dp[0] = 0;
            dp[1] = 1;
            for (int i = 2; i < dp.length; i++) {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];
        }
    }

    /**
     * 动态规划改良，减少内存消耗
     * @param n
     * @return
     */
    public int fib3(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            int sum = 0, pre = 0, curr = 1;
            for (int i = 1; i < n; i++) {
                sum = curr + pre;
                pre = curr;
                curr = sum;
            }
            return sum;
        }
    }

    public static void main(String[] args) {
        Fibonacci f = new Fibonacci();
        System.out.println(f.fib2(5));
        System.out.println(f.fib1(5));
        System.out.println(f.fib3(5));
    }
}
```

### 2.[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

> - 示例 1：
>
>输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> 
>- 示例 2：
> 
>输入：s = "cbbd"
> 输出："bb"
> 
>- 示例 3：
> 
>输入：s = "a"
> 输出："a"
> 
>- 示例 4：
> 
>输入：s = "ac"
> 输出："a"

>
> 提示：
>
> 1 <= s.length <= 1000
> s 仅由数字和英文字母（大写和/或小写）组成

**`这里的方法2：中心向外扩展法，在LeetCode上无法编译通过，但是idea上可以运行。`**

```java
package com.learn.part1;

public class LongestPalindrome {
    /**
     * <p>动态规划算法</p>
     * <p>1.建立一个dp数组记录dp[j]记录的是以j下标为结尾的最长回文串的开始位置</p>
     * <p>2.如何递推求出每个dp[j]的值</p>
     * <p> 情况1：dp[j+1] = dp[dp[j]-1],这种情况直接使得dp[j+1] = dp[j]-1</p>
     * <p> 情况2：如果没能向两侧扩展，那么需要重新求出最长回文子串<br/>
     * (解决方法：设置两个下标left = dp[j],right = j+1<br>
     * 如果str[lef]==str[right]让left++的同时让right--<br>
     * 如果遇到str[lef]！=str[right]，让right回归初始值，left不变<br>
     * 当left==right的时候，就可以记录dp数组了
     * </p>
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome1(String s) {
        if (s == null) {
            return null;
        }
        int[] dp = new int[s.length()];//建立记录数组
        char[] chars = s.toCharArray();//拆分字符串为一个字符数组
        dp[0] = 0;//初始化dp[0]为0
        //动态求得每一个数组的值
        for (int i = 1; i < chars.length; i++) {
            //边界判断 索引没有变为负数
            if (dp[i - 1] - 1 >= 0 && chars[i] == chars[dp[i - 1] - 1]) {
                //情况1 当前字符串等于上一个字符串的上
                dp[i] = dp[i - 1] - 1;
            } else {
                int left = dp[i - 1], right = i, index = dp[i - 1];
                while (right - left >= 1) {
                    if (chars[left] == chars[right]) {
                        left++;
                        right--;
                    } else {
                        right = i;
                        left++;
                        index = left;
                        if (index == i) break;
                    }
                }
                dp[i] = index;
            }
        }
        //遍历获取最大的回文串
        int begin = 0, end = 0, len = 0;
        for (int i = 0; i < dp.length; i++) {
            if (i - dp[i] > len) {
                begin = dp[i];
                end = i;
                len = i - dp[i];
            }
        }
        return s.substring(begin, end + 1);
    }

    /**
     * 中间向两侧扩展法，思路简单易懂
     *
     * @param s 要求的字符串
     * @return 最长的回文子串
     */
    public String longestPalindrome2(String s) {
        if (s == null) {
            return null;
        }
        StringBuilder res = new StringBuilder();
        StringBuilder str1 = new StringBuilder();
        StringBuilder str2 = new StringBuilder();
        for (int i = 0; i < s.length() - 1; i++) {
            str1.delete(0, str1.length()).append(extend(s, i, i));//奇数扩展
            str2.delete(0, str2.length()).append(extend(s, i, i + 1));//偶数扩展
            if (res.length() < str1.length() || res.length() < str2.length()) {
                res.delete(0, res.length()).append(str1.length() > str2.length() ? str1 : str2);
            }
        }
        return res.toString();
    }

    /**
     * 从中间向两侧扩展，注意<br>
     * 回文串是奇数还是偶数<br>
     *
     * @param s     待求的字符串
     * @param left  以该索引向两边扩展
     * @param right 以该索引向两边扩展
     * @return 中间向两侧扩展的最大回文子串
     */
    private String extend(String s, int left, int right) {
        while (left >= 0 && right < s.length()) {
            if (s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
            } else {
                break;
            }
        }
        return s.substring(left + 1, right);
    }

    public static void main(String[] args) {
        LongestPalindrome lp = new LongestPalindrome();
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1("cbbdd"));
        System.out.println(lp.longestPalindrome1("cb"));
        System.out.println(lp.longestPalindrome1("ababababa"));
        System.out.println(lp.longestPalindrome1("asddsa"));
        System.out.println(lp.longestPalindrome1(null));
        System.out.println(lp.longestPalindrome2("asddsa"));
        System.out.println(lp.longestPalindrome2("cbbdd"));
        System.out.println(lp.longestPalindrome2("cb"));
        System.out.println(lp.longestPalindrome2("ababababa"));
        System.out.println(lp.longestPalindrome2("babad"));
        System.out.println(lp.longestPalindrome2("bb"));
        System.out.println(lp.longestPalindrome2("sss"));
        System.out.println(lp.longestPalindrome2(""));
        System.out.println(lp.longestPalindrome2(null));
    }
}
```

### 3.[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)（进阶：分治求解）

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

> - 示例 1：
>
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>
> - 示例 2：
>
> 输入：nums = [1]
> 输出：1
>
> - 示例 3：
>
> 输入：nums = [0]
> 输出：0
>
> - 示例 4：
>
> 输入：nums = [-1]
> 输出：-1
>
> - 示例 5：
>
> 输入：nums = [-100000]
> 输出：-100000
>
> - 
>   提示：1 <= nums.length <= 3 * 104      -105 <= nums[i] <= 105
>
>
> - 
>   进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
>

```java
package com.learn.part1;

public class MaxSubArray {
    /**
     * 动态规划算法<br>
     * 利用一个一维数组dp[j]来记录包含nums[j]的最大子序和<br/>
     * 其中递归规律是：<br>
     * 1.对于dp[j],如果dp[j-1]>0,那么dp[j]=dp[j-1]+nums[j]<br>
     * 2.对于dp[j],如果dp[j-1]<0，那么dp[j]=nums[j]
     *
     * @param nums 一个数组
     * @return 最大子序和（即最大连续子数组和）
     */
    public int maxSubArray1(int[] nums) {
        int[] dp = new int[nums.length];
        int res = nums[0];
        dp[0] = nums[0];
        //按照递推规律求得dp数组的值
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    public static void main(String[] args) {
        MaxSubArray msa = new MaxSubArray();
        int[] nums = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(msa.maxSubArray1(nums));
    }
}
```

### 4.[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
>
> 1 阶 + 1 阶
>
> 2 阶

示例 2：

> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
>
> 1 阶 + 1 阶 + 1 阶
>
> 1 阶 + 2 阶
>
> 2 阶 + 1 阶

```java
package com.learn.part1;

public class ClimbStairs {
    /**
     * 由于爬楼梯的方式要么两格一步，要么一格一步<br>
     * 所以爬到最后一阶楼梯的时候要么跨出两步，要么跨出一步<br>
     * 所以F(n)=F(n-1)+F(n-2)
     *
     * @param n 楼梯数
     * @return 爬楼梯的方式数
     */
    public int climbStairs(int n) {
        int pre = 1, curr = 2, res = 1;
        for (int i = 1; i < n; i++) {
            res = curr;
            curr = pre + curr;
            pre = res;
        }
        return res;
    }

    public static void main(String[] args) {
        ClimbStairs cs = new ClimbStairs();
        System.out.println(cs.climbStairs(4));
    }
}
```

### 5.[买股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。



示例 1：

> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> 示例 2：

> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

> 1 <= prices.length <= 105
> 0 <= prices[i] <= 104

```java
package com.learn.part1;

public class MaxProfit {
    /**
     * 分析：<br>
     * <p>
     * 解法1：暴力遍历数组，记录最大的利益 timeoutError
     * </p>
     *
     * @param prices 股票的价格
     * @return 最大收益
     */
    public int maxProfit1(int[] prices) {
        int res = 0;
        for (int i = prices.length - 1; i >= 0; i--) {
            for (int j = i; j >= 0; j--) {
                if (prices[j] < prices[i] && res < prices[i] - prices[j]) res = prices[i] - prices[j];
            }
        }
        return res;
    }

    /**
     * 分析：<br>
     * <p>
     * 解法2：图像分析法+动态规划算法<br>
     * 把每个值绘制在折线图中，就可以非常直观看到每个数值的大小关系了<br>
     * 整个过程就是找出极差，右边的数必须大于左边的数<br>
     * 用数组dp表示动态规划的状态数组，则dp[i]表示到第i天时的最大利润。<br>
     * 用变量cur_min_buy维护截止到前一天股票的最低买入价格<br>
     * 则不难看出状态转移方程为dp[i]=max(dp[i-1], prices[i]-cur_min_buy).<br>
     *     在动态记录这个result即可
     * </p>
     *
     * @param prices 股票的价格
     * @return 最大收益
     */
    public int maxProfit2(int[] prices) {
        if (prices.length < 2) return 0;
        // res用来记录当前已经知道的最大利益，currMin用来记录已知的最小股票市价
        int res = 0, currMin = prices[0];
        for (int price : prices) {
            currMin = Math.min(currMin, price);
            res = Math.max(res, price - currMin);
        }
        return res;
    }

    public static void main(String[] args) {
        MaxProfit mp = new MaxProfit();
        int[] prices = new int[]{7, 1, 5, 3, 6, 4};
        System.out.println(mp.maxProfit1(prices));
        System.out.println(mp.maxProfit2(prices));
    }
}
```

## Part2

### 1.[不同路径](https://leetcode-cn.com/problems/unique-paths)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：

> 输入：m = 3, n = 7
> 输出：28

示例 2：

> 输入：m = 3, n = 2
> 输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
>
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下
>

示例 3：

> 输入：m = 7, n = 3
> 输出：28

示例 4：

> 输入：m = 3, n = 3
> 输出：6


提示：

> 1 <= m, n <= 100
> 题目数据保证答案小于等于 2 * 109
>

```java
package com.learn.part2;

public class UniquePaths {
    /**
     * 动态规划算法求取最多的路径数量<br>
     * 递推关系，对于最终的目的点，由于只能选择右或者下，最后只有两个地方直接抵达这个点<br>
     * 即改点的上一个点或者左边的那个点，由此得到递推关系dp[i][j]=dp[i-1][j]+dp[i][j-1]
     *
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths1(int m, int n) {
        int[][] dp = new int[m][n];
        //递推求解数组中的每个值
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) dp[i][j] = 1;
                else
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * 动态规划算法空间优化<br>
     * 遍历得时候按照行进行遍历，那么只需要记录上一行和当前点的左边即可
     *
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths2(int m, int n) {
        int[] preRow = new int[n];
        int[] currRow = new int[n];
        currRow[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (i == 0) currRow[j] = 1;
                else currRow[j] = preRow[j] + currRow[j - 1];
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        UniquePaths up = new UniquePaths();
        System.out.println(up.uniquePaths1(3, 7));
    }
}
```

### 2.[不同路径2](https://leetcode-cn.com/problems/unique-paths-ii)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？



网格中的障碍物和空位置分别用 1 和 0 来表示。

 

示例 1：

> 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
> 输出：2
> 解释：
> 3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
>
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右
>

示例 2：

> 输入：obstacleGrid = [[0,1],[0,0]]
> 输出：1


提示：

> m == obstacleGrid.length
> n == obstacleGrid[i].length
> 1 <= m, n <= 100
> obstacleGrid[i][j] 为 0 或 1

```java
package com.learn.part2;

public class UniquePathsWithObstacles {

    /**
     * 动态规划算法求取最多的路径数量<br>
     * 递推关系，对于最终的目的点，由于只能选择右或者下，最后只有两个地方直接抵达这个点<br>
     * 即改点的上一个点或者左边的那个点，由此得到递推关系dp[i][j]=dp[i-1][j]+dp[i][j-1]<br>
     * 但是，由于中间有不可过的点，那么这个位置的dp值置0
     *
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles1(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i < m + 1; i++) {
            for (int j = 0; j < n + 1; j++) {
                if (i == 0 || j == 0) dp[i][j] = 0;
                else if (i == 1 && j == 1) dp[i][j] = obstacleGrid[0][0] == 0 ? 1 : 0;
                else {
                    if (obstacleGrid[i - 1][j - 1] == 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    else dp[i][j] = 0;
                }
            }
        }
        return dp[m][n];
    }

    /**
     * 对动态规划算法进行空间优化
     *
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles2(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[] preRow = new int[n];
        int[] currRow = new int[n];
        boolean flag = false;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0) {
                    //第一行
                    if (obstacleGrid[i][j] == 1) {
                        flag = true;
                        currRow[j] = 0;
                    } else if (obstacleGrid[i][j] == 0 && flag == false) {
                        currRow[j] = 1;
                    } else if (flag) {
                        currRow[j] = 0;
                    }
                } else if (j == 0) {
                    if (obstacleGrid[i][j] == 1) currRow[0] = 0;
                } else {
                    if (obstacleGrid[i][j] == 1) {
                        currRow[j] = 0;
                    } else {
                        currRow[j] = preRow[j] + currRow[j - 1];
                    }
                }
            }
            System.arraycopy(currRow, 0, preRow, 0, n);
        }
        return currRow[n - 1];
    }

    public static void main(String[] args) {
        UniquePathsWithObstacles upo = new UniquePathsWithObstacles();
        int[][] grid = new int[][]{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
        System.out.println(upo.uniquePathsWithObstacles1(grid));
        System.out.println(upo.uniquePathsWithObstacles2(grid));
    }
}
```