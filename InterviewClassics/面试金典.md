# 面试金典

## part01：字符串

### [01. 判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

示例 1：

> 输入: s = "leetcode"
> 输出: false 

示例 2：

> 输入: s = "abc"
> 输出: true

- 如果你不使用额外的数据结构，会很加分。

```java
package com.yubin.part01;

import java.sql.Array;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * @author MIIAMOR
 * @date 2021/6/23 19:31
 * easy
 */
public class IsUnique {
    /**
     * 哈希集合存储
     */
    public boolean isUnique(String astr) {
        char[] chars = astr.toCharArray();
        Set<Character> set = new HashSet<>();
        for (char c : chars) {
            if (set.contains(c)) return false;
            set.add(c);
        }
        return true;
    }

    /**
     * 暴力枚举法
     */
    public boolean isUnique1(String astr) {
        char[] chars = astr.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            for (int j = i + 1; j < chars.length; j++) {
                if (chars[i] == chars[j]) return false;
            }
        }
        return true;
    }

    /**
     * 排序后对比
     */
    public boolean isUnique2(String astr) {
        char[] chars = astr.toCharArray();
        Arrays.sort(chars);
        for (int i = 0; i < chars.length - 1; i++) {
            if (chars[i] == chars[i + 1]) return false;
        }
        return true;
    }

    /**
     * 数组计数法
     */
    public boolean isUnique3(String astr) {
        int[] count = new int[128];
        for (int i = 0; i < astr.length(); i++) {
            char c = astr.charAt(i);
            if (count[c] != 0) return false;
            count[c]++;
        }
        return true;
    }

    /**
     * 假设题目中使用的字符数为26个小写字符
     * 使用位运算算法
     * << 是左移运算符
     */
    public boolean isUnique4(String astr) {
        int count = 0, base = 1, countChar;
        for (char c : astr.toCharArray()) {
            int offset = c - 'a';
            countChar = base << offset;
            if ((count & countChar) > 0) return false;
            count |= countChar;
        }
        return true;
    }
}
```

### [02. 判定是否互为字符重排](https://leetcode-cn.com/problems/check-permutation-lcci/)

给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

示例 1：

> 输入: s1 = "abc", s2 = "bca"
> 输出: true 

```java
package com.yubin.part01;

import java.util.Arrays;

/**
 * @author MIIAMOR
 * @date 2021/6/23 19:52
 * easy
 */
public class CheckPermutation {
    /**
     * 假设使用到的字符数是26个小写字符
     */
    public boolean checkPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int[] countS1 = new int[26], countS2 = new int[26];
        int len = s1.length();
        for (int i = 0; i < len; i++) {
            countS1[s1.charAt(i) - 'a']++;
            countS2[s2.charAt(i) - 'a']++;
        }
        return Arrays.equals(countS1, countS2);
    }
}
```

### [03. URL化](https://leetcode-cn.com/problems/string-to-url-lcci/)

URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）

 

示例 1：

> 输入："Mr John Smith    ", 13
> 输出："Mr%20John%20Smith"

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/23 20:03
 * easy
 */
public class ReplaceSpaces {
    public String replaceSpaces(String S, int length) {
        StringBuilder sb = new StringBuilder();
        char[] chars = S.toCharArray();
        for (int i = 0; i < length; i++) {
            if (chars[i] == ' ') sb.append("%20");
            else sb.append(chars[i]);
        }
        return sb.toString();
    }

    public String replaceSpaces1(String S, int length) {
        String s = S.substring(0, length);
        s = s.replace(" ", "%20");
        return s;
    }
}
```

### [04. 回文排列](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。

回文串不一定是字典当中的单词。

 

示例1：

> 输入："tactcoa"
> 输出：true（排列有"tacocat"、"atcocta"，等等）

```java
package com.yubin.part01;

import java.util.HashSet;
import java.util.Set;

/**
 * @author MIIAMOR
 * @date 2021/6/23 20:36
 * easy
 */
public class CanPermutePalindrome {
    public boolean canPermutePalindrome(String s) {
        int odd = 0;
        int[] count = new int[256];
        char[] chars = s.toCharArray();
        for (char c : chars) {
            count[c]++;
        }
        for (int i : count) {
            if (i % 2 == 1) odd++;
        }
        return odd <= 1;
    }

    public boolean canPermutePalindrome1(String s) {
        Set<Character> set = new HashSet<>();
        for (char c : s.toCharArray()) {
            if (!set.contains(c)) set.add(c);
            else set.remove(c);
        }
        return set.size() <= 1;
    }
}
```

### [05. 一次编辑](https://leetcode-cn.com/problems/one-away-lcci/)

字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

 

示例 1:

> 输入: 
> first = "pale"
> second = "ple"
> 输出: True

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 8:58
 * medium
 */
public class OneEditAway {
    public boolean oneEditAway(String first, String second) {
        int len1 = first.length(), len2 = second.length();
        if (Math.abs(len1 - len2) > 1) return false;
        if ((len1 == 1 && len2 == 0) || (len1 == 0 && len2 == 1) || (len1 == 1 && len2 == 1) || (len1 == 0 && len2 == 0))
            return true;
        char[] firstC = first.toCharArray(), secondC = second.toCharArray();
        int count = 0;
        int i = 0, j = 0;
        while (i < len1 && j < len2) {
            if (count > 1) break;
            if (firstC[i] == secondC[j]) {
                i++;
                j++;
            } else {
                if (len1 < len2) {
                    // len1小 选择在first上添加一个字符
                    count++;
                    j++;
                } else if (len1 > len2) {
                    // len1大 选择在first上删除一个字符
                    count++;
                    i++;
                } else {
                    // 一样大 选择在first上替换一个字符
                    count++;
                    i++;
                    j++;
                }
            }
        }
        return count <= 1;
    }
}
```

### [06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

示例1:

>  输入："aabcccccaaa"
>  输出："a2b1c5a3"

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 9:11
 * easy
 */
public class CompressString {
    public String compressString(String S) {
        if (S == null) return null;
        if (S.length() == 0) return S;
        StringBuilder sb = new StringBuilder();
        char[] chars = S.toCharArray();
        int count = 1;
        char pre = chars[0];
        for (int i = 1; i < chars.length; i++) {
            if (chars[i] == pre) count++;
            else {
                sb.append(pre).append(count);
                pre = chars[i];
                count = 1;
            }
        }
        sb.append(pre).append(count);
        return sb.length() < S.length() ? sb.toString() : S;
    }

    public static void main(String[] args) {
        new CompressString().compressString(
                "aabcccccaa");
    }
}
```

### [07. 旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/)

给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

 

示例 1:

> 给定 matrix = 
> [
> [1,2,3],
> [4,5,6],
> [7,8,9]
> ],
>
> 原地旋转输入矩阵，使其变为:
> [
> [7,4,1],
> [8,5,2],
> [9,6,3]
> ]

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 9:38
 * medium
 */
public class Rotate {
    /**
     * 只在原地修改矩阵
     * 本题难点是坐标变换
     */
    public void rotate(int[][] matrix) {
        int N = matrix.length;
        int num, numNext;
        for (int i = 0; i < N / 2; i++) {
            for (int j = i; j < N - 1 - i; j++) {
                int index1 = i, index2 = j;

                num = matrix[index1][index2];
                index1 = index2;
                index2 = N - 1 - i;
                numNext = matrix[index1][index2];
                matrix[index1][index2] = num;

                num = numNext;
                index1 = index2;
                index2 = N - 1 - j;
                numNext = matrix[index1][index2];
                matrix[index1][index2] = num;

                num = numNext;
                index1 = index2;
                index2 = i;
                numNext = matrix[index1][index2];
                matrix[index1][index2] = num;

                matrix[i][j] = numNext;
            }
        }
    }

    public void rotate1(int[][] matrix) {
        int N = matrix.length;
        int[][] rotateMatrix = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                rotateMatrix[j][N - 1 - i] = matrix[i][j];
            }
        }
        matrix = rotateMatrix;
    }

    public static void main(String[] args) {
        new Rotate().rotate(new int[][]{
                {5, 1, 9, 11},
                {2, 4, 8, 10},
                {13, 3, 6, 7},
                {15, 14, 12, 16}
        });
        new Rotate().rotate(new int[][]{
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9}
        });
    }
}
```

### [08. 零矩阵](https://leetcode-cn.com/problems/zero-matrix-lcci/)

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

 

示例 1：

> 输入：
> [
> [1,1,1],
> [1,0,1],
> [1,1,1]
> ]
> 输出：
> [
> [1,0,1],
> [0,0,0],
> [1,0,1]
> ]

```java
package com.yubin.part01;

import java.util.HashSet;
import java.util.Set;

/**
 * @author MIIAMOR
 * @date 2021/6/24 10:37
 * medium
 */
public class SetZeroes {
    public void setZeroes(int[][] matrix) {
        int M = matrix.length, N = matrix[0].length;
        Set<Integer> cols = new HashSet<>(), rows = new HashSet<>();
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] == 0) {
                    cols.add(j);
                    rows.add(i);
                }
            }
        }
        for (Integer col : cols) {
            for (int i = 0; i < M; i++) {
                matrix[i][col] = 0;
            }
        }
        for (Integer row : rows) {
            for (int i = 0; i < N; i++) {
                matrix[row][i] = 0;
            }
        }
    }

    public void setZeroes1(int[][] matrix) {
        int M = matrix.length, N = matrix[0].length;
        boolean[] rows = new boolean[M], cols = new boolean[N];
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] == 0) {
                    rows[i] = true;
                    cols[j] = true;
                }
            }
        }
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (rows[i] || cols[j]) matrix[i][j] = 0;
            }
        }
    }
}
```

### [09. 字符串轮转](https://leetcode-cn.com/problems/string-rotation-lcci/)

字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。

示例1:

>  输入：s1 = "waterbottle", s2 = "erbottlewat"
>  输出：True

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 10:52
 * easy
 */
public class IsFlippedString {
    public boolean isFlippedString(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int len = s1.length();
        for (int i = 0; i < len; i++) {
            if (s1.substring(0, i).equals(s2.substring(len - i))
                    && s1.substring(i).equals(s2.substring(0, len - i)))
                return true;
        }
        return len == 0;
    }

    /**
     * 大佬的解法
     */
    public boolean isFlippedString1(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        String s = s2 + s2;
        return s.contains(s1);
    }

    public static void main(String[] args) {
        new IsFlippedString().isFlippedString("WaterBottle", "erBottleWat");
    }
}
```

## part02：链表

### [01. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

**示例1:**

>  输入：[1, 2, 3, 3, 2, 1]
>  输出：[1, 2, 3]

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

import java.util.*;

/**
 * @author MIIAMOR
 * @date 2021/6/24 13:09
 * easy
 */
public class RemoveDuplicateNodes {
    public ListNode removeDuplicateNodes(ListNode head) {
        if (head == null) return null;
        ListNode n = head;
        List<Integer> list = new ArrayList<>();
        while (n != null) {
            if (!list.contains(n.val))
                list.add(n.val);
            n = n.next;
        }
        n = new ListNode(list.get(0));
        ListNode res = n;
        for (int i = 1; i < list.size(); i++) {
            n.next = new ListNode(list.get(i));
            n = n.next;
        }
        return res;
    }

    public ListNode removeDuplicateNodes1(ListNode head) {
        if (head == null) return null;
        Set<Integer> set = new HashSet<>();
        ListNode n = head;
        ListNode listNode = new ListNode(n.val);
        ListNode res = listNode;
        set.add(n.val);
        while (n != null) {
            if (!set.contains(n.val)) {
                listNode.next = new ListNode(n.val);
                set.add(n.val);
                listNode = listNode.next;
            }
            n = n.next;
        }
        return res;
    }

    public ListNode removeDuplicateNodes2(ListNode head) {
        if (head == null) return null;
        Set<Integer> set = new HashSet<>();
        ListNode n = head;
        set.add(n.val);
        while (n.next != null) {
            if (!set.contains(n.next.val)) {
                set.add(n.next.val);
                n = n.next;
            } else
                n.next = n.next.next;
        }
        return head;
    }

    /**
     * 作弊版哈希表
     */
    public ListNode removeDuplicateNodes3(ListNode head) {
        if (head == null) return null;
        byte[] occurred = new byte[20000];
        ListNode n = head;
        occurred[n.val] = 1;
        while (n.next != null) {
            if (occurred[n.next.val] == 0) {
                occurred[n.next.val] = 1;
                n = n.next;
            } else
                n.next = n.next.next;
        }
        return head;
    }
}
```

### [02. 返回倒数第 k 个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

示例：

> 输入： 1->2->3->4->5 和 k = 2
> 输出： 4

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/24 16:07
 * easy
 */
public class KthToLast {
    public int kthToLast(ListNode head, int k) {
        ListNode n = head;
        List<Integer> list = new ArrayList<>();
        while (n != null) {
            list.add(n.val);
            n = n.next;
        }
        return list.get(list.size() - k);
    }

    /**
     * 双指针解法：第一个指针走k步，两个指针同时走，当一个指针走到了null
     * 第二个指针就走到了倒数第k个位置
     */
    public int kthToLast1(ListNode head, int k) {
        ListNode n = head;
        ListNode res = head;
        for (int i = 0; i < k; i++) {
            n = n.next;
        }
        while (n != null) {
            res = res.next;
            n = n.next;
        }
        return res.val;
    }
}
```

### [03. 删除中间节点](https://leetcode-cn.com/problems/delete-middle-node-lcci/)

若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。

假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。

例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f

 

示例：

> 输入：节点 5 （位于单向链表 4->5->1->9 中）
> 输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 9:15
 * easy
 */
public class DeleteNode {
    /**
     * 删除链表中间节点
     *
     * @param node
     */
    public void deleteNode1(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }

    public void deleteNode(ListNode node) {
        ListNode pre = node;
        node.val = node.next.val;
        node = node.next;
        while (node.next != null) {
            node.val = node.next.val;
            node = node.next;
            pre = pre.next;
        }
        pre.next = null;
    }
}
```

### [04. 分割链表](https://leetcode-cn.com/problems/partition-list-lcci/)

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

> 输入: head = 3->5->8->5->10->2->1, x = 5
> 输出: 3->1->2->10->5->5->8

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 9:25
 * medium
 */
public class Partition {
    /**
     * 有点没看懂题目,不是说x的节点必须在右边，不能在交界处
     */
    public ListNode partition(ListNode head, int x) {
        ListNode left = new ListNode(x), res = left;
        ListNode mid = new ListNode(x), midRes = mid;
        ListNode right = new ListNode(x), rightRes = right;
        while (head != null) {
            if (head.val < x) {
                left.next = head;
                left = left.next;
            } else if (head.val > x) {
                mid.next = head;
                mid = mid.next;
            } else {
                right.next = head;
                right = right.next;
            }
            head = head.next;
        }
        right.next = null;
        mid.next = rightRes.next;
        left.next = midRes.next;
        return res.next;
    }

    public ListNode partition1(ListNode head, int x) {
        ListNode left = new ListNode(x), leftRes = left;
        ListNode right = new ListNode(x), rightRes = right;
        while (head != null) {
            if (head.val < x) {
                left.next = head;
                left = left.next;
            } else {
                right.next = head;
                right = right.next;
            }
            head = head.next;
        }
        right.next = null;
        left.next = rightRes.next;
        return leftRes.next;
    }
}
```



### [05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

 

示例：

> 输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
> 输出：2 -> 1 -> 9，即912

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 10:10
 * medium
 */
public class AddTwoNumbers {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int next = 0, currSum;
        ListNode sum = new ListNode(0), res = sum;
        while (l1 != null || l2 != null) {
            int num1 = 0, num2 = 0;
            if (l1 != null) {
                num1 = l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                num2 = l2.val;
                l2 = l2.next;
            }
            currSum = next + num1 + num2;
            sum.next = new ListNode(currSum % 10);
            sum = sum.next;
            next = currSum / 10;
        }
        if (next != 0) sum.next = new ListNode(next);
        return res.next;
    }
}
```

### [06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/)

编写一个函数，检查输入的链表是否是回文的。

 

**示例 1：**

```java
输入： 1->2
输出： false 
```

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/25 10:20
 * easy
 */
public class IsPalindrome {
    /**
     * List记录数据
     */
    public boolean isPalindrome(ListNode head) {
        List<Integer> list = new ArrayList<>();
        ListNode n = head;
        while (n != null) {
            list.add(n.val);
            n = n.next;
        }
        for (int i = 0; i < list.size() / 2; i++) {
            if (!list.get(i).equals(list.get(list.size() - i - 1)))
                return false;
        }
        return true;
    }

    /**
     * dfs求解
     */
    private ListNode head = null;

    public boolean isPalindrome1(ListNode head) {
        if (head == null) return true;
        this.head = head;
        return dfs(head);
    }

    private boolean dfs(ListNode n) {
        if (n.next != null && !dfs(n.next))
            return false;
        if (head.val != n.val)
            return false;
        head = head.next;
        return true;
    }
}
```

### [07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。


示例 1：

> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
> 输出：Reference of the node with value = 8
> 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 10:57
 * easy
 */
public class GetIntersectionNode {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode nodeA = headA;
        while (nodeA != null) {
            ListNode node = headB;
            while (node != null) {
                if (nodeA.equals(node)) return node;
                node = node.next;
            }
            nodeA = nodeA.next;
        }
        return null;
    }

    /**
     * 大佬解法
     * 使用两个指针：
     * 一个A走完了走B，另一个B走完了走A
     * 如果有相同节点，必然两个指针相遇
     * 如果没有相遇，两个指针都会走向null
     */
    public ListNode getIntersectionNode1(ListNode headA, ListNode headB) {
        ListNode nodeA = headA, nodeB = headB;
        while (nodeA != nodeB) {
            nodeA = nodeA == null ? headB : nodeA.next;
            nodeB = nodeB == null ? headA : nodeB.next;
        }
        return nodeA;
    }
}
```

### [08. 环路检测](https://leetcode-cn.com/problems/linked-list-cycle-lcci/)

给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

 

示例 1：

> 输入：head = [3,2,0,-4], pos = 1
> 输出：tail connects to node index 1
> 解释：链表中有一个环，其尾部连接到第二个节点。

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 17:00
 * medium
 */
public class DetectCycle {
    /**
     * 环路检测使用双指针解法解答
     * 环入口地址求解方式：数学方式
     */
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        ListNode fast = head, slow = head;
        while (true) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == null || fast.next == null) return null;
            if (fast == slow) {
                fast = head;
                while (slow != fast) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return slow;
            }
        }
    }
}
```

## part03：栈与队列

### [01. 三合一](https://leetcode-cn.com/problems/three-in-one-lcci/)

三合一。描述如何只用一个数组来实现三个栈。

你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。

构造函数会传入一个stackSize参数，代表每个栈的大小。

示例1:

>  输入：
> ["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]
> [[1], [0, 1], [0, 2], [0], [0], [0], [0]]
>  输出：
> [null, null, null, 1, -1, -1, true]
> 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。

```java
package com.yubin.part03;

/**
 * @author MIIAMOR
 * @date 2021/6/25 17:18
 * easy
 */
public class TripleInOne {
    /**
     * 使用一个数组完成三个栈的模拟
     */
    int[][] stack = null;
    int stackSize = 0;

    public TripleInOne(int stackSize) {
        stack = new int[3][stackSize + 1];
        this.stackSize = stackSize;
    }

    public void push(int stackNum, int value) {
        int index = stack[stackNum][stackSize];
        if (index == stackSize) return;
        stack[stackNum][index++] = value;
        stack[stackNum][stackSize] = index;
    }

    public int pop(int stackNum) {
        int index = stack[stackNum][stackSize];
        if (index == 0) return -1;
        stack[stackNum][stackSize] = --index;
        return stack[stackNum][index];
    }

    public int peek(int stackNum) {
        int index = stack[stackNum][stackSize];
        if (index == 0) return -1;
        return stack[stackNum][index - 1];
    }

    public boolean isEmpty(int stackNum) {
        int index = stack[stackNum][stackSize];
        return index == 0;
    }
}
```

### [02. 栈的最小值](https://leetcode-cn.com/problems/min-stack-lcci/)

请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。


示例：

> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.getMin();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.getMin();   --> 返回 -2.

```java
package com.yubin.part03;

/**
 * @author MIIAMOR
 * @date 2021/6/25 17:37
 * easy
 */
public class MinStack {
    /**
     * 辅助栈存储当前的最小元素
     */
    private Node stackHead = null;
    private Node stackPointer = null, stackMinPointer = null;

    public MinStack() {
        stackHead = new Node(Integer.MAX_VALUE);
        stackPointer = stackHead;
        stackMinPointer = new Node(Integer.MAX_VALUE);
    }

    public void push(int x) {
        stackPointer.next = new Node(x, stackPointer);
        stackMinPointer.next = new Node(Math.min(stackMinPointer.val, x), stackMinPointer);
        stackPointer = stackPointer.next;
        stackMinPointer = stackMinPointer.next;
    }

    public void pop() {
        if (stackPointer == stackHead) return;
        stackPointer = stackPointer.pre;
        stackPointer.next = null;
        stackMinPointer = stackMinPointer.pre;
        stackMinPointer.next = null;
    }

    public int top() {
        return stackPointer.val;
    }

    public int getMin() {
        return stackMinPointer.val;
    }

    private static class Node {
        public int val;
        public Node pre;
        public Node next;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node pre) {
            this.val = val;
            this.pre = pre;
        }
    }
}
```

### [03. 堆盘子](https://leetcode-cn.com/problems/stack-of-plates-lcci/)

堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。

当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1.

示例1:

>  输入：
> ["StackOfPlates", "push", "push", "popAt", "pop", "pop"]
> [[1], [1], [2], [1], [], []]
>  输出：
> [null, null, null, 2, 1, -1]

```java
package com.yubin.part03;

/**
 * @author MIIAMOR
 * @date 2021/6/25 19:20
 * medium
 */
public class StackOfPlates {
    private final Node stackHead;
    private Node stackPointer;
    private final int cap;
    private int length;

    public StackOfPlates(int cap) {
        this.cap = cap;
        stackHead = new Node(null);
        stackPointer = stackHead;
        this.length = 0;
    }

    public void push(int val) {
        if (cap == 0) return;
        if (stackPointer.size == cap || stackPointer == stackHead) {
            stackPointer.next = new Node(new int[cap], stackPointer);
            stackPointer = stackPointer.next;
            this.length++;
        }
        stackPointer.val[stackPointer.size++] = val;
    }

    public int pop() {
        if (stackPointer == stackHead) return -1;
        int res = stackPointer.val[--stackPointer.size];
        if (stackPointer.size == 0) {
            stackPointer = stackPointer.pre;
            stackPointer.next = null;
            this.length--;
        }
        return res;
    }

    public int popAt(int index) {
        if (index >= length || index < 0) return -1;
        if (index == length - 1) return pop();
        Node node = stackHead.next;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        int res = node.val[--node.size];
        if (node.size == 0) {
            node.pre.next = node.next;
            node.next.pre = node.pre;
            this.length--;
        }
        return res;
    }

    static class Node {
        int size = 0;
        int[] val;
        Node pre;
        Node next;

        public Node(int[] val) {
            this.val = val;
        }

        public Node(int[] val, Node pre) {
            this.val = val;
            this.pre = pre;
        }
    }
}
```

### [04. 化栈为队](https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/)

实现一个MyQueue类，该类用两个栈来实现一个队列。


示例：

> MyQueue queue = new MyQueue();
>
> queue.push(1);
> queue.push(2);
> queue.peek();  // 返回 1
> queue.pop();   // 返回 1
> queue.empty(); // 返回 false

```java
package com.yubin.part03;

import java.util.LinkedList;

/**
 * @author MIIAMOR
 * @date 2021/6/26 11:06
 * easy
 */
public class MyQueue {
    /**
     * 基于链表实现的队列
     */
    private final Node head;
    private final Node tail;
    private int size;

    /**
     * Initialize your data structure here.
     */
    public MyQueue() {
        size = 0;
        head = new Node(0);
        tail = new Node(0);
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        if (head.next == null) {
            head.next = new Node(x);
            tail.next = head.next;
        } else {
            tail.next.next = new Node(x);
            tail.next = tail.next.next;
        }
        size++;
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
        if (head.next == null) return Integer.MAX_VALUE;
        int val = head.next.val;
        head.next = head.next.next;
        if (head.next == null) tail.next = null;
        size--;
        return val;
    }

    /**
     * Get the front element.
     */
    public int peek() {
        if (head.next == null) return Integer.MAX_VALUE;
        return head.next.val;
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        return size == 0;
    }

    static class Node {
        int val;
        Node next;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    public static void main(String[] args) {
        MyQueue q = new MyQueue();
        q.push(1);
        q.push(2);
        System.out.println(q.pop());
        System.out.println(q.peek());
    }
}

class MyQueue2 {
    /**
     * 基于数组实现的队列
     */
    private int[] val;
    private int head, tail, size;
    private int capacity = 15;

    /**
     * Initialize your data structure here.
     */
    public MyQueue2() {
        size = 0;
        head = 0;
        tail = 0;
        val = new int[capacity];
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        tail = (tail + 1) % capacity;
        if (tail == head) resize();
        val[tail] = x;
        size++;
    }

    private void resize() {
        int[] newVal = new int[capacity * 2];
        for (int i = 1; i < capacity; i++) {
            newVal[i] = val[(++head) % capacity];
        }
        val = newVal;
        head = 0;
        tail = capacity;
        capacity = 2 * capacity;
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
        size--;
        head = (head + 1) % capacity;
        return val[head];
    }

    /**
     * Get the front element.
     */
    public int peek() {
        return val[(head + 1) % capacity];
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        return size == 0;
    }
}

/**
 * 利用双栈实现队列
 */
class MyQueue3 {
    private final LinkedList<Integer> inStack;
    private final LinkedList<Integer> outStack;

    /**
     * Initialize your data structure here.
     */
    public MyQueue3() {
        inStack = new LinkedList<>();
        outStack = new LinkedList<>();
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        inStack.push(x);
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
        inToOut();
        return outStack.pop();
    }

    /**
     * Get the front element.
     */
    public int peek() {
        inToOut();
        return outStack.peek();
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    private void inToOut() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty())
                outStack.push(inStack.pop());
        }
    }
}
```

### [05. 栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)

栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。

示例1:

>  输入：
> ["SortedStack", "push", "push", "peek", "pop", "peek"]
> [[], [1], [2], [], [], []]
>  输出：
> [null,null,null,1,null,2]

```java
package com.yubin.part03;

import java.util.PriorityQueue;
import java.util.Stack;

/**
 * @author MIIAMOR
 * @date 2021/6/26 13:26
 * medium
 */
public class SortedStack {
    private final Stack<Integer> data;
    private final Stack<Integer> help;

    public SortedStack() {
        data = new Stack<>();
        help = new Stack<>();
    }

    public void push(int val) {
        if (data.isEmpty()) {
            data.push(val);
        } else {
            while (!data.isEmpty() && data.peek() < val) {
                help.push(data.pop());
            }
            data.push(val);
            while (!help.isEmpty()) {
                data.push(help.pop());
            }
        }
    }

    public void pop() {
        if (!isEmpty())
            data.pop();
    }

    public int peek() {
        if (!isEmpty())
            return data.peek();
        return -1;
    }

    public boolean isEmpty() {
        return data.isEmpty();
    }
}

class SortedStack1 {
    private PriorityQueue<Integer> queue;

    public SortedStack1() {
        queue = new PriorityQueue<>();
    }

    public void push(int val) {
        queue.add(val);
    }

    public void pop() {
        if (!isEmpty())
            queue.poll();
    }

    public int peek() {
        if (!isEmpty())
            return queue.peek();
        return -1;
    }

    public boolean isEmpty() {
        return queue.isEmpty();
    }
}
```

### [06. 动物收容所](https://leetcode-cn.com/problems/animal-shelter-lcci/)

动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。

enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。

dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。

示例1:

>  输入：
> ["AnimalShelf", "enqueue", "enqueue", "dequeueCat", "dequeueDog", "dequeueAny"]
> [[], [[0, 0]], [[1, 0]], [], [], []]
>  输出：
> [null,null,null,[0,0],[-1,-1],[1,0]]

```java
package com.yubin.part03;

import java.util.LinkedList;

/**
 * @author MIIAMOR
 * @date 2021/6/26 18:50
 * easy
 */
public class AnimalShelf {
    private LinkedList<int[]> animals;

    public AnimalShelf() {
        animals = new LinkedList<>();
    }

    public void enqueue(int[] animal) {
        animals.addLast(animal);
    }

    public int[] dequeueAny() {
        if (animals.isEmpty()) return new int[]{-1, -1};
        return animals.removeFirst();
    }

    public int[] dequeueDog() {
        if (animals.isEmpty()) return new int[]{-1, -1};
        for (int[] animal : animals) {
            if (animal[1] == 1) {
                animals.remove(animal);
                return animal;
            }
        }
        return new int[]{-1, -1};
    }

    public int[] dequeueCat() {
        if (animals.isEmpty()) return new int[]{-1, -1};
        for (int[] animal : animals) {
            if (animal[1] == 0) {
                animals.remove(animal);
                return animal;
            }
        }
        return new int[]{-1, -1};
    }
}
```

## part04：树与图

### [01. 节点间通路](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

示例1:

>  输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
>  输出：true

```java
package com.yubin.part04;

import java.util.Arrays;
import java.util.LinkedList;

/**
 * @author MIIAMOR
 * @date 2021/6/26 19:08
 * medium
 */
public class FindWhetherExistsPath {
    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {
        if (n == 0 || graph == null) return false;
//        return findWhetherExistsPath1(n, graph, start, target);
//        return findWhetherExistsPath2(n, graph, start, target);
        return findWhetherExistsPath3(n, graph, start, target);
//        return findWhetherExistsPath4(n, graph, start, target);
//        return findWhetherExistsPath5(n, graph, start, target);
//        return findWhetherExistsPath6(n, graph, start, target);
    }

    /**
     * 根据起点求，有向边在数组中的下标
     */
    private int[][] getIndex(int n, int start, int[][] graph) {
        int[][] index = new int[n][2];
        for (int i = 0; i < n; i++) {
            index[i][0] = index[i][1] = -1;
        }
        int pre = graph[0][0], count = 0;
        index[graph[0][0]][0] = 0;
        for (int i = 0; i < graph.length; i++) {
            if (graph[i][0] == pre) count++;
            else {
                index[pre][1] = index[pre][0] + count - 1;
                pre = graph[i][0];
                index[pre][0] = i;
                count = 1;
            }
        }
        index[pre][1] = index[pre][0] + count - 1;
        return index;
    }

    /**
     * -------------------------------------------------------------------------------------------------------------------------
     * 记录每个起点的有向边的索引
     */
    public boolean findWhetherExistsPath1(int n, int[][] graph, int start, int target) {
        boolean[] visited = new boolean[n];
        Arrays.sort(graph, (array1, array2) -> {
            if (array1[0] > array2[0]) return 1;
            else if (array1[0] < array2[0]) return -1;
            else return array1[1] - array2[1];
        });
        int[][] index = getIndex(n, start, graph);
        return dfs(start, visited, index, graph, target);
    }

    private boolean dfs(int start, boolean[] visited, int[][] index, int[][] graph, int target) {
        if (start == target) return true;
        if (index[start][1] == -1) return false;
        visited[start] = true;
        for (int i = index[start][0]; i <= index[start][1]; i++) {
            if (!visited[graph[i][1]])
                if (dfs(graph[i][1], visited, index, graph, target)) return true;
        }
        visited[start] = false;
        return false;
    }

    /**
     * 学习的提交第一那个大佬的
     * -------------------------------------------------------------------------------------------------------------------------
     * 为了知道能不能到达target，那么就需要知道可以可以到达target的前面那个点
     */
    public boolean findWhetherExistsPath2(int n, int[][] graph, int start, int target) {
        boolean[] visited = new boolean[n];
        return dfsFrontToBack(graph, visited, start, target);
    }

    private boolean dfsBackToFront(int[][] graph, boolean[] visited, int start, int target) {
        if (start == target) return true;
        visited[target] = true;
        for (int[] edge : graph) {
            if (edge[1] == target && !visited[edge[0]])
                if (dfsBackToFront(graph, visited, start, edge[0])) return true;
        }
        visited[target] = false;
        return false;
    }

    public boolean findWhetherExistsPath3(int n, int[][] graph, int start, int target) {
        boolean[] visited = new boolean[n];
        return dfsBackToFront(graph, visited, start, target);
    }

    private boolean dfsFrontToBack(int[][] graph, boolean[] visited, int start, int target) {
        if (start == target) return true;
        visited[start] = true;
        for (int[] edge : graph) {
            if (edge[0] == start && !visited[edge[1]])
                if (dfsBackToFront(graph, visited, edge[1], target)) return true;
        }
        visited[start] = false;
        return false;
    }

    /**
     * -------------------------------------------------------------------------------------------------------------------------
     * 广度优先搜索解题(事先对edge们排好序)
     */
    public boolean findWhetherExistsPath5(int n, int[][] graph, int start, int target) {
        boolean[] visited = new boolean[n];
        Arrays.sort(graph, (array1, array2) -> {
            if (array1[0] > array2[0]) return 1;
            else if (array1[0] < array2[0]) return -1;
            else return array1[1] - array2[1];
        });
        int[][] index = getIndex(n, start, graph);
        LinkedList<Integer> point = new LinkedList<>();
        point.add(start);
        visited[start] = true;
        while (true) {
            int size = point.size();
            if (size == 0) return false;
            for (int i = 0; i < size; i++) {
                int edge = point.removeFirst();
                if (index[edge][0] == -1) continue;
                for (int k = index[edge][0]; k <= index[edge][1]; k++) {
                    int next = graph[k][1];
                    if (!visited[next]) {
                        if (next == target) return true;
                        point.addLast(next);
                    }
                }
            }
        }
    }

    /**
     * -------------------------------------------------------------------------------------------------------------------------
     * 广度优先搜索解题(不排序):超时
     */
    public boolean findWhetherExistsPath4(int n, int[][] graph, int start, int target) {
        boolean[] visited = new boolean[n];
        LinkedList<Integer> point = new LinkedList<>();
        point.add(start);
        visited[start] = true;
        while (true) {
            int size = point.size();
            if (size == 0) return false;
            for (int i = 0; i < size; i++) {
                int edgePre = point.removeFirst();
                for (int[] edge : graph) {
                    if (edgePre == edge[0] && !visited[edge[1]]) {
                        if (edge[1] == target) return true;
                        point.addLast(edge[1]);
                    }
                }
            }
        }
    }

    /**
     * -------------------------------------------------------------------------------------------------------------------------
     * 邻接矩阵 内存超了
     */
    private int[][] matrix;

    public boolean findWhetherExistsPath6(int n, int[][] graph, int start, int target) {
        boolean[] visited = new boolean[n];
        matrix = new int[n][n];
        for (int[] index : graph) {
            if (matrix[index[0]][index[1]] == 0)
                matrix[index[0]][index[1]] = 1;
        }
        return backtracking(start, target, visited);
    }

    /**
     * 使用回溯算法寻找通路
     */
    private boolean backtracking(int start, int target, boolean[] visited) {
        if (start == target) return true;
        if (!visited[start]) {
            visited[start] = true;
            for (int i = 0; i < matrix[start].length; i++) {
                if (matrix[start][i] == 1) {
                    if (backtracking(i, target, visited)) return true;
                }
            }
            visited[start] = false;
        }
        return false;
    }
}
```

### [02. 最小高度树](https://leetcode-cn.com/problems/minimum-height-tree-lcci/)

给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

/**
 * @author MIIAMOR
 * @date 2021/6/26 21:51
 */
public class SortedArrayToBST {
    public TreeNode sortedArrayToBST(int[] nums) {
        return sortedArrayToBST(nums, 0, nums.length - 1);
    }

    private TreeNode sortedArrayToBST(int[] nums, int left, int right) {
        if (left > right) return null;
        int mid = (right + left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = sortedArrayToBST(nums, left, mid - 1);
        node.right = sortedArrayToBST(nums, mid + 1, right);
        return node;
    }
}
```

### [03. 特定深度节点链表](https://leetcode-cn.com/problems/list-of-depth-lcci/)

给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。

```java
package com.yubin.part04;

import com.yubin.basic.ListNode;
import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.LinkedList;

/**
 * @author MIIAMOR
 * @date 2021/6/26 21:59
 */
public class ListOfDepth {
    public ListNode[] listOfDepth(TreeNode tree) {
        if (tree == null) return null;
        LinkedList<TreeNode> level = new LinkedList<>();
        ArrayList<ListNode> res = new ArrayList<>();
        level.addLast(tree);
        while (true) {
            int size = level.size();
            if (size == 0) break;
            ListNode head = new ListNode(0), listNode = head;
            for (int i = 0; i < size; i++) {
                TreeNode treeNode = level.removeFirst();
                listNode.next = new ListNode(treeNode.val);
                listNode = listNode.next;
                if (treeNode.left != null) level.addLast(treeNode.left);
                if (treeNode.right != null) level.addLast(treeNode.right);
            }
            res.add(head.next);
        }
        ListNode[] ans = new ListNode[res.size()];
        int index = 0;
        for (ListNode listNode : res) {
            ans[index++] = listNode;
        }
        return ans;
    }
}
```

### [04. 检查平衡性](https://leetcode-cn.com/problems/check-balance-lcci/)

实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。

```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

/**
 * @author MIIAMOR
 * @date 2021/6/27 14:20
 */
public class IsBalanced {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return isBalanced(root.left)
                && isBalanced(root.right)
                && (Math.abs(treeHeight(root.left) - treeHeight(root.right)) <= 1);
    }

    private int treeHeight(TreeNode node) {
        if (node == null) return 0;
        return Math.max(treeHeight(node.left), treeHeight(node.right)) + 1;
    }
}
```

### [05. 合法二叉搜索树](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)

实现一个函数，检查一棵二叉树是否为二叉搜索树。

```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

/**
 * @author MIIAMOR
 * @date 2021/6/27 14:32
 */
public class IsValidBST {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean isValidBST(TreeNode root, long min, long max) {
        if (root == null) return true;
        // 这里默认相同的数据可以充当左子树
        return root.val >= min && root.val < max
                && isValidBST(root.left, min, root.val)
                && isValidBST(root.right, root.val, max);
    }
}
```

### [06. 后继者](https://leetcode-cn.com/problems/successor-lcci/)

设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。

如果指定节点没有对应的“下一个”节点，则返回`null`。

```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/27 14:58
 */
public class InorderSuccessor {
    private List<TreeNode> list;

    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        list = new ArrayList<>();
        inorder(root);
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) == p) {
                if (i < list.size() - 1)
                    return list.get(i + 1);
                else return null;
            }
        }
        return null;
    }

    private void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        list.add(root);
        inorder(root.right);
    }

    /**
     * ------------------------------------------------------------------------------------------------------------------
     */
    private int flag;
    private TreeNode res;

    public TreeNode inorderSuccessor1(TreeNode root, TreeNode p) {
        flag = 0;
        inorder(root, p);
        return res;
    }

    private void inorder(TreeNode root, TreeNode p) {
        if (root == null) return;
        if (flag == -1) return;
        inorder(root.left, p);
        if (flag == 1) {
            res = root;
            flag = -1;
            return;
        } else if (flag == 0 && root == p)
            flag = 1;
        inorder(root.right, p);
    }
}
```

### [08. 首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)

设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。



```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

/**
 * @author MIIAMOR
 * @date 2021/6/27 19:45
 */
public class LowestCommonAncestor {

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == p || root == q || root == null) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 两边同时为null的情况，在前两种判断中已经返回了null
        if (left == null) return right;// 左子树既没有P也没有Q,说明在右子树中才能找到
        else if (right == null) return left;// 右子树既没有P也没有Q,说明在左子树中才能找到
        else return root;// 右子树找到一个，左子树找到一个，说明最近的公共节点就是root
    }

    /**
     * -------------------------------------------------------------------------------------------------------------
     */
    private boolean flag;
    private TreeNode p, q, res;

    public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {
        this.p = p;
        this.q = q;
        if (findQ(p)) return p;
        if (findP(q)) return q;
        findPQ(root);
        return res;
    }

    private boolean[] findPQ(TreeNode node) {
        if (node == null || flag) return new boolean[]{false, false};
        if (node == p) return new boolean[]{true, false};
        if (node == q) return new boolean[]{false, true};
        boolean[] left = findPQ(node.left);
        boolean[] right = findPQ(node.right);
        boolean findP = left[0] || right[0];
        boolean findQ = left[1] || right[1];
        if (findQ && findP && !flag) {
            flag = true;
            res = node;
        }
        return new boolean[]{findP, findQ};
    }

    private boolean findP(TreeNode node) {
        if (node == null) return false;
        if (node == p) return true;
        return findP(node.left) ||
                findP(node.right);
    }

    private boolean findQ(TreeNode node) {
        if (node == null) return false;
        if (node == q) return true;
        return findQ(node.left) ||
                findQ(node.right);
    }
}
```

### [09. 二叉搜索树序列](https://leetcode-cn.com/problems/bst-sequences-lcci/)（非自己解题）

从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。

 [解题思路来源](https://leetcode-cn.com/problems/bst-sequences-lcci/solution/pei-tu-hui-su-mo-ban-xiang-xi-zhu-shi-by-dong-men/)

```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/27 22:05
 */
public class BSTSequencesClass {
    /**
     * https://leetcode-cn.com/problems/bst-sequences-lcci/solution/pei-tu-hui-su-mo-ban-xiang-xi-zhu-shi-by-dong-men/
     * --------------------------------------------------------------------------------------------------------
     */
    private LinkedList<Integer> list;// 存放可能的路径
    private LinkedList<TreeNode> rest;// 存放在当前已知部分路径的情况下还可以选择的节点
    private List<List<Integer>> res;// 最终结果

    public List<List<Integer>> BSTSequences(TreeNode root) {
        list = new LinkedList<>();
        res = new ArrayList<>();
        rest = new LinkedList<>();
        if (root == null) {
            res.add(new LinkedList<>());
            return res;
        }
        rest.addLast(root);
        backtracking();
        return res;
    }

    private void backtracking() {
        int size = rest.size();
        if (size == 0) {
            res.add(new LinkedList<>(list));
            return;
        }
        for (int i = 0; i < size; i++) {
            TreeNode node = rest.removeFirst();
            list.addLast(node.val);
            int count = 0;
            if (node.left != null) {
                rest.addLast(node.left);
                count++;
            }
            if (node.right != null) {
                rest.addLast(node.right);
                count++;
            }
            backtracking();
            for (int j = 0; j < count; j++) {
                rest.removeLast();
            }
            list.removeLast();
            rest.addLast(node);
        }
    }
}
```

### [10. 检查子树](https://leetcode-cn.com/problems/check-subtree-lcci/)

检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。

如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。

注意：此题相对书上原题略有改动。

```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

/**
 * @author MIIAMOR
 * @date 2021/6/28 11:28
 */
public class CheckSubTree {
    public boolean checkSubTree(TreeNode t1, TreeNode t2) {
        return findTree(t1, t2);
    }

    private boolean findTree(TreeNode root, TreeNode target) {
        if (root == target) return true;
        if (root == null) return false;
        if (root.val == target.val && checkTree(root, target)) return true;
        return findTree(root.left, target) || findTree(root.right, target);
    }

    private boolean checkTree(TreeNode t1, TreeNode t2) {
        if (t1 == t2) return true;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        return checkTree(t1.left, t2.left) && checkTree(t1.right, t2.right);
    }
}
```

### [12. 求和路径](https://leetcode-cn.com/problems/paths-with-sum-lcci/)

给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。

```java
package com.yubin.part04;

import com.yubin.basic.TreeNode;

import java.util.*;

/**
 * @author MIIAMOR
 * @date 2021/6/28 12:08
 */
public class PathSum {
    private int res;

    public int pathSum(TreeNode root, int sum) {
        return pathSum1(root, sum);
//        return pathSum2(root, sum);
//        return pathSum3(root, sum);
    }

    public int pathSum1(TreeNode root, int sum) {
        res = 0;
        dfs(root, sum);
        return res;
    }

    private void dfs(TreeNode root, int sum) {
        if (root == null) return;
        getSum(root, 0, sum);
        dfs(root.left, sum);
        dfs(root.right, sum);
    }

    private void getSum(TreeNode node, int currSum, int sum) {
        if (node == null) return;
        currSum += node.val;
        if (currSum == sum) res++;
        getSum(node.left, currSum, sum);
        getSum(node.right, currSum, sum);
    }

    /**
     * 记忆化搜索
     */
    public int pathSum2(TreeNode root, int sum) {
        res = 0;
        getSum(root, sum);
        return res;
    }

    private List<Integer> getSum(TreeNode node, int sum) {
        if (node == null) return new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        List<Integer> left = getSum(node.left, sum);
        List<Integer> right = getSum(node.right, sum);
        for (Integer i : left) {
            list.add(i + node.val);
            if (i + node.val == sum) res++;
        }
        for (Integer i : right) {
            list.add(i + node.val);
            if (i + node.val == sum) res++;
        }
        list.add(node.val);
        if (node.val == sum) res++;
        return list;
    }

    /**
     * 记忆化搜索
     */
    private Map<TreeNode, List<Integer>> record;// 用记录节点为起始点可能计算出的路径和

    public int pathSum3(TreeNode root, int sum) {
        record = new HashMap<>();
        record.put(null, new ArrayList<>());
        res = 0;
        backtracking(root, sum);
        return res;
    }

    private void backtracking(TreeNode node, int sum) {
        if (node == null) return;
        backtracking(node.left, sum);
        backtracking(node.right, sum);
        getSum(node);
        List<Integer> list = record.get(node);
        for (Integer currSum : list) {
            if (currSum == sum) res++;
        }
    }

    private void getSum(TreeNode node) {
        List<Integer> list = new ArrayList<>();
        List<Integer> left = record.get(node.left);
        List<Integer> right = record.get(node.right);
        for (Integer i : left) {
            list.add(i + node.val);
        }
        for (Integer i : right) {
            list.add(i + node.val);
        }
        list.add(node.val);
        record.put(node, list);
    }
}
```

## part05：位运算

### [01. 插入](https://leetcode-cn.com/problems/insert-into-bits-lcci/)

给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i <= j，且从 0 位开始计算）。

编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。



题目保证从 i 位到 j 位足以容纳 M， 例如： M = 10011，则 i～j 区域至少可容纳 5 位。

 

示例1:

>  输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6
>  输出：N = 1100(10001001100)

```java
package com.yubin.part05;

/**
 * @author MIIAMOR
 * @date 2021/6/28 13:39
 */
public class InsertBits {
    public int insertBits(int N, int M, int i, int j) {
        // N的i-j位置0
        for (int x = i; x <= j; x++) {
            int base = (1 << x);
            if ((N & base) == base) N -= base;
        }
        // 加上M
        return N + (M << i);
    }
}
```

### [02. 二进制数转字符串](https://leetcode-cn.com/problems/bianry-number-to-string-lcci/)

二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。

示例1:

>  输入：0.625
>  输出："0.101"

```java
package com.yubin.part05;

/**
 * @author MIIAMOR
 * @date 2021/6/28 14:31
 */
public class PrintBin {
    /**
     * 十进制小数转二进制：乘基取整法
     */
    public String printBin(double num) {
        StringBuilder sb = new StringBuilder();
        sb.append("0.");
        int count = 0;
        while (num != 0) {
            num *= 2;
            int head = (int) num;
            sb.append(head);
            num -= head;
            count++;
            if (count >= 30) return "ERROR";
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        System.out.println(new PrintBin().printBin(0.625));
    }
}
```

### [03. 翻转数位](https://leetcode-cn.com/problems/reverse-bits-lcci/)

给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。

示例 1：

> 输入: num = 1775(110111011112)
> 输出: 8

[解法参考](https://leetcode-cn.com/problems/reverse-bits-lcci/solution/ji-lu-shang-yi-ge-0de-wei-zhi-lei-si-yu-c6lxp/)相似题目->https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

```java
package com.yubin.part05;

/**
 * @author MIIAMOR
 * @date 2021/6/28 14:41
 */
public class ReverseBits {
    /**
     * 模拟所有0都变成1的情况
     */
    public int reverseBits(int num) {
        // 最终结果 上一个0的位置(索引从0开始，lastZero默认为-1开始) 记录当前连续的1的长度
        int res = 0, lastZero = -1, curr = 0;
        for (int i = 0; i < 32; i++) {
            int bit = num & (1 << i);
            if (bit == 0) {
                // 如果遇到了0，那么假设把这个0变为1，则已知连续的1长度应该是这个0到上一个0的距离
                // curr在遇到0的时候会更新自己的长度
                curr = i - lastZero;
                // 由于每次只能让一个0变为1，因此在往后遍历的时候，需要把这个位置默认为0
                lastZero = i;
            } else {
                // 如果遇到了1，curr计数+1
                curr++;
            }
            res = Math.max(res, curr);
        }
        return res;
    }
}
```

### [*04. 下一个数](https://leetcode-cn.com/problems/closed-number-lcci/)

下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。

示例1:

>  输入：num = 2（或者0b10）
>  输出：[4, 1] 或者（[0b100, 0b1]）

```java
package com.yubin.part05;

/**
 * @author MIIAMOR
 * @date 2021/6/28 22:25
 */
public class FindClosedNumbers {
    public int[] findClosedNumbers(int num) {
        return findClosedNumbers1(num);
    }

    /**
     * 暴力枚举
     */
    public int[] findClosedNumbers1(int num) {
        if (num <= 0 || num >= Integer.MAX_VALUE) return new int[]{-1, -1};
        int count = countOnes(num);
        int big = num + 1, small = num - 1;
        while (big < Integer.MAX_VALUE && countOnes(big) != count)
            big++;
        while (small > 0 && countOnes(small) != count)
            small--;
        big = big == Integer.MAX_VALUE ? -1 : big;
        small = small == 0 ? -1 : small;
        return new int[]{big, small};
    }

    private int countOnes(int num) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            if ((num & (1 << i)) != 0) count++;
        }
        return count;
    }
}
```

### [06. 整数转换](https://leetcode-cn.com/problems/convert-integer-lcci/)

整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。

示例1:

>  输入：A = 29 （或者0b11101）, B = 15（或者0b01111）
>  输出：2

```java
package com.yubin.part05;

/**
 * @author MIIAMOR
 * @date 2021/6/28 22:25
 */
public class FindClosedNumbers {
    public int[] findClosedNumbers(int num) {
//        return findClosedNumbers1(num);
        return findClosedNumbers2(num);
    }

    /**
     * 暴力枚举
     */
    public int[] findClosedNumbers1(int num) {
        if (num <= 0 || num >= Integer.MAX_VALUE) return new int[]{-1, -1};
        int count = countOnes(num);
        int big = num + 1, small = num - 1;
        while (big < Integer.MAX_VALUE && countOnes(big) != count)
            big++;
        while (small > 0 && countOnes(small) != count)
            small--;
        big = big == Integer.MAX_VALUE ? -1 : big;
        small = small == 0 ? -1 : small;
        return new int[]{big, small};
    }

    private int countOnes(int num) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            if ((num & (1 << i)) != 0) count++;
        }
        return count;
    }

    /**
     * 比 num 大的数：从右往左，找到第一个 01 位置，然后把 01 转为 10，右侧剩下的 1 移到右侧的低位，右侧剩下的位清0。
     * 比 num 小的数：从右往左，找到第一个 10 位置，然后把 10 转为 01，右侧剩下的 1 移到右侧的高位，右侧剩下的位置0。
     * <p>
     * 常规上，低位在右侧，bitset 注意方向相反
     * https://leetcode-cn.com/problems/closed-number-lcci/solution/wei-yun-suan-by-wushaoling-2/
     */
    public int[] findClosedNumbers2(int num) {
        int count = 0;// 记录1的数量
        int big = -1, small = -1;
        int numTmp = num;
        for (int i = 0; i < 30; i++) {
            // 遇到01，把他变为10，并且把右侧的1放到最右边
            if ((num & (1 << i)) != 0 && (num & (1 << i + 1)) == 0) {
                numTmp += (1 << i + 1);
                numTmp -= (1 << i);
                for (int j = 0; j < count; j++) {
                    numTmp += (1 << j);
                }
                big = numTmp;
                break;
            }
            if ((num & (1 << i)) != 0) count++;
            numTmp &= (~(1 << i));
        }
        numTmp = num;
        count = 0;
        for (int i = 0; i < 30; i++) {
            // 遇到10，把他变为01，并且把右侧的1放到最右边
            if ((num & (1 << i)) == 0 && (num & (1 << i + 1)) != 0) {
                numTmp -= (1 << i + 1);
                numTmp += (1 << i);
                for (int j = 0; j < count; j++) {
                    numTmp += (1 << i - j - 1);
                }
                small = numTmp;
                break;
            }
            if ((num & (1 << i)) != 0) count++;
            numTmp &= (~(1 << i));
        }
        return new int[]{big, small};
    }

    public static void main(String[] args) {
        new FindClosedNumbers().findClosedNumbers(67);
    }
}
```

### [07. 配对交换](https://leetcode-cn.com/problems/exchange-lcci/)

配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。

示例1:

>  输入：num = 2（或者0b10）
>  输出 1 (或者 0b01)

```java
package com.yubin.part05;

/**
 * @author MIIAMOR
 * @date 2021/6/28 23:40
 */
public class ExchangeBits {
    public int exchangeBits(int num) {
        for (int i = 0; i < 32; i += 2) {
            boolean test1 = test(num, i), test2 = test(num, i + 1);
            if (test1 == test2) continue;
            int base1 = 1 << i, base2 = 1 << (i + 1);
            if (test1) {
                num -= base1;
                num += base2;
            } else {
                num += base1;
                num -= base2;
            }
        }
        return num;
    }

    private boolean test(int num, int base) {
        return (num & (1 << base)) != 0;
    }
}
```

### [08. 绘制直线](https://leetcode-cn.com/problems/draw-line-lcci/)

绘制直线。有个单色屏幕存储在一个一维数组中，使得32个连续像素可以存放在一个 int 里。屏幕宽度为w，且w可被32整除（即一个 int 不会分布在两行上），屏幕高度可由数组长度及屏幕宽度推算得出。请实现一个函数，绘制从点(x1, y)到点(x2, y)的水平线。

给出数组的长度 length，宽度 w（以比特为单位）、直线开始位置 x1（比特为单位）、直线结束位置 x2（比特为单位）、直线所在行数 y。返回绘制过后的数组。

示例1:

>  输入：length = 1, w = 32, x1 = 30, x2 = 31, y = 0
>  输出：[3]
>  说明：在第0行的第30位到第31为画一条直线，屏幕表示为[0b000000000000000000000000000000011]

```java
package com.yubin.part05;

/**
 * @author MIIAMOR
 * @date 2021/6/29 12:38
 */
public class DrawLine {
    public int[] drawLine(int length, int w, int x1, int x2, int y) {
        int[] res = new int[length];// 结果
        int wNum = w / 32;
        int x1Pos = x1 / 32 + y * wNum, x2Pos = x2 / 32 + y * wNum;// x1和x2两个点所在的索引
        // 边界处理
        if (x1Pos != x2Pos) {
            for (int i = 0; i < 32 - x1 % 32; i++) {
                res[x1Pos] |= (1 << i);
            }
            for (int i = 0; i <= x2 % 32; i++) {
                res[x2Pos] += (1 << 32 - i - 1);
            }
        } else {
            for (int i = 31 - x2 % 32; i <= 31 - x1 % 32; i++) {
                res[x1Pos] |= (1 << i);
            }
        }
        // 中间部分处理
        for (int i = x1Pos + 1; i < x2Pos; i++) {
            res[i] = -1;
        }
        return res;
    }
}
```

## part08：算法1（动态规划、递归）

### [01. 三步问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

示例1:

>  输入：n = 3 
>  输出：4
>  说明: 有四种走法

```java
package com.yubin.part08;

/**
 * @author MIIAMOR
 * @date 2021/6/29 21:38
 */
public class WaysToStep {
    /**
     * 动态规划：
     * 当要达到第n阶梯的时候，可以从n-3走3步，n-2走2步或者n-1走一步三种方式
     * 所以f(n) = f(n-1) + f(n-2) + f(n-3)
     */
    public int waysToStep(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (n == 3) return 4;
        int step1 = 1, step2 = 2, step3 = 4;
        int nextStep = 0;
        int mod = 1000000007;
        for (int i = 4; i <= n; i++) {
            nextStep = step1 + step2;
            if (nextStep >= mod) nextStep -= mod;
            nextStep += step3;
            if (nextStep >= mod) nextStep -= mod;
            step1 = step2;
            step2 = step3;
            step3 = nextStep;
        }
        return nextStep;
    }
}
```

### [02. 迷路的机器人](https://leetcode-cn.com/problems/robot-in-a-grid-lcci/)

设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。



网格中的障碍物和空位置分别用 1 和 0 来表示。

返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

示例 1:

> 输入:
> [
>   [0,0,0],
>   [0,1,0],
>   [0,0,0]
> ]
> 输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
> 解释: 
> 输入中标粗的位置即为输出表示的路径，即
> 0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）

```java
package com.yubin.part08;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/29 22:03
 */
public class PathWithObstacles {
    // 记录矩阵的宽高
    private int m, n;

    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {
//        return pathWithObstacles1(obstacleGrid);
        return pathWithObstacles2(obstacleGrid);
    }

    /**
     * 动态规划后逆序求解
     */
    public List<List<Integer>> pathWithObstacles1(int[][] obstacleGrid) {
        res = new ArrayList<>();
        if (obstacleGrid == null) return res;
        m = obstacleGrid.length;
        n = obstacleGrid[0].length;
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return res;
        int bound = m + n + 10;
        int[][] dp = new int[m][n];// 可以到达的位置都是0.不能到达的位置是1
        for (int i = 1; i < m; i++) {
            if (dp[i - 1][0] == bound) dp[i][0] = bound;
            else if (obstacleGrid[i][0] == 1) dp[i][0] = bound;
            else dp[i][0] = dp[i - 1][0] + 1;
        }
        for (int i = 1; i < n; i++) {
            if (dp[0][i - 1] == bound) dp[0][i] = bound;
            else if (obstacleGrid[0][i] == 1) dp[0][i] = bound;
            else dp[0][i] = dp[0][i - 1] + 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) dp[i][j] = bound;
                else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;
            }
        }
        if (dp[m - 1][n - 1] >= bound) return res;
        int i = m - 1, j = n - 1;
        while (i != 0 || j != 0) {
            ArrayList<Integer> l = new ArrayList<>();
            l.add(i);
            l.add(j);
            res.add(0, l);
            if (j == 0 || (i > 0 && dp[i - 1][j] == dp[i][j] - 1)) {
                i--;
                continue;
            }
            if (i == 0 || dp[i][j - 1] == dp[i][j] - 1) j--;
        }
        ArrayList<Integer> l = new ArrayList<>();
        l.add(0);
        l.add(0);
        res.add(0, l);
        return res;
    }

    // dfs搜索
    private ArrayList<List<Integer>> res;
    private boolean find;
    private boolean[][] visited;

    private void dfs(int[][] obstacleGrid, int i, int j) {
        if (obstacleGrid[i][j] == 1) return;
        if (i == m - 1 && j == n - 1) find = true;
        List<Integer> l = new ArrayList<>();
        l.add(i);
        l.add(j);
        res.add(l);
        visited[i][j] = true;
        if (i + 1 < m && !visited[i + 1][j]) dfs(obstacleGrid, i + 1, j);
        if (find) return;
        if (j + 1 < n && !visited[i][j + 1]) dfs(obstacleGrid, i, j + 1);
        if (find) return;
        res.remove(res.size() - 1);
    }

    /**
     * 直接dfs
     */
    public List<List<Integer>> pathWithObstacles2(int[][] obstacleGrid) {
        res = new ArrayList<>();
        if (obstacleGrid == null) return res;
        m = obstacleGrid.length;
        n = obstacleGrid[0].length;
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return res;
        find = false;
        visited = new boolean[m][n];
        dfs(obstacleGrid, 0, 0);
        return res;
    }
}
```

### [03. 魔术索引](https://leetcode-cn.com/problems/magic-index-lcci/)

魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

示例1:

>  输入：nums = [0, 2, 3, 4, 5]
>  输出：0
>  说明: 0下标的元素为0

```java
package com.yubin.part08;

/**
 * @author MIIAMOR
 * @date 2021/6/29 23:57
 */
public class FindMagicIndex {
    public int findMagicIndex(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (i == nums[i]) return i;
        }
        return -1;
    }
}
```

### [04. 幂集](https://leetcode-cn.com/problems/power-set-lcci/)

幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。

示例:

>  输入： nums = [1,2,3]
>  输出：
> [
>   [3],
>   [1],
>   [2],
>   [1,2,3],
>   [1,3],
>   [2,3],
>   [1,2],
>   []
> ]

```java
package com.yubin.part08;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/30 10:44
 */
public class Subsets {
    public List<List<Integer>> subsets(int[] nums) {
//        return subsets1(nums);
        return subsets2(nums);
    }

    /**
     * 方案1：dfs搜索
     */
    private List<List<Integer>> res;
    private List<Integer> list;

    private List<List<Integer>> subsets1(int[] nums) {
        res = new ArrayList<>();
        list = new ArrayList<>();
        dfs(nums, 0);
        return res;
    }

    private void dfs(int[] nums, int index) {
        res.add(new ArrayList<>(list));
        for (int i = index; i < nums.length; i++) {
            list.add(nums[i]);
            dfs(nums, i + 1);
            list.remove(list.size() - 1);
        }
    }

    /**
     * 方案2，动态规划算法
     */
    private List<List<Integer>> subsets2(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<>());
        for (int num : nums) {
            int size = res.size();
            for (int i = 0; i < size; i++) {
                List<Integer> list = new ArrayList<>(res.get(i));
                list.add(num);
                res.add(list);
            }
        }
        return res;
    }
}
```

### [05. 递归乘法](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。

示例1:

>  输入：A = 1, B = 10
>  输出：10

```java
package com.yubin.part08;

/**
 * @author MIIAMOR
 * @date 2021/6/30 11:11
 */
public class Multiply {
    public int multiply(int A, int B) {
        // 符号判断
        int sign = -1;
        if ((A > 0 && B > 0) || (A < 0 && B < 0)) sign = 1;
        int small = Math.min(Math.abs(A), Math.abs(B));
        int big = Math.max(Math.abs(A), Math.abs(B));

        return multiply1(small, big) * sign;
//        return multiply2(small, big) * sign;
    }

    /**
     * 直接相加法
     */
    public int multiply1(int A, int B) {
        int res = 0;
        for (int i = 0; i < A; i++) {
            res += B;
        }
        return res;
    }

    /**
     * 递归求解
     */
    public int multiply2(int A, int B) {
        if (A == 0) return 0;
        return B + multiply2(A - 1, B);
    }
}
```

### [06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

[汉诺塔递归](https://www.zhihu.com/question/24385418)

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

示例1:

>  输入：A = [2, 1, 0], B = [], C = []
>  输出：C = [2, 1, 0]

```java
package com.yubin.part08;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/30 11:28
 */
public class Hanota {
    /**
     * A为起点，B为缓冲区，C为终点
     * 1：把A上面的n-1个盘子利用C移动到B上
     * 2：把A剩余的盘子移动到C上
     * 3：把B上面的n-1个盘子以相同的方式以A为缓冲区移动到C
     */
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        // 作弊试一试
        // C.addAll(A);
        // A.clear();
        int len = A.size();
        move(len - 1, A, B, C);
    }

    private void move(int n, List<Integer> A, List<Integer> B, List<Integer> C) {
        if (n == 0) {
            C.add(A.remove(A.size() - 1));
        } else {
            move(n - 1, A, C, B);
            move(0, A, B, C);
            move(n - 1, B, A, C);
        }
    }

    public static void main(String[] args) {
        move(5, 'A', 'B', 'C');
    }

    private static void move(int n, char A, char B, char C) {
        if (n == 1) System.out.println(A + " --> " + C);
        else {
            move(n - 1, A, C, B);
            move(1, A, B, C);
            move(n - 1, B, A, C);
        }
    }
}
```

### [07. 无重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-i-lcci/)

无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。

示例1:

>  输入：S = "qwe"
>  输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]

```java
package com.yubin.part08;

/**
 * @author MIIAMOR
 * @date 2021/6/30 14:13
 */
public class Permutation {
    private char[] chars;
    private StringBuilder sb;
    private boolean[] visited;
    private int len, index;
    private String[] res;

    public String[] permutation(String S) {
        chars = S.toCharArray();
        len = chars.length;
        index = 0;
        visited = new boolean[len];
        sb = new StringBuilder();
        res = new String[getLen(len)];
        backtracking(0);
        return res;
    }

    private int getLen(int n) {
        if (n == 1) return 1;
        return getLen(n - 1) * n;
    }

    private void backtracking(int currLen) {
        if (currLen == len) {
            res[index++] = sb.toString();
            return;
        }
        for (int i = 0; i < len; i++) {
            if (!visited[i]) {
                visited[i] = true;
                sb.append(chars[i]);
                backtracking(currLen + 1);
                sb.deleteCharAt(sb.length() - 1);
                visited[i] = false;
            }
        }
    }
}
```

### [08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

>  输入：S = "qqe"
>  输出：["eqq","qeq","qqe"]

```java
package com.yubin.part08;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * @author MIIAMOR
 * @date 2021/6/30 16:01
 */
public class Permutation2 {
    public String[] permutation(String S) {
        char[] chars = S.toCharArray();
        Arrays.sort(chars);
        StringBuilder sb = new StringBuilder();
        ArrayList<String> list = new ArrayList<>();
        int len = chars.length;
        boolean[] visited = new boolean[len];
        backtracking(chars, visited, sb, len, list, 0);
        String[] res = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    private void backtracking(char[] chars, boolean[] visited, StringBuilder sb, int len, ArrayList<String> list, int currLen) {
        if (currLen == len) {
            list.add(sb.toString());
            return;
        }
        for (int i = 0; i < len; i++) {
            if (visited[i]) continue;
            visited[i] = true;
            sb.append(chars[i]);
            backtracking(chars, visited, sb, len, list, currLen + 1);
            sb.deleteCharAt(sb.length() - 1);
            visited[i] = false;
            while (i + 1 < len && (chars[i] == chars[i + 1])) i++;
        }
    }

    public static void main(String[] args) {
        for (String s : new Permutation2().permutation("awake")) {
            System.out.println(s);
        }
    }
}
```

### [09. 括号](https://leetcode-cn.com/problems/bracket-lcci/)

括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。

说明：解集不能包含重复的子集。

例如，给出 n = 3，生成结果为：

> [
>   "((()))",
>   "(()())",
>   "(())()",
>   "()(())",
>   "()()()"
> ]

```java
package com.yubin.part08;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/30 16:26
 */
public class GenerateParenthesis {
    private int status; // 记录括号状态，需要多少个右括号匹配
    private int left, right;// 左括号和右括号剩余的数量

    public List<String> generateParenthesis(int n) {
        StringBuilder sb = new StringBuilder();
        ArrayList<String> res = new ArrayList<>();
        sb.append('(');// 第一个只能是左括号
        left = n - 1;
        right = n;
        status = 1;
        backtracking(res, sb);
        return res;
    }

    private void backtracking(ArrayList<String> res, StringBuilder sb) {
        if (left == 0 && right == 0) {
            res.add(sb.toString());
            return;
        }
        if (status == 0 || left > 0) {
            left--;
            status++;
            sb.append('(');
            backtracking(res, sb);
            sb.deleteCharAt(sb.length() - 1);
            status--;
            left++;
        }
        if (status > 0 && right > 0) {
            right--;
            status--;
            sb.append(')');
            backtracking(res, sb);
            sb.deleteCharAt(sb.length() - 1);
            status++;
            right++;
        }
    }

    public static void main(String[] args) {
        for (String s : new GenerateParenthesis().generateParenthesis(5)) {
            System.out.println(s);
        }
    }
}
```

### [10. 颜色填充](https://leetcode-cn.com/problems/color-fill-lcci/)

编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。

待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的行坐标为 sr 列坐标为 sc。需要填充的新颜色为 newColor 。

「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。

请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。

 

示例：

> 输入：
> image = [[1,1,1],[1,1,0],[1,0,1]] 
> sr = 1, sc = 1, newColor = 2
> 输出：[[2,2,2],[2,2,0],[2,0,1]]
> 解释: 
> 初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。
> 初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。
> 注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。

```java
package com.yubin.part08;

/**
 * @author MIIAMOR
 * @date 2021/6/30 16:26
 */
public class FloodFill {
    private int m, n, preColor, newColor;

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        m = image.length;
        n = image[0].length;
        preColor = image[sr][sc];
        this.newColor = newColor;
        if (preColor == newColor) return image;
        dfs(image, sr, sc);
        return image;
    }

    private void dfs(int[][] image, int sr, int sc) {
        image[sr][sc] = newColor;
        if (sr - 1 >= 0 && image[sr - 1][sc] == preColor) dfs(image, sr - 1, sc);
        if (sc - 1 >= 0 && image[sr][sc - 1] == preColor) dfs(image, sr, sc - 1);
        if (sr + 1 < m && image[sr + 1][sc] == preColor) dfs(image, sr + 1, sc);
        if (sc + 1 < n && image[sr][sc + 1] == preColor) dfs(image, sr, sc + 1);
    }
}
```

### [11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)

硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

示例1:

>  输入: n = 5
>  输出：2
>  解释: 有两种方式可以凑成总金额:
> 5=5
> 5=1+1+1+1+1

```java
package com.yubin.part08;

import java.util.Arrays;

/**
 * @author MIIAMOR
 * @date 2021/6/30 21:23
 */
public class WaysToChange {
    private final int mod = 1000000007;

    public int waysToChange(int n) {
//        return waysToChange1(n);// 超时
//        return waysToChange2(n);// 超时
//        return waysToChange3(n);
        return waysToChange4(n);
    }

    /**
     * 数学解法:试硬币
     */
    public int waysToChange1(int n) {
        int res = 0;
        for (int coin25 = 0; coin25 <= n / 25; coin25++) {
            int ten = n - coin25 * 25;
            for (int coin10 = 0; coin10 <= ten / 10; coin10++) {
                int five = ten - coin10 * 10;
                for (int coin5 = 0; coin5 <= five / 5; coin5++) {
                    res++;
                    if (res >= mod) res -= mod;
                }
            }
        }
        return res;
    }

    /**
     * 数学解法优化循环
     */
    public int waysToChange2(int n) {
        int res = 0;
        for (int coin25 = 0; coin25 <= n / 25; coin25++) {
            int ten = n - coin25 * 25;
            for (int coin10 = 0; coin10 <= ten / 10; coin10++) {
                int five = ten - coin10 * 10;
                res += (five / 5 + 1);// (five / 5 + 1)这个式子的值每次减小2，构成等差数列
                if (res >= mod) res -= mod;
            }
        }
        return res;
    }

    /**
     * 继续优化
     */
    public int waysToChange3(int n) {
        long res = 0;
        for (int coin25 = 0; coin25 <= n / 25; coin25++) {
            int rest = n - coin25 * 25;
            long coin10 = rest / 10 + 1;// 等差数列的项数
            long coin5B = rest % 10 / 5 + 1;// 等差数列的首项
            long coin5E = rest / 5 + 1;// 等差数列的末尾项
            res = (res + (coin5E + coin5B) / 2 * coin10) % mod;
        }
        return (int) res;
    }

    /**
     * 完全背包问题模型
     * 总共有四个物品，其价值分别是1，5，10，25，且体积都是1
     * 1硬币不会影响方案的总数：
     * 当n不能被5整除的时候，那么就只能使用1来填充剩余数量，那么方案数不会增加
     * 比如n=5的时候方案数为2，n在值为6..9的时候，方案数也为2
     * <p>
     * 因此可以简化方式为加入只有三个硬币5，10，25
     * <p>
     * 在dp求解的时候，遵循背包问题的一贯思维：先对物品进行遍历，再去对容量进行遍历
     */
    public int waysToChange4(int n) {
        int[] coins = new int[]{5, 10, 25};
        int coin5 = n / 5;// 这里因为10和25都是5的倍数，索引只需要考虑硬币面值在5之上的硬币
        int[] dp = new int[coin5 + 1];// 避免越界（解题过程中可以选择多分配点空间，避免越界，dp问题的解题一般从1开始计数、
        Arrays.fill(dp, 1);//假设只有一个1分硬币的情况，那么对于每种n，都会只有一种方式
        for (int coin : coins) {
            for (int i = coin / 5; i <= coin5; i++) {
                dp[i] = (dp[i - coin / 5] + dp[i]) % mod;
            }
        }
        return dp[coin5];
    }


    public static void main(String[] args) {
        System.out.println(new WaysToChange().waysToChange(1000));
    }
}
```

### [12. 八皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)

设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。

注意：本题相对原题做了扩展

示例:

>  输入：4
>  输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
>  解释: 4 皇后问题存在如下两个不同的解法。
> [
>  [".Q..",  // 解法 1
>   "...Q",
>   "Q...",
>   "..Q."],
>
>  ["..Q.",  // 解法 2
>   "Q...",
>   "...Q",
>   ".Q.."]
> ]

```java
package com.yubin.part08;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/7/1 13:30
 */
public class SolveNQueens {
    public List<List<String>> solveNQueens(int n) {
        return solveNQueens1(n);
    }

    /**
     * dfs搜索
     */
    // 行标记(可以不需要)、列标记 左斜标记、右斜标记（用于记录对角线）
    private boolean[] cols, obliqueLeft, obliqueRight;
    private char[][] board;// 棋盘
    private int N;// 皇后数量
    private List<List<String>> res;

    private List<List<String>> solveNQueens1(int n) {
        N = n;
        cols = new boolean[n];
        res = new ArrayList<>();
        // 对角线的映射方式
        obliqueLeft = new boolean[2 * n + 1];// 左下到右上对角线 index = i + j
        obliqueRight = new boolean[2 * n + 1];// 左上到右下对角线 index = n - i + j - 1
        board = new char[n][n];
        for (char[] chars : board) {
            Arrays.fill(chars, '.');
        }
        dfs(0);
        return res;
    }

    /**
     * @param row 要在第row行安排皇后
     */
    private void dfs(int row) {
        // 递归出口设置
        if (row == N) {
            List<String> list = new ArrayList<>();
            for (char[] chars : board) {
                list.add(String.valueOf(chars));
            }
            res.add(list);
            return;
        }
        for (int i = 0; i < N; i++) {
            // 当前这个点所在的列 行 和 两个对角线都是有效的
            if (!cols[i] && !obliqueLeft[row + i] && !obliqueRight[N - row + i - 1]) {
                // 把这个点的对应的行列对角线有效性去除
                cols[i] = obliqueLeft[row + i] = obliqueRight[N - row + i - 1] = true;
                board[row][i] = 'Q';
                dfs(row + 1);
                // 恢复状态
                board[row][i] = '.';
                cols[i] = obliqueLeft[row + i] = obliqueRight[N - row + i - 1] = false;
            }
        }
    }
}
```

### [13. 堆箱子](https://leetcode-cn.com/problems/pile-box-lcci/)（非自己解答）

堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。

输入使用数组[wi, di, hi]表示每个箱子。

示例1:

>  输入：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
>  输出：6

```java
package com.yubin.part08;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @author MIIAMOR
 * @date 2021/7/1 19:34
 */
public class PileBox {
    public int pileBox(int[][] box) {
        // 先排序，按宽从小到大
        Arrays.sort(box, Comparator.comparingInt(a -> a[0]));
        int len = box.length;
        int res = 0;// 用于记录最终的结果
        int[] dp = new int[len];// dp[i]表示的是，取第i个箱子作为基的情况下所能达到的最大高度
        for (int i = 0; i < len; i++) {
            dp[i] = box[i][2];// 假设每一种的初始情况都只有一个箱子
            for (int j = 0; j < i; j++) {
                // 对该箱子之前的情况进行遍历，如果这些重叠起来的箱子可以放在新的基的话
                // 则加上当前的箱子的高度
                if (box[j][0] < box[i][0] && box[j][1] < box[i][1] && box[j][2] < box[i][2])// 这里需要严格小于
                    dp[i] = Math.max(dp[i], dp[j] + box[i][2]);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

### [14. 布尔运算](https://leetcode-cn.com/problems/boolean-evaluation-lcci/)(不会，好难)

给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。

示例 1:

> 输入: s = "1^0|0|1", result = 0
>
> 输出: 2
> 解释: 两种可能的括号方法是
> 1^(0|(0|1))
> 1^((0|0)|1)

```java
package com.yubin.part08;

/**
 * @author MIIAMOR
 * @date 2021/7/1 20:45
 */
public class CountEval {
    /**
     * dp[i][j][0]代表第i个字符到第j个字符，result=0的可能性个数
     * <p>
     * dp[i][j][1]代表第i个字符到第j个字符，result=1的可能性个数
     * <p>
     * 链接：https://leetcode-cn.com/problems/boolean-evaluation-lcci/solution/c-qu-jian-dphe-xin-fang-cheng-jian-dan-c-13kh/
     */
    public int countEval(String s, int result) {
        int n = s.length();
        int[][][] dp = new int[n][n][2];
        char[] chars = s.toCharArray();
        // 初始化
        for (int i = 0; i < n; i += 2) {
            int z = chars[i] == '0' ? 1 : 0;
            dp[i][i][0] = z;
            dp[i][i][1] = 1 - z;
        }
        for (int step = 2; step < n; step += 2) {
            for (int i = 0; i + step < n; i += 2) {
                for (int j = i + 1; j < i + step; j += 2) {
                    int left0 = dp[i][j - 1][0], left1 = dp[i][j - 1][1];
                    int right0 = dp[j + 1][i + step][0], right1 = dp[j + 1][i + step][1];
                    switch (chars[j]) {
                        case '&' -> {
                            dp[i][i + step][1] += left1 * right1;
                            dp[i][i + step][0] += left0 * right0 + left0 * right1 + left1 * right0;
                        }
                        case '|' -> {
                            dp[i][i + step][0] += left0 * right0;
                            dp[i][i + step][1] += left0 * right1 + left1 * right0 + left1 * right1;
                        }
                        case '^' -> {
                            dp[i][i + step][0] += left0 * right0 + left1 * right1;
                            dp[i][i + step][1] += left1 * right0 + left0 * right1;
                        }
                    }
                }
            }
        }
        return dp[0][n - 1][result];
    }
}
```

## part10：算法2（二分查找、哈希）

### [01. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 m 和 n。

示例:

> 输入:
> A = [1,2,3,0,0,0], m = 3
> B = [2,5,6],       n = 3
>
> 输出: [1,2,2,3,5,6]
>

```java
package com.yubin.part10;

/**
 * @author MIIAMOR
 * @date 2021/7/2 13:30
 */
public class Merge {
    public void merge(int[] A, int m, int[] B, int n) {
        int[] T = new int[m];
        System.arraycopy(A, 0, T, 0, m);
        int index = 0, i = 0, j = 0;
        while (i < m && j < n) {
            if (T[i] < B[j]) A[index++] = T[i++];
            else A[index++] = B[j++];
        }
        while (i < m) A[index++] = T[i++];
        while (j < n) A[index++] = B[j++];
    }
}
```

### [02. 变位词组](https://leetcode-cn.com/problems/group-anagrams-lcci/)

编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。

注意：本题相对原题稍作修改

示例:

> 输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
> 输出:
> [
>   ["ate","eat","tea"],
>   ["nat","tan"],
>   ["bat"]
> ]

```java
package com.yubin.part10;

import java.util.*;

/**
 * @author MIIAMOR
 * @date 2021/7/3 14:14
 */
public class GroupAnagrams {
    private Map<String, Integer> map;
    private Integer index;
    private List<List<String>> res;

    public List<List<String>> groupAnagrams(String[] strs) {
        map = new HashMap<>();
        res = new ArrayList<>();
        index = 0;
        for (String str : strs) {
            putIn(str);
        }
        return res;
    }

    public void putIn(String s) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String ss = String.valueOf(chars);
        if (map.containsKey(ss)) {
            res.get(map.get(ss)).add(s);
        } else {
            map.put(ss, index++);
            List<String> list = new ArrayList<>();
            list.add(s);
            res.add(list);
        }
    }
}
```

### [03. 搜索旋转数组](https://leetcode-cn.com/problems/search-rotate-array-lcci/)

[相关题目](https://leetcode-cn.com/problems/search-rotate-array-lcci/solution/xuan-zhuan-shu-zu-cong-yi-dao-nan-ge-ge-dcv7a/)

搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

示例1:

 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）

```java
package com.yubin.part10;

/**
 * @author MIIAMOR
 * @date 2021/7/3 21:16
 */
public class Search {
    public int search(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        int mid = 0;
        while (left <= right) {
            if (arr[left] == target) return left;
            mid = (right + left) / 2;
            if (arr[mid] == target) right = mid;
            else if (arr[0] < arr[mid]) {
                if (arr[0] <= target && target < arr[mid]) right = mid - 1;
                else left = mid + 1;
            } else if (arr[0] > arr[mid]) {
                if (arr[mid] < target && target <= arr[arr.length - 1]) left = mid + 1;
                else right = mid - 1;
            } else left++;
        }
        return -1;
    }

    public int search1(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) return i;
        }
        return -1;
    }
}
```

### [05. 稀疏数组搜索](https://leetcode-cn.com/problems/sparse-array-search-lcci/)

稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。

```java
package com.yubin.part10;

import java.util.Collections;

/**
 * @author MIIAMOR
 * @date 2021/7/5 19:01
 */
public class FindString {
    public int findString(String[] words, String s) {
        int left = 0, right = words.length - 1;
        while (left <= right) {
            int mid = (right + left) / 2;
            while (mid > left && words[mid].equals("")) mid--;
            if (s.equals(words[mid])) return mid;
            else if (s.compareTo(words[mid]) > 0) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }

    public int findString1(String[] words, String s) {
        int index = 0;
        for (String word : words) {
            if (word.equals(s)) return index;
            index++;
        }
        return -1;
    }
}
```

### [09. 排序矩阵查找](https://leetcode-cn.com/problems/sorted-matrix-search-lcci/)

给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。

示例:

现有矩阵 matrix 如下：

> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]

```java
package com.yubin.part10;

/**
 * @author MIIAMOR
 * @date 2021/7/5 19:49
 */
public class SearchMatrix {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        int i = 0, j = matrix[0].length - 1;
        int rows = matrix.length;
        while (i < rows && j >= 0) {
            if (matrix[i][j] == target) return true;
            else if (matrix[i][j] > target) j--;
            else i++;
        }
        return false;
    }

    public boolean searchMatrix1(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        for (int[] nums : matrix) {
            for (int num : nums) {
                if (num == target) return true;
            }
        }
        return false;
    }
}
```

### [10. 数字流的秩](https://leetcode-cn.com/problems/rank-from-stream-lcci/)（进阶：树状数组）

假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：

实现 track(int x) 方法，每读入一个数字都会调用该方法；

实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。

注意：本题相对原题稍作改动

示例:

输入:

```java
["StreamRank", "getRankOfNumber", "track", "getRankOfNumber"]
[[], [1], [0], [0]]
输出:
[null,0,null,1]
```

```java
package com.yubin.part10;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/7/7 21:29
 */
public class StreamRank {
    private List<Integer> list;

    public StreamRank() {
        list = new ArrayList<>();
    }

    public void track(int x) {
        list.add(x);
    }

    public int getRankOfNumber(int x) {
        int count = 0;
        for (Integer i : list) {
            if (i <= x) count++;
        }
        return count;
    }
}
```

### [11. 峰与谷](https://leetcode-cn.com/problems/peaks-and-valleys-lcci/)

在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。

示例:

> 输入: [5, 3, 1, 2, 3]
> 输出: [5, 1, 3, 2, 3]

```java
package com.yubin.part10;

import java.util.Arrays;

/**
 * @author MIIAMOR
 * @date 2021/7/8 18:43
 */
public class WiggleSort {
    public void wiggleSort(int[] nums) {
        Arrays.sort(nums);
        int[] numsTmp = Arrays.copyOf(nums, nums.length);
        boolean flag = true;
        int left = 0, right = numsTmp.length - 1;
        int index = 0;
        while (left <= right) {
            if (flag) {
                nums[index++] = numsTmp[right--];
            } else nums[index++] = numsTmp[left++];
            flag = !flag;
        }
    }
}
```

## part16：算法进阶1（位运算、数学）

### [01. 交换数字](https://leetcode-cn.com/problems/swap-numbers-lcci/)

编写一个函数，不用临时变量，直接交换`numbers = [a, b]`中`a`与`b`的值。

`根据a^b^a=b,进行计算`

```java
package com.yubin.part16;

/**
 * @author MIIAMOR
 * @date 2021/7/13 16:34
 */
public class SwapNumbers {
    public int[] swapNumbers(int[] numbers) {
        numbers[0] ^= numbers[1];
        numbers[1] ^= numbers[0];
        numbers[0] ^= numbers[1];
        return numbers;
    }
}
```

### [02. 单词频率](https://leetcode-cn.com/problems/words-frequency-lcci/)

设计一个方法，找出任意指定单词在一本书中的出现频率。

你的实现应该支持如下操作：

`WordsFrequency(book)`构造函数，参数为字符串数组构成的一本书
`get(word)`查询指定单词在书中出现的频率

```java
package com.yubin.part16;

import java.util.*;

/**
 * @author MIIAMOR
 * @date 2021/7/13 16:38
 */
public class WordsFrequency {
    Map<String, Integer> map;

    public WordsFrequency(String[] book) {
        map = new HashMap<>();
        int index = 0;
        for (String s : book) {
            map.put(s, map.getOrDefault(s, 0) + 1);
        }
    }

    public int get(String word) {
        return map.getOrDefault(word, 0);
    }
}
```

### *[03. 交点](https://leetcode-cn.com/problems/intersection-lcci/)

给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。

要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。



### [04. 井字游戏](https://leetcode-cn.com/problems/tic-tac-toe-lcci/)

设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符" "，"X"和"O"组成，其中字符" "代表一个空位。

以下是井字游戏的规则：

玩家轮流将字符放入空位（" "）中。
第一个玩家总是放字符"O"，且第二个玩家总是放字符"X"。
"X"和"O"只允许放置在空位中，不允许对已放有字符的位置进行填充。
当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。
当所有位置非空时，也算为游戏结束。
如果游戏结束，玩家不允许再放置字符。
如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（"X"或"O"）；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。

```java
package com.yubin.part16;

/**
 * @author MIIAMOR
 * @date 2021/7/13 18:35
 */
public class Tictactoe {
    public String tictactoe(String[] board) {
        int n = board.length;
        int empty = 0;// 记录空的数量
        int[] rows = new int[n], cols = new int[n];// 记录X和O
        int left = 0, right = 0;// 左斜和右斜的数量
        for (int i = 0; i < n; i++) {
            char[] chars = board[i].toCharArray();
            for (int j = 0; j < n; j++) {
                char c = chars[j];
                if (c == 'X') {
                    rows[i]++;
                    cols[j]++;
                    if (i == j) left++;
                    if (i + j + 1 == n) right++;
                } else if (c == 'O') {
                    rows[i]--;
                    cols[j]--;
                    if (i == j) left--;
                    if (i + j + 1 == n) right--;
                } else {
                    empty++;
                    continue;
                }
                if (j == n - 1) {
                    if (rows[i] == n) return "X";
                    if (rows[i] == -n) return "O";
                }
                if (i == n - 1) {
                    if (cols[j] == n) return "X";
                    if (cols[j] == -n) return "O";
                }
            }
        }
        if (left == n || right == n) return "X";
        else if (left == -n || right == -n) return "O";
        else if (empty == 0) return "Draw";
        else return "Pending";
    }
}
```

### [05. 阶乘尾数](https://leetcode-cn.com/problems/factorial-zeros-lcci/)

设计一个算法，算出 n 阶乘有多少个尾随零。

```java
package com.yubin.part16;

/**
 * @author MIIAMOR
 * @date 2021/7/13 19:12
 */
public class TrailingZeroes {
    public int trailingZeroes(int n) {
        return countFive(n);
    }

    private int countFive(int n) {
        int count = 0;
        while (n != 0) {
            n /= 5;
            count += n;
        }
        return count;
    }
}
```

### [06. 最小差](https://leetcode-cn.com/problems/smallest-difference-lcci/)

给定两个整数数组`a`和`b`，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差

```java
package com.yubin.part16;

import java.util.Arrays;

/**
 * @author MIIAMOR
 * @date 2021/7/13 19:48
 */
public class SmallestDifference {
    public int smallestDifference(int[] a, int[] b) {
        Arrays.sort(a);
        Arrays.sort(b);
        long res = Integer.MAX_VALUE;
        int left1 = 0, left2 = 0;
        int n1 = a.length, n2 = b.length;
        while (left1 < n1 && left2 < n2) {
            res = Math.min(res, Math.abs((long) a[left1] - b[left2]));
            if (a[left1] < b[left2]) left1++;
            else left2++;
        }
        while (left1 < n1) {
            res = Math.min(res, Math.abs(a[left1] - b[left2 - 1]));
            left1++;
        }
        while (left2 < n2) {
            res = Math.min(res, Math.abs(a[left1 - 1] - b[left2]));
            left2++;
        }
        return (int) res;
    }
}
```

### *[07. 最大数值](https://leetcode-cn.com/problems/maximum-lcci/)

编写一个方法，找出两个数字`a`和`b`中最大的那一个。不得使用if-else或其他比较运算符。

```java
package com.yubin.part16;

/**
 * @author MIIAMOR
 * @date 2021/7/13 20:04
 */
public class Maximum {
    public int maximum(int a, int b) {
        return Math.max(a, b);
    }
}
```

### *[08. 整数的英语表示](https://leetcode-cn.com/problems/english-int-lcci/)