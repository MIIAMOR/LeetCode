# 面试金典

## part01：字符串

### [01. 判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

示例 1：

> 输入: s = "leetcode"
> 输出: false 

示例 2：

> 输入: s = "abc"
> 输出: true

- 如果你不使用额外的数据结构，会很加分。

```java
package com.yubin.part01;

import java.sql.Array;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * @author MIIAMOR
 * @date 2021/6/23 19:31
 * easy
 */
public class IsUnique {
    /**
     * 哈希集合存储
     */
    public boolean isUnique(String astr) {
        char[] chars = astr.toCharArray();
        Set<Character> set = new HashSet<>();
        for (char c : chars) {
            if (set.contains(c)) return false;
            set.add(c);
        }
        return true;
    }

    /**
     * 暴力枚举法
     */
    public boolean isUnique1(String astr) {
        char[] chars = astr.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            for (int j = i + 1; j < chars.length; j++) {
                if (chars[i] == chars[j]) return false;
            }
        }
        return true;
    }

    /**
     * 排序后对比
     */
    public boolean isUnique2(String astr) {
        char[] chars = astr.toCharArray();
        Arrays.sort(chars);
        for (int i = 0; i < chars.length - 1; i++) {
            if (chars[i] == chars[i + 1]) return false;
        }
        return true;
    }

    /**
     * 数组计数法
     */
    public boolean isUnique3(String astr) {
        int[] count = new int[128];
        for (int i = 0; i < astr.length(); i++) {
            char c = astr.charAt(i);
            if (count[c] != 0) return false;
            count[c]++;
        }
        return true;
    }

    /**
     * 假设题目中使用的字符数为26个小写字符
     * 使用位运算算法
     * << 是左移运算符
     */
    public boolean isUnique4(String astr) {
        int count = 0, base = 1, countChar;
        for (char c : astr.toCharArray()) {
            int offset = c - 'a';
            countChar = base << offset;
            if ((count & countChar) > 0) return false;
            count |= countChar;
        }
        return true;
    }
}
```

### [02. 判定是否互为字符重排](https://leetcode-cn.com/problems/check-permutation-lcci/)

给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

示例 1：

> 输入: s1 = "abc", s2 = "bca"
> 输出: true 

```java
package com.yubin.part01;

import java.util.Arrays;

/**
 * @author MIIAMOR
 * @date 2021/6/23 19:52
 * easy
 */
public class CheckPermutation {
    /**
     * 假设使用到的字符数是26个小写字符
     */
    public boolean checkPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int[] countS1 = new int[26], countS2 = new int[26];
        int len = s1.length();
        for (int i = 0; i < len; i++) {
            countS1[s1.charAt(i) - 'a']++;
            countS2[s2.charAt(i) - 'a']++;
        }
        return Arrays.equals(countS1, countS2);
    }
}
```

### [03. URL化](https://leetcode-cn.com/problems/string-to-url-lcci/)

URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）

 

示例 1：

> 输入："Mr John Smith    ", 13
> 输出："Mr%20John%20Smith"

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/23 20:03
 * easy
 */
public class ReplaceSpaces {
    public String replaceSpaces(String S, int length) {
        StringBuilder sb = new StringBuilder();
        char[] chars = S.toCharArray();
        for (int i = 0; i < length; i++) {
            if (chars[i] == ' ') sb.append("%20");
            else sb.append(chars[i]);
        }
        return sb.toString();
    }

    public String replaceSpaces1(String S, int length) {
        String s = S.substring(0, length);
        s = s.replace(" ", "%20");
        return s;
    }
}
```

### [04. 回文排列](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。

回文串不一定是字典当中的单词。

 

示例1：

> 输入："tactcoa"
> 输出：true（排列有"tacocat"、"atcocta"，等等）

```java
package com.yubin.part01;

import java.util.HashSet;
import java.util.Set;

/**
 * @author MIIAMOR
 * @date 2021/6/23 20:36
 * easy
 */
public class CanPermutePalindrome {
    public boolean canPermutePalindrome(String s) {
        int odd = 0;
        int[] count = new int[256];
        char[] chars = s.toCharArray();
        for (char c : chars) {
            count[c]++;
        }
        for (int i : count) {
            if (i % 2 == 1) odd++;
        }
        return odd <= 1;
    }

    public boolean canPermutePalindrome1(String s) {
        Set<Character> set = new HashSet<>();
        for (char c : s.toCharArray()) {
            if (!set.contains(c)) set.add(c);
            else set.remove(c);
        }
        return set.size() <= 1;
    }
}
```

### [05. 一次编辑](https://leetcode-cn.com/problems/one-away-lcci/)

字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

 

示例 1:

> 输入: 
> first = "pale"
> second = "ple"
> 输出: True

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 8:58
 * medium
 */
public class OneEditAway {
    public boolean oneEditAway(String first, String second) {
        int len1 = first.length(), len2 = second.length();
        if (Math.abs(len1 - len2) > 1) return false;
        if ((len1 == 1 && len2 == 0) || (len1 == 0 && len2 == 1) || (len1 == 1 && len2 == 1) || (len1 == 0 && len2 == 0))
            return true;
        char[] firstC = first.toCharArray(), secondC = second.toCharArray();
        int count = 0;
        int i = 0, j = 0;
        while (i < len1 && j < len2) {
            if (count > 1) break;
            if (firstC[i] == secondC[j]) {
                i++;
                j++;
            } else {
                if (len1 < len2) {
                    // len1小 选择在first上添加一个字符
                    count++;
                    j++;
                } else if (len1 > len2) {
                    // len1大 选择在first上删除一个字符
                    count++;
                    i++;
                } else {
                    // 一样大 选择在first上替换一个字符
                    count++;
                    i++;
                    j++;
                }
            }
        }
        return count <= 1;
    }
}
```

### [06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

示例1:

>  输入："aabcccccaaa"
>  输出："a2b1c5a3"

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 9:11
 * easy
 */
public class CompressString {
    public String compressString(String S) {
        if (S == null) return null;
        if (S.length() == 0) return S;
        StringBuilder sb = new StringBuilder();
        char[] chars = S.toCharArray();
        int count = 1;
        char pre = chars[0];
        for (int i = 1; i < chars.length; i++) {
            if (chars[i] == pre) count++;
            else {
                sb.append(pre).append(count);
                pre = chars[i];
                count = 1;
            }
        }
        sb.append(pre).append(count);
        return sb.length() < S.length() ? sb.toString() : S;
    }

    public static void main(String[] args) {
        new CompressString().compressString(
                "aabcccccaa");
    }
}
```

### [07. 旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/)

给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

 

示例 1:

> 给定 matrix = 
> [
> [1,2,3],
> [4,5,6],
> [7,8,9]
> ],
>
> 原地旋转输入矩阵，使其变为:
> [
> [7,4,1],
> [8,5,2],
> [9,6,3]
> ]

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 9:38
 * medium
 */
public class Rotate {
    /**
     * 只在原地修改矩阵
     * 本题难点是坐标变换
     */
    public void rotate(int[][] matrix) {
        int N = matrix.length;
        int num, numNext;
        for (int i = 0; i < N / 2; i++) {
            for (int j = i; j < N - 1 - i; j++) {
                int index1 = i, index2 = j;

                num = matrix[index1][index2];
                index1 = index2;
                index2 = N - 1 - i;
                numNext = matrix[index1][index2];
                matrix[index1][index2] = num;

                num = numNext;
                index1 = index2;
                index2 = N - 1 - j;
                numNext = matrix[index1][index2];
                matrix[index1][index2] = num;

                num = numNext;
                index1 = index2;
                index2 = i;
                numNext = matrix[index1][index2];
                matrix[index1][index2] = num;

                matrix[i][j] = numNext;
            }
        }
    }

    public void rotate1(int[][] matrix) {
        int N = matrix.length;
        int[][] rotateMatrix = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                rotateMatrix[j][N - 1 - i] = matrix[i][j];
            }
        }
        matrix = rotateMatrix;
    }

    public static void main(String[] args) {
        new Rotate().rotate(new int[][]{
                {5, 1, 9, 11},
                {2, 4, 8, 10},
                {13, 3, 6, 7},
                {15, 14, 12, 16}
        });
        new Rotate().rotate(new int[][]{
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9}
        });
    }
}
```

### [08. 零矩阵](https://leetcode-cn.com/problems/zero-matrix-lcci/)

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

 

示例 1：

> 输入：
> [
> [1,1,1],
> [1,0,1],
> [1,1,1]
> ]
> 输出：
> [
> [1,0,1],
> [0,0,0],
> [1,0,1]
> ]

```java
package com.yubin.part01;

import java.util.HashSet;
import java.util.Set;

/**
 * @author MIIAMOR
 * @date 2021/6/24 10:37
 * medium
 */
public class SetZeroes {
    public void setZeroes(int[][] matrix) {
        int M = matrix.length, N = matrix[0].length;
        Set<Integer> cols = new HashSet<>(), rows = new HashSet<>();
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] == 0) {
                    cols.add(j);
                    rows.add(i);
                }
            }
        }
        for (Integer col : cols) {
            for (int i = 0; i < M; i++) {
                matrix[i][col] = 0;
            }
        }
        for (Integer row : rows) {
            for (int i = 0; i < N; i++) {
                matrix[row][i] = 0;
            }
        }
    }

    public void setZeroes1(int[][] matrix) {
        int M = matrix.length, N = matrix[0].length;
        boolean[] rows = new boolean[M], cols = new boolean[N];
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] == 0) {
                    rows[i] = true;
                    cols[j] = true;
                }
            }
        }
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (rows[i] || cols[j]) matrix[i][j] = 0;
            }
        }
    }
}
```

### [09. 字符串轮转](https://leetcode-cn.com/problems/string-rotation-lcci/)

字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。

示例1:

>  输入：s1 = "waterbottle", s2 = "erbottlewat"
>  输出：True

```java
package com.yubin.part01;

/**
 * @author MIIAMOR
 * @date 2021/6/24 10:52
 * easy
 */
public class IsFlippedString {
    public boolean isFlippedString(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int len = s1.length();
        for (int i = 0; i < len; i++) {
            if (s1.substring(0, i).equals(s2.substring(len - i))
                    && s1.substring(i).equals(s2.substring(0, len - i)))
                return true;
        }
        return len == 0;
    }

    /**
     * 大佬的解法
     */
    public boolean isFlippedString1(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        String s = s2 + s2;
        return s.contains(s1);
    }

    public static void main(String[] args) {
        new IsFlippedString().isFlippedString("WaterBottle", "erBottleWat");
    }
}
```

## part02：链表

### [01. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

**示例1:**

>  输入：[1, 2, 3, 3, 2, 1]
>  输出：[1, 2, 3]

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

import java.util.*;

/**
 * @author MIIAMOR
 * @date 2021/6/24 13:09
 * easy
 */
public class RemoveDuplicateNodes {
    public ListNode removeDuplicateNodes(ListNode head) {
        if (head == null) return null;
        ListNode n = head;
        List<Integer> list = new ArrayList<>();
        while (n != null) {
            if (!list.contains(n.val))
                list.add(n.val);
            n = n.next;
        }
        n = new ListNode(list.get(0));
        ListNode res = n;
        for (int i = 1; i < list.size(); i++) {
            n.next = new ListNode(list.get(i));
            n = n.next;
        }
        return res;
    }

    public ListNode removeDuplicateNodes1(ListNode head) {
        if (head == null) return null;
        Set<Integer> set = new HashSet<>();
        ListNode n = head;
        ListNode listNode = new ListNode(n.val);
        ListNode res = listNode;
        set.add(n.val);
        while (n != null) {
            if (!set.contains(n.val)) {
                listNode.next = new ListNode(n.val);
                set.add(n.val);
                listNode = listNode.next;
            }
            n = n.next;
        }
        return res;
    }

    public ListNode removeDuplicateNodes2(ListNode head) {
        if (head == null) return null;
        Set<Integer> set = new HashSet<>();
        ListNode n = head;
        set.add(n.val);
        while (n.next != null) {
            if (!set.contains(n.next.val)) {
                set.add(n.next.val);
                n = n.next;
            } else
                n.next = n.next.next;
        }
        return head;
    }

    /**
     * 作弊版哈希表
     */
    public ListNode removeDuplicateNodes3(ListNode head) {
        if (head == null) return null;
        byte[] occurred = new byte[20000];
        ListNode n = head;
        occurred[n.val] = 1;
        while (n.next != null) {
            if (occurred[n.next.val] == 0) {
                occurred[n.next.val] = 1;
                n = n.next;
            } else
                n.next = n.next.next;
        }
        return head;
    }
}
```

### [02. 返回倒数第 k 个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

示例：

> 输入： 1->2->3->4->5 和 k = 2
> 输出： 4

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/24 16:07
 * easy
 */
public class KthToLast {
    public int kthToLast(ListNode head, int k) {
        ListNode n = head;
        List<Integer> list = new ArrayList<>();
        while (n != null) {
            list.add(n.val);
            n = n.next;
        }
        return list.get(list.size() - k);
    }

    /**
     * 双指针解法：第一个指针走k步，两个指针同时走，当一个指针走到了null
     * 第二个指针就走到了倒数第k个位置
     */
    public int kthToLast1(ListNode head, int k) {
        ListNode n = head;
        ListNode res = head;
        for (int i = 0; i < k; i++) {
            n = n.next;
        }
        while (n != null) {
            res = res.next;
            n = n.next;
        }
        return res.val;
    }
}
```

### [03. 删除中间节点](https://leetcode-cn.com/problems/delete-middle-node-lcci/)

若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。

假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。

例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f

 

示例：

> 输入：节点 5 （位于单向链表 4->5->1->9 中）
> 输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 9:15
 * easy
 */
public class DeleteNode {
    /**
     * 删除链表中间节点
     *
     * @param node
     */
    public void deleteNode1(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }

    public void deleteNode(ListNode node) {
        ListNode pre = node;
        node.val = node.next.val;
        node = node.next;
        while (node.next != null) {
            node.val = node.next.val;
            node = node.next;
            pre = pre.next;
        }
        pre.next = null;
    }
}
```

### [04. 分割链表](https://leetcode-cn.com/problems/partition-list-lcci/)

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

> 输入: head = 3->5->8->5->10->2->1, x = 5
> 输出: 3->1->2->10->5->5->8

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 9:25
 * medium
 */
public class Partition {
    /**
     * 有点没看懂题目,不是说x的节点必须在右边，不能在交界处
     */
    public ListNode partition(ListNode head, int x) {
        ListNode left = new ListNode(x), res = left;
        ListNode mid = new ListNode(x), midRes = mid;
        ListNode right = new ListNode(x), rightRes = right;
        while (head != null) {
            if (head.val < x) {
                left.next = head;
                left = left.next;
            } else if (head.val > x) {
                mid.next = head;
                mid = mid.next;
            } else {
                right.next = head;
                right = right.next;
            }
            head = head.next;
        }
        right.next = null;
        mid.next = rightRes.next;
        left.next = midRes.next;
        return res.next;
    }

    public ListNode partition1(ListNode head, int x) {
        ListNode left = new ListNode(x), leftRes = left;
        ListNode right = new ListNode(x), rightRes = right;
        while (head != null) {
            if (head.val < x) {
                left.next = head;
                left = left.next;
            } else {
                right.next = head;
                right = right.next;
            }
            head = head.next;
        }
        right.next = null;
        left.next = rightRes.next;
        return leftRes.next;
    }
}
```



### [05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

 

示例：

> 输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
> 输出：2 -> 1 -> 9，即912

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 10:10
 * medium
 */
public class AddTwoNumbers {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int next = 0, currSum;
        ListNode sum = new ListNode(0), res = sum;
        while (l1 != null || l2 != null) {
            int num1 = 0, num2 = 0;
            if (l1 != null) {
                num1 = l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                num2 = l2.val;
                l2 = l2.next;
            }
            currSum = next + num1 + num2;
            sum.next = new ListNode(currSum % 10);
            sum = sum.next;
            next = currSum / 10;
        }
        if (next != 0) sum.next = new ListNode(next);
        return res.next;
    }
}
```

### [06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/)

编写一个函数，检查输入的链表是否是回文的。

 

**示例 1：**

```java
输入： 1->2
输出： false 
```

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MIIAMOR
 * @date 2021/6/25 10:20
 * easy
 */
public class IsPalindrome {
    /**
     * List记录数据
     */
    public boolean isPalindrome(ListNode head) {
        List<Integer> list = new ArrayList<>();
        ListNode n = head;
        while (n != null) {
            list.add(n.val);
            n = n.next;
        }
        for (int i = 0; i < list.size() / 2; i++) {
            if (!list.get(i).equals(list.get(list.size() - i - 1)))
                return false;
        }
        return true;
    }

    /**
     * dfs求解
     */
    private ListNode head = null;

    public boolean isPalindrome1(ListNode head) {
        if (head == null) return true;
        this.head = head;
        return dfs(head);
    }

    private boolean dfs(ListNode n) {
        if (n.next != null && !dfs(n.next))
            return false;
        if (head.val != n.val)
            return false;
        head = head.next;
        return true;
    }
}
```

### [07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。


示例 1：

> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
> 输出：Reference of the node with value = 8
> 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 10:57
 * easy
 */
public class GetIntersectionNode {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode nodeA = headA;
        while (nodeA != null) {
            ListNode node = headB;
            while (node != null) {
                if (nodeA.equals(node)) return node;
                node = node.next;
            }
            nodeA = nodeA.next;
        }
        return null;
    }

    /**
     * 大佬解法
     * 使用两个指针：
     * 一个A走完了走B，另一个B走完了走A
     * 如果有相同节点，必然两个指针相遇
     * 如果没有相遇，两个指针都会走向null
     */
    public ListNode getIntersectionNode1(ListNode headA, ListNode headB) {
        ListNode nodeA = headA, nodeB = headB;
        while (nodeA != nodeB) {
            nodeA = nodeA == null ? headB : nodeA.next;
            nodeB = nodeB == null ? headA : nodeB.next;
        }
        return nodeA;
    }
}
```

### [08. 环路检测](https://leetcode-cn.com/problems/linked-list-cycle-lcci/)

给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

 

示例 1：

> 输入：head = [3,2,0,-4], pos = 1
> 输出：tail connects to node index 1
> 解释：链表中有一个环，其尾部连接到第二个节点。

```java
package com.yubin.part02;

import com.yubin.basic.ListNode;

/**
 * @author MIIAMOR
 * @date 2021/6/25 17:00
 * medium
 */
public class DetectCycle {
    /**
     * 环路检测使用双指针解法解答
     * 环入口地址求解方式：数学方式
     */
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        ListNode fast = head, slow = head;
        while (true) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == null || fast.next == null) return null;
            if (fast == slow) {
                fast = head;
                while (slow != fast) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return slow;
            }
        }
    }
}
```

## part03：栈与队列

### [01. 三合一](https://leetcode-cn.com/problems/three-in-one-lcci/)

三合一。描述如何只用一个数组来实现三个栈。

你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。

构造函数会传入一个stackSize参数，代表每个栈的大小。

示例1:

>  输入：
> ["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]
> [[1], [0, 1], [0, 2], [0], [0], [0], [0]]
>  输出：
> [null, null, null, 1, -1, -1, true]
> 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。

```java
package com.yubin.part03;

/**
 * @author MIIAMOR
 * @date 2021/6/25 17:18
 * easy
 */
public class TripleInOne {
    /**
     * 使用一个数组完成三个栈的模拟
     */
    int[][] stack = null;
    int stackSize = 0;

    public TripleInOne(int stackSize) {
        stack = new int[3][stackSize + 1];
        this.stackSize = stackSize;
    }

    public void push(int stackNum, int value) {
        int index = stack[stackNum][stackSize];
        if (index == stackSize) return;
        stack[stackNum][index++] = value;
        stack[stackNum][stackSize] = index;
    }

    public int pop(int stackNum) {
        int index = stack[stackNum][stackSize];
        if (index == 0) return -1;
        stack[stackNum][stackSize] = --index;
        return stack[stackNum][index];
    }

    public int peek(int stackNum) {
        int index = stack[stackNum][stackSize];
        if (index == 0) return -1;
        return stack[stackNum][index - 1];
    }

    public boolean isEmpty(int stackNum) {
        int index = stack[stackNum][stackSize];
        return index == 0;
    }
}
```

### [02. 栈的最小值](https://leetcode-cn.com/problems/min-stack-lcci/)

请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。


示例：

> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.getMin();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.getMin();   --> 返回 -2.

```java
package com.yubin.part03;

/**
 * @author MIIAMOR
 * @date 2021/6/25 17:37
 * easy
 */
public class MinStack {
    /**
     * 辅助栈存储当前的最小元素
     */
    private Node stackHead = null;
    private Node stackPointer = null, stackMinPointer = null;

    public MinStack() {
        stackHead = new Node(Integer.MAX_VALUE);
        stackPointer = stackHead;
        stackMinPointer = new Node(Integer.MAX_VALUE);
    }

    public void push(int x) {
        stackPointer.next = new Node(x, stackPointer);
        stackMinPointer.next = new Node(Math.min(stackMinPointer.val, x), stackMinPointer);
        stackPointer = stackPointer.next;
        stackMinPointer = stackMinPointer.next;
    }

    public void pop() {
        if (stackPointer == stackHead) return;
        stackPointer = stackPointer.pre;
        stackPointer.next = null;
        stackMinPointer = stackMinPointer.pre;
        stackMinPointer.next = null;
    }

    public int top() {
        return stackPointer.val;
    }

    public int getMin() {
        return stackMinPointer.val;
    }

    private static class Node {
        public int val;
        public Node pre;
        public Node next;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node pre) {
            this.val = val;
            this.pre = pre;
        }
    }
}
```

### [03. 堆盘子](https://leetcode-cn.com/problems/stack-of-plates-lcci/)

堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。

当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1.

示例1:

>  输入：
> ["StackOfPlates", "push", "push", "popAt", "pop", "pop"]
> [[1], [1], [2], [1], [], []]
>  输出：
> [null, null, null, 2, 1, -1]

```java
package com.yubin.part03;

/**
 * @author MIIAMOR
 * @date 2021/6/25 19:20
 * medium
 */
public class StackOfPlates {
    private final Node stackHead;
    private Node stackPointer;
    private final int cap;
    private int length;

    public StackOfPlates(int cap) {
        this.cap = cap;
        stackHead = new Node(null);
        stackPointer = stackHead;
        this.length = 0;
    }

    public void push(int val) {
        if (cap == 0) return;
        if (stackPointer.size == cap || stackPointer == stackHead) {
            stackPointer.next = new Node(new int[cap], stackPointer);
            stackPointer = stackPointer.next;
            this.length++;
        }
        stackPointer.val[stackPointer.size++] = val;
    }

    public int pop() {
        if (stackPointer == stackHead) return -1;
        int res = stackPointer.val[--stackPointer.size];
        if (stackPointer.size == 0) {
            stackPointer = stackPointer.pre;
            stackPointer.next = null;
            this.length--;
        }
        return res;
    }

    public int popAt(int index) {
        if (index >= length) return -1;
        if (index == length - 1) return pop();
        Node node = stackHead.next;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        int res = node.val[--node.size];
        if (node.size == 0) {
            node.pre.next = node.next;
            node.next.pre = node.pre;
            this.length--;
        }
        return res;
    }

    static class Node {
        int size = 0;
        int[] val;
        Node pre;
        Node next;

        public Node(int[] val) {
            this.val = val;
        }

        public Node(int[] val, Node pre) {
            this.val = val;
            this.pre = pre;
        }
    }
}
```